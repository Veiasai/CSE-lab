// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "common.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* RPCTraceInfoProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RPCTraceInfoProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* RPCCallerContextProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RPCCallerContextProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* RpcRequestHeaderProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RpcRequestHeaderProto_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RpcRequestHeaderProto_OperationProto_descriptor_ = NULL;
const ::google::protobuf::Descriptor* RpcResponseHeaderProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RpcResponseHeaderProto_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RpcResponseHeaderProto_RpcStatusProto_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RpcResponseHeaderProto_RpcErrorCodeProto_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FsPermissionProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FsPermissionProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExtendedBlockProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExtendedBlockProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DatanodeIDProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DatanodeIDProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DatanodeInfoProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DatanodeInfoProto_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DatanodeInfoProto_AdminState_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TokenProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TokenProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* FileEncryptionInfoProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileEncryptionInfoProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* LocatedBlockProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LocatedBlockProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* LocatedBlocksProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LocatedBlocksProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestHeaderProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestHeaderProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* StorageInfoProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StorageInfoProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlockKeyProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlockKeyProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExportedBlockKeysProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExportedBlockKeysProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DatanodeRegistrationProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DatanodeRegistrationProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegisterDatanodeRequestProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterDatanodeRequestProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegisterDatanodeResponseProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterDatanodeResponseProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DatanodeHeartbeatRequestProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DatanodeHeartbeatRequestProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DatanodeHeartbeatResponseProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DatanodeHeartbeatResponseProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataTransferTraceInfoProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataTransferTraceInfoProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* BaseHeaderProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BaseHeaderProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientOperationHeaderProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientOperationHeaderProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* OpTransferBlockProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OpTransferBlockProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* OpBlockChecksumResponseProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OpBlockChecksumResponseProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChecksumProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChecksumProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReadOpChecksumInfoProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReadOpChecksumInfoProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlockOpResponseProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlockOpResponseProto_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RpcKindProto_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* StorageTypeProto_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CipherSuiteProto_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CryptoProtocolVersionProto_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ChecksumTypeProto_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Status_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_common_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_common_2eproto() {
  protobuf_AddDesc_common_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "common.proto");
  GOOGLE_CHECK(file != NULL);
  RPCTraceInfoProto_descriptor_ = file->message_type(0);
  static const int RPCTraceInfoProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCTraceInfoProto, traceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCTraceInfoProto, parentid_),
  };
  RPCTraceInfoProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RPCTraceInfoProto_descriptor_,
      RPCTraceInfoProto::default_instance_,
      RPCTraceInfoProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCTraceInfoProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(RPCTraceInfoProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCTraceInfoProto, _internal_metadata_),
      -1);
  RPCCallerContextProto_descriptor_ = file->message_type(1);
  static const int RPCCallerContextProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCCallerContextProto, context_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCCallerContextProto, signature_),
  };
  RPCCallerContextProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RPCCallerContextProto_descriptor_,
      RPCCallerContextProto::default_instance_,
      RPCCallerContextProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCCallerContextProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(RPCCallerContextProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCCallerContextProto, _internal_metadata_),
      -1);
  RpcRequestHeaderProto_descriptor_ = file->message_type(2);
  static const int RpcRequestHeaderProto_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcRequestHeaderProto, rpckind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcRequestHeaderProto, rpcop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcRequestHeaderProto, callid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcRequestHeaderProto, clientid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcRequestHeaderProto, retrycount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcRequestHeaderProto, traceinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcRequestHeaderProto, callercontext_),
  };
  RpcRequestHeaderProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RpcRequestHeaderProto_descriptor_,
      RpcRequestHeaderProto::default_instance_,
      RpcRequestHeaderProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcRequestHeaderProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(RpcRequestHeaderProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcRequestHeaderProto, _internal_metadata_),
      -1);
  RpcRequestHeaderProto_OperationProto_descriptor_ = RpcRequestHeaderProto_descriptor_->enum_type(0);
  RpcResponseHeaderProto_descriptor_ = file->message_type(3);
  static const int RpcResponseHeaderProto_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcResponseHeaderProto, callid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcResponseHeaderProto, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcResponseHeaderProto, serveripcversionnum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcResponseHeaderProto, exceptionclassname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcResponseHeaderProto, errormsg_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcResponseHeaderProto, errordetail_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcResponseHeaderProto, clientid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcResponseHeaderProto, retrycount_),
  };
  RpcResponseHeaderProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RpcResponseHeaderProto_descriptor_,
      RpcResponseHeaderProto::default_instance_,
      RpcResponseHeaderProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcResponseHeaderProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(RpcResponseHeaderProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RpcResponseHeaderProto, _internal_metadata_),
      -1);
  RpcResponseHeaderProto_RpcStatusProto_descriptor_ = RpcResponseHeaderProto_descriptor_->enum_type(0);
  RpcResponseHeaderProto_RpcErrorCodeProto_descriptor_ = RpcResponseHeaderProto_descriptor_->enum_type(1);
  FsPermissionProto_descriptor_ = file->message_type(4);
  static const int FsPermissionProto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsPermissionProto, perm_),
  };
  FsPermissionProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      FsPermissionProto_descriptor_,
      FsPermissionProto::default_instance_,
      FsPermissionProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsPermissionProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(FsPermissionProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsPermissionProto, _internal_metadata_),
      -1);
  ExtendedBlockProto_descriptor_ = file->message_type(5);
  static const int ExtendedBlockProto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, poolid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, blockid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, generationstamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, numbytes_),
  };
  ExtendedBlockProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ExtendedBlockProto_descriptor_,
      ExtendedBlockProto::default_instance_,
      ExtendedBlockProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(ExtendedBlockProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, _internal_metadata_),
      -1);
  DatanodeIDProto_descriptor_ = file->message_type(6);
  static const int DatanodeIDProto_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, ipaddr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, datanodeuuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, xferport_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, infoport_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, ipcport_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, infosecureport_),
  };
  DatanodeIDProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DatanodeIDProto_descriptor_,
      DatanodeIDProto::default_instance_,
      DatanodeIDProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(DatanodeIDProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, _internal_metadata_),
      -1);
  DatanodeInfoProto_descriptor_ = file->message_type(7);
  static const int DatanodeInfoProto_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, capacity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, dfsused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, remaining_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, blockpoolused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, lastupdate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, xceivercount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, nondfsused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, adminstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, cachecapacity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, cacheused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, lastupdatemonotonic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, upgradedomain_),
  };
  DatanodeInfoProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DatanodeInfoProto_descriptor_,
      DatanodeInfoProto::default_instance_,
      DatanodeInfoProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(DatanodeInfoProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, _internal_metadata_),
      -1);
  DatanodeInfoProto_AdminState_descriptor_ = DatanodeInfoProto_descriptor_->enum_type(0);
  TokenProto_descriptor_ = file->message_type(8);
  static const int TokenProto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TokenProto, identifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TokenProto, password_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TokenProto, kind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TokenProto, service_),
  };
  TokenProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TokenProto_descriptor_,
      TokenProto::default_instance_,
      TokenProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TokenProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(TokenProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TokenProto, _internal_metadata_),
      -1);
  FileEncryptionInfoProto_descriptor_ = file->message_type(9);
  static const int FileEncryptionInfoProto_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEncryptionInfoProto, suite_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEncryptionInfoProto, cryptoprotocolversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEncryptionInfoProto, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEncryptionInfoProto, iv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEncryptionInfoProto, keyname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEncryptionInfoProto, ezkeyversionname_),
  };
  FileEncryptionInfoProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      FileEncryptionInfoProto_descriptor_,
      FileEncryptionInfoProto::default_instance_,
      FileEncryptionInfoProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEncryptionInfoProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(FileEncryptionInfoProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileEncryptionInfoProto, _internal_metadata_),
      -1);
  LocatedBlockProto_descriptor_ = file->message_type(10);
  static const int LocatedBlockProto_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, b_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, locs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, corrupt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, blocktoken_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, iscached_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, storagetypes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, storageids_),
  };
  LocatedBlockProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LocatedBlockProto_descriptor_,
      LocatedBlockProto::default_instance_,
      LocatedBlockProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(LocatedBlockProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, _internal_metadata_),
      -1);
  LocatedBlocksProto_descriptor_ = file->message_type(11);
  static const int LocatedBlocksProto_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, filelength_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, blocks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, underconstruction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, lastblock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, islastblockcomplete_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, fileencryptioninfo_),
  };
  LocatedBlocksProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LocatedBlocksProto_descriptor_,
      LocatedBlocksProto::default_instance_,
      LocatedBlocksProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(LocatedBlocksProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, _internal_metadata_),
      -1);
  RequestHeaderProto_descriptor_ = file->message_type(12);
  static const int RequestHeaderProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeaderProto, methodname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeaderProto, declaringclassprotocolname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeaderProto, clientprotocolversion_),
  };
  RequestHeaderProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestHeaderProto_descriptor_,
      RequestHeaderProto::default_instance_,
      RequestHeaderProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeaderProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestHeaderProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeaderProto, _internal_metadata_),
      -1);
  StorageInfoProto_descriptor_ = file->message_type(13);
  static const int StorageInfoProto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, layoutversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, namespceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, clusterid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, ctime_),
  };
  StorageInfoProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      StorageInfoProto_descriptor_,
      StorageInfoProto::default_instance_,
      StorageInfoProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(StorageInfoProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, _internal_metadata_),
      -1);
  BlockKeyProto_descriptor_ = file->message_type(14);
  static const int BlockKeyProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockKeyProto, keyid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockKeyProto, expirydate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockKeyProto, keybytes_),
  };
  BlockKeyProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BlockKeyProto_descriptor_,
      BlockKeyProto::default_instance_,
      BlockKeyProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockKeyProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(BlockKeyProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockKeyProto, _internal_metadata_),
      -1);
  ExportedBlockKeysProto_descriptor_ = file->message_type(15);
  static const int ExportedBlockKeysProto_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, isblocktokenenabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, keyupdateinterval_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, tokenlifetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, currentkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, allkeys_),
  };
  ExportedBlockKeysProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ExportedBlockKeysProto_descriptor_,
      ExportedBlockKeysProto::default_instance_,
      ExportedBlockKeysProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(ExportedBlockKeysProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, _internal_metadata_),
      -1);
  DatanodeRegistrationProto_descriptor_ = file->message_type(16);
  static const int DatanodeRegistrationProto_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeRegistrationProto, datanodeid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeRegistrationProto, storageinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeRegistrationProto, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeRegistrationProto, softwareversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeRegistrationProto, master_),
  };
  DatanodeRegistrationProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DatanodeRegistrationProto_descriptor_,
      DatanodeRegistrationProto::default_instance_,
      DatanodeRegistrationProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeRegistrationProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(DatanodeRegistrationProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeRegistrationProto, _internal_metadata_),
      -1);
  RegisterDatanodeRequestProto_descriptor_ = file->message_type(17);
  static const int RegisterDatanodeRequestProto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterDatanodeRequestProto, registration_),
  };
  RegisterDatanodeRequestProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RegisterDatanodeRequestProto_descriptor_,
      RegisterDatanodeRequestProto::default_instance_,
      RegisterDatanodeRequestProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterDatanodeRequestProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(RegisterDatanodeRequestProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterDatanodeRequestProto, _internal_metadata_),
      -1);
  RegisterDatanodeResponseProto_descriptor_ = file->message_type(18);
  static const int RegisterDatanodeResponseProto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterDatanodeResponseProto, registration_),
  };
  RegisterDatanodeResponseProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RegisterDatanodeResponseProto_descriptor_,
      RegisterDatanodeResponseProto::default_instance_,
      RegisterDatanodeResponseProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterDatanodeResponseProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(RegisterDatanodeResponseProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterDatanodeResponseProto, _internal_metadata_),
      -1);
  DatanodeHeartbeatRequestProto_descriptor_ = file->message_type(19);
  static const int DatanodeHeartbeatRequestProto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeHeartbeatRequestProto, id_),
  };
  DatanodeHeartbeatRequestProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DatanodeHeartbeatRequestProto_descriptor_,
      DatanodeHeartbeatRequestProto::default_instance_,
      DatanodeHeartbeatRequestProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeHeartbeatRequestProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(DatanodeHeartbeatRequestProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeHeartbeatRequestProto, _internal_metadata_),
      -1);
  DatanodeHeartbeatResponseProto_descriptor_ = file->message_type(20);
  static const int DatanodeHeartbeatResponseProto_offsets_[1] = {
  };
  DatanodeHeartbeatResponseProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DatanodeHeartbeatResponseProto_descriptor_,
      DatanodeHeartbeatResponseProto::default_instance_,
      DatanodeHeartbeatResponseProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeHeartbeatResponseProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(DatanodeHeartbeatResponseProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeHeartbeatResponseProto, _internal_metadata_),
      -1);
  DataTransferTraceInfoProto_descriptor_ = file->message_type(21);
  static const int DataTransferTraceInfoProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataTransferTraceInfoProto, traceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataTransferTraceInfoProto, parentid_),
  };
  DataTransferTraceInfoProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DataTransferTraceInfoProto_descriptor_,
      DataTransferTraceInfoProto::default_instance_,
      DataTransferTraceInfoProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataTransferTraceInfoProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(DataTransferTraceInfoProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataTransferTraceInfoProto, _internal_metadata_),
      -1);
  BaseHeaderProto_descriptor_ = file->message_type(22);
  static const int BaseHeaderProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseHeaderProto, block_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseHeaderProto, token_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseHeaderProto, traceinfo_),
  };
  BaseHeaderProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BaseHeaderProto_descriptor_,
      BaseHeaderProto::default_instance_,
      BaseHeaderProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseHeaderProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(BaseHeaderProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BaseHeaderProto, _internal_metadata_),
      -1);
  ClientOperationHeaderProto_descriptor_ = file->message_type(23);
  static const int ClientOperationHeaderProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientOperationHeaderProto, baseheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientOperationHeaderProto, clientname_),
  };
  ClientOperationHeaderProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ClientOperationHeaderProto_descriptor_,
      ClientOperationHeaderProto::default_instance_,
      ClientOperationHeaderProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientOperationHeaderProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(ClientOperationHeaderProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientOperationHeaderProto, _internal_metadata_),
      -1);
  OpTransferBlockProto_descriptor_ = file->message_type(24);
  static const int OpTransferBlockProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpTransferBlockProto, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpTransferBlockProto, targets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpTransferBlockProto, targetstoragetypes_),
  };
  OpTransferBlockProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      OpTransferBlockProto_descriptor_,
      OpTransferBlockProto::default_instance_,
      OpTransferBlockProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpTransferBlockProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(OpTransferBlockProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpTransferBlockProto, _internal_metadata_),
      -1);
  OpBlockChecksumResponseProto_descriptor_ = file->message_type(25);
  static const int OpBlockChecksumResponseProto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpBlockChecksumResponseProto, bytespercrc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpBlockChecksumResponseProto, crcperblock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpBlockChecksumResponseProto, md5_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpBlockChecksumResponseProto, crctype_),
  };
  OpBlockChecksumResponseProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      OpBlockChecksumResponseProto_descriptor_,
      OpBlockChecksumResponseProto::default_instance_,
      OpBlockChecksumResponseProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpBlockChecksumResponseProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(OpBlockChecksumResponseProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpBlockChecksumResponseProto, _internal_metadata_),
      -1);
  ChecksumProto_descriptor_ = file->message_type(26);
  static const int ChecksumProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChecksumProto, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChecksumProto, bytesperchecksum_),
  };
  ChecksumProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ChecksumProto_descriptor_,
      ChecksumProto::default_instance_,
      ChecksumProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChecksumProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(ChecksumProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChecksumProto, _internal_metadata_),
      -1);
  ReadOpChecksumInfoProto_descriptor_ = file->message_type(27);
  static const int ReadOpChecksumInfoProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadOpChecksumInfoProto, checksum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadOpChecksumInfoProto, chunkoffset_),
  };
  ReadOpChecksumInfoProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReadOpChecksumInfoProto_descriptor_,
      ReadOpChecksumInfoProto::default_instance_,
      ReadOpChecksumInfoProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadOpChecksumInfoProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(ReadOpChecksumInfoProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadOpChecksumInfoProto, _internal_metadata_),
      -1);
  BlockOpResponseProto_descriptor_ = file->message_type(28);
  static const int BlockOpResponseProto_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockOpResponseProto, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockOpResponseProto, firstbadlink_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockOpResponseProto, checksumresponse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockOpResponseProto, readopchecksuminfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockOpResponseProto, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockOpResponseProto, shortcircuitaccessversion_),
  };
  BlockOpResponseProto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BlockOpResponseProto_descriptor_,
      BlockOpResponseProto::default_instance_,
      BlockOpResponseProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockOpResponseProto, _has_bits_[0]),
      -1,
      -1,
      sizeof(BlockOpResponseProto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockOpResponseProto, _internal_metadata_),
      -1);
  RpcKindProto_descriptor_ = file->enum_type(0);
  StorageTypeProto_descriptor_ = file->enum_type(1);
  CipherSuiteProto_descriptor_ = file->enum_type(2);
  CryptoProtocolVersionProto_descriptor_ = file->enum_type(3);
  ChecksumTypeProto_descriptor_ = file->enum_type(4);
  Status_descriptor_ = file->enum_type(5);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_common_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RPCTraceInfoProto_descriptor_, &RPCTraceInfoProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RPCCallerContextProto_descriptor_, &RPCCallerContextProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RpcRequestHeaderProto_descriptor_, &RpcRequestHeaderProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RpcResponseHeaderProto_descriptor_, &RpcResponseHeaderProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      FsPermissionProto_descriptor_, &FsPermissionProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ExtendedBlockProto_descriptor_, &ExtendedBlockProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DatanodeIDProto_descriptor_, &DatanodeIDProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DatanodeInfoProto_descriptor_, &DatanodeInfoProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TokenProto_descriptor_, &TokenProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      FileEncryptionInfoProto_descriptor_, &FileEncryptionInfoProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LocatedBlockProto_descriptor_, &LocatedBlockProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LocatedBlocksProto_descriptor_, &LocatedBlocksProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestHeaderProto_descriptor_, &RequestHeaderProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      StorageInfoProto_descriptor_, &StorageInfoProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BlockKeyProto_descriptor_, &BlockKeyProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ExportedBlockKeysProto_descriptor_, &ExportedBlockKeysProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DatanodeRegistrationProto_descriptor_, &DatanodeRegistrationProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RegisterDatanodeRequestProto_descriptor_, &RegisterDatanodeRequestProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RegisterDatanodeResponseProto_descriptor_, &RegisterDatanodeResponseProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DatanodeHeartbeatRequestProto_descriptor_, &DatanodeHeartbeatRequestProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DatanodeHeartbeatResponseProto_descriptor_, &DatanodeHeartbeatResponseProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DataTransferTraceInfoProto_descriptor_, &DataTransferTraceInfoProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BaseHeaderProto_descriptor_, &BaseHeaderProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ClientOperationHeaderProto_descriptor_, &ClientOperationHeaderProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      OpTransferBlockProto_descriptor_, &OpTransferBlockProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      OpBlockChecksumResponseProto_descriptor_, &OpBlockChecksumResponseProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ChecksumProto_descriptor_, &ChecksumProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReadOpChecksumInfoProto_descriptor_, &ReadOpChecksumInfoProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BlockOpResponseProto_descriptor_, &BlockOpResponseProto::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_common_2eproto() {
  delete RPCTraceInfoProto::default_instance_;
  delete RPCTraceInfoProto_reflection_;
  delete RPCCallerContextProto::default_instance_;
  delete RPCCallerContextProto_reflection_;
  delete RpcRequestHeaderProto::default_instance_;
  delete RpcRequestHeaderProto_reflection_;
  delete RpcResponseHeaderProto::default_instance_;
  delete RpcResponseHeaderProto_reflection_;
  delete FsPermissionProto::default_instance_;
  delete FsPermissionProto_reflection_;
  delete ExtendedBlockProto::default_instance_;
  delete ExtendedBlockProto_reflection_;
  delete DatanodeIDProto::default_instance_;
  delete DatanodeIDProto_reflection_;
  delete DatanodeInfoProto::default_instance_;
  delete DatanodeInfoProto_reflection_;
  delete TokenProto::default_instance_;
  delete TokenProto_reflection_;
  delete FileEncryptionInfoProto::default_instance_;
  delete FileEncryptionInfoProto_reflection_;
  delete LocatedBlockProto::default_instance_;
  delete LocatedBlockProto_reflection_;
  delete LocatedBlocksProto::default_instance_;
  delete LocatedBlocksProto_reflection_;
  delete RequestHeaderProto::default_instance_;
  delete RequestHeaderProto_reflection_;
  delete StorageInfoProto::default_instance_;
  delete StorageInfoProto_reflection_;
  delete BlockKeyProto::default_instance_;
  delete BlockKeyProto_reflection_;
  delete ExportedBlockKeysProto::default_instance_;
  delete ExportedBlockKeysProto_reflection_;
  delete DatanodeRegistrationProto::default_instance_;
  delete DatanodeRegistrationProto_reflection_;
  delete RegisterDatanodeRequestProto::default_instance_;
  delete RegisterDatanodeRequestProto_reflection_;
  delete RegisterDatanodeResponseProto::default_instance_;
  delete RegisterDatanodeResponseProto_reflection_;
  delete DatanodeHeartbeatRequestProto::default_instance_;
  delete DatanodeHeartbeatRequestProto_reflection_;
  delete DatanodeHeartbeatResponseProto::default_instance_;
  delete DatanodeHeartbeatResponseProto_reflection_;
  delete DataTransferTraceInfoProto::default_instance_;
  delete DataTransferTraceInfoProto_reflection_;
  delete BaseHeaderProto::default_instance_;
  delete BaseHeaderProto_reflection_;
  delete ClientOperationHeaderProto::default_instance_;
  delete ClientOperationHeaderProto_reflection_;
  delete OpTransferBlockProto::default_instance_;
  delete OpTransferBlockProto_reflection_;
  delete OpBlockChecksumResponseProto::default_instance_;
  delete OpBlockChecksumResponseProto_reflection_;
  delete ChecksumProto::default_instance_;
  delete ChecksumProto_reflection_;
  delete ReadOpChecksumInfoProto::default_instance_;
  delete ReadOpChecksumInfoProto_reflection_;
  delete BlockOpResponseProto::default_instance_;
  delete BlockOpResponseProto_reflection_;
}

void protobuf_AddDesc_common_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_common_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014common.proto\"6\n\021RPCTraceInfoProto\022\017\n\007t"
    "raceId\030\001 \001(\003\022\020\n\010parentId\030\002 \001(\003\";\n\025RPCCal"
    "lerContextProto\022\017\n\007context\030\001 \002(\t\022\021\n\tsign"
    "ature\030\002 \001(\014\"\334\002\n\025RpcRequestHeaderProto\022\036\n"
    "\007rpcKind\030\001 \001(\0162\r.RpcKindProto\0224\n\005rpcOp\030\002"
    " \001(\0162%.RpcRequestHeaderProto.OperationPr"
    "oto\022\016\n\006callId\030\003 \002(\021\022\020\n\010clientId\030\004 \002(\014\022\026\n"
    "\nretryCount\030\005 \001(\021:\002-1\022%\n\ttraceInfo\030\006 \001(\013"
    "2\022.RPCTraceInfoProto\022-\n\rcallerContext\030\007 "
    "\001(\0132\026.RPCCallerContextProto\"]\n\016Operation"
    "Proto\022\024\n\020RPC_FINAL_PACKET\020\000\022\033\n\027RPC_CONTI"
    "NUATION_PACKET\020\001\022\030\n\024RPC_CLOSE_CONNECTION"
    "\020\002\"\256\005\n\026RpcResponseHeaderProto\022\016\n\006callId\030"
    "\001 \002(\r\0226\n\006status\030\002 \002(\0162&.RpcResponseHeade"
    "rProto.RpcStatusProto\022\033\n\023serverIpcVersio"
    "nNum\030\003 \001(\r\022\032\n\022exceptionClassName\030\004 \001(\t\022\020"
    "\n\010errorMsg\030\005 \001(\t\022>\n\013errorDetail\030\006 \001(\0162)."
    "RpcResponseHeaderProto.RpcErrorCodeProto"
    "\022\020\n\010clientId\030\007 \001(\014\022\026\n\nretryCount\030\010 \001(\021:\002"
    "-1\"3\n\016RpcStatusProto\022\013\n\007SUCCESS\020\000\022\t\n\005ERR"
    "OR\020\001\022\t\n\005FATAL\020\002\"\341\002\n\021RpcErrorCodeProto\022\025\n"
    "\021ERROR_APPLICATION\020\001\022\030\n\024ERROR_NO_SUCH_ME"
    "THOD\020\002\022\032\n\026ERROR_NO_SUCH_PROTOCOL\020\003\022\024\n\020ER"
    "ROR_RPC_SERVER\020\004\022\036\n\032ERROR_SERIALIZING_RE"
    "SPONSE\020\005\022\036\n\032ERROR_RPC_VERSION_MISMATCH\020\006"
    "\022\021\n\rFATAL_UNKNOWN\020\n\022#\n\037FATAL_UNSUPPORTED"
    "_SERIALIZATION\020\013\022\034\n\030FATAL_INVALID_RPC_HE"
    "ADER\020\014\022\037\n\033FATAL_DESERIALIZING_REQUEST\020\r\022"
    "\032\n\026FATAL_VERSION_MISMATCH\020\016\022\026\n\022FATAL_UNA"
    "UTHORIZED\020\017\"!\n\021FsPermissionProto\022\014\n\004perm"
    "\030\001 \002(\r\"c\n\022ExtendedBlockProto\022\016\n\006poolId\030\001"
    " \002(\t\022\017\n\007blockId\030\002 \002(\004\022\027\n\017generationStamp"
    "\030\003 \002(\004\022\023\n\010numBytes\030\004 \001(\004:\0010\"\231\001\n\017Datanode"
    "IDProto\022\016\n\006ipAddr\030\001 \002(\t\022\020\n\010hostName\030\002 \002("
    "\t\022\024\n\014datanodeUuid\030\003 \002(\t\022\020\n\010xferPort\030\004 \002("
    "\r\022\020\n\010infoPort\030\005 \002(\r\022\017\n\007ipcPort\030\006 \002(\r\022\031\n\016"
    "infoSecurePort\030\007 \001(\r:\0010\"\315\003\n\021DatanodeInfo"
    "Proto\022\034\n\002id\030\001 \002(\0132\020.DatanodeIDProto\022\023\n\010c"
    "apacity\030\002 \001(\004:\0010\022\022\n\007dfsUsed\030\003 \001(\004:\0010\022\024\n\t"
    "remaining\030\004 \001(\004:\0010\022\030\n\rblockPoolUsed\030\005 \001("
    "\004:\0010\022\025\n\nlastUpdate\030\006 \001(\004:\0010\022\027\n\014xceiverCo"
    "unt\030\007 \001(\r:\0010\022\020\n\010location\030\010 \001(\t\022\022\n\nnonDfs"
    "Used\030\t \001(\004\0229\n\nadminState\030\n \001(\0162\035.Datanod"
    "eInfoProto.AdminState:\006NORMAL\022\030\n\rcacheCa"
    "pacity\030\013 \001(\004:\0010\022\024\n\tcacheUsed\030\014 \001(\004:\0010\022\036\n"
    "\023lastUpdateMonotonic\030\r \001(\004:\0010\022\025\n\rupgrade"
    "Domain\030\016 \001(\t\"I\n\nAdminState\022\n\n\006NORMAL\020\000\022\033"
    "\n\027DECOMMISSION_INPROGRESS\020\001\022\022\n\016DECOMMISS"
    "IONED\020\002\"Q\n\nTokenProto\022\022\n\nidentifier\030\001 \002("
    "\014\022\020\n\010password\030\002 \002(\014\022\014\n\004kind\030\003 \002(\t\022\017\n\007ser"
    "vice\030\004 \002(\t\"\273\001\n\027FileEncryptionInfoProto\022 "
    "\n\005suite\030\001 \002(\0162\021.CipherSuiteProto\022:\n\025cryp"
    "toProtocolVersion\030\002 \002(\0162\033.CryptoProtocol"
    "VersionProto\022\013\n\003key\030\003 \002(\014\022\n\n\002iv\030\004 \002(\014\022\017\n"
    "\007keyName\030\005 \002(\t\022\030\n\020ezKeyVersionName\030\006 \002(\t"
    "\"\352\001\n\021LocatedBlockProto\022\036\n\001b\030\001 \002(\0132\023.Exte"
    "ndedBlockProto\022\016\n\006offset\030\002 \002(\004\022 \n\004locs\030\003"
    " \003(\0132\022.DatanodeInfoProto\022\017\n\007corrupt\030\004 \002("
    "\010\022\037\n\nblockToken\030\005 \002(\0132\013.TokenProto\022\024\n\010is"
    "Cached\030\006 \003(\010B\002\020\001\022\'\n\014storageTypes\030\007 \003(\0162\021"
    ".StorageTypeProto\022\022\n\nstorageIDs\030\010 \003(\t\"\341\001"
    "\n\022LocatedBlocksProto\022\022\n\nfileLength\030\001 \002(\004"
    "\022\"\n\006blocks\030\002 \003(\0132\022.LocatedBlockProto\022\031\n\021"
    "underConstruction\030\003 \002(\010\022%\n\tlastBlock\030\004 \001"
    "(\0132\022.LocatedBlockProto\022\033\n\023isLastBlockCom"
    "plete\030\005 \002(\010\0224\n\022fileEncryptionInfo\030\006 \001(\0132"
    "\030.FileEncryptionInfoProto\"k\n\022RequestHead"
    "erProto\022\022\n\nmethodName\030\001 \002(\t\022\"\n\032declaring"
    "ClassProtocolName\030\002 \002(\t\022\035\n\025clientProtoco"
    "lVersion\030\003 \002(\004\"_\n\020StorageInfoProto\022\025\n\rla"
    "youtVersion\030\001 \002(\r\022\022\n\nnamespceID\030\002 \002(\r\022\021\n"
    "\tclusterID\030\003 \002(\t\022\r\n\005cTime\030\004 \002(\004\"D\n\rBlock"
    "KeyProto\022\r\n\005keyId\030\001 \002(\r\022\022\n\nexpiryDate\030\002 "
    "\002(\004\022\020\n\010keyBytes\030\003 \001(\014\"\254\001\n\026ExportedBlockK"
    "eysProto\022\033\n\023isBlockTokenEnabled\030\001 \002(\010\022\031\n"
    "\021keyUpdateInterval\030\002 \002(\004\022\025\n\rtokenLifeTim"
    "e\030\003 \002(\004\022\"\n\ncurrentKey\030\004 \002(\0132\016.BlockKeyPr"
    "oto\022\037\n\007allKeys\030\005 \003(\0132\016.BlockKeyProto\"\271\001\n"
    "\031DatanodeRegistrationProto\022$\n\ndatanodeID"
    "\030\001 \002(\0132\020.DatanodeIDProto\022&\n\013storageInfo\030"
    "\002 \001(\0132\021.StorageInfoProto\022%\n\004keys\030\003 \001(\0132\027"
    ".ExportedBlockKeysProto\022\027\n\017softwareVersi"
    "on\030\004 \001(\t\022\016\n\006master\030\005 \001(\010\"P\n\034RegisterData"
    "nodeRequestProto\0220\n\014registration\030\001 \002(\0132\032"
    ".DatanodeRegistrationProto\"Q\n\035RegisterDa"
    "tanodeResponseProto\0220\n\014registration\030\001 \002("
    "\0132\032.DatanodeRegistrationProto\"=\n\035Datanod"
    "eHeartbeatRequestProto\022\034\n\002id\030\001 \002(\0132\020.Dat"
    "anodeIDProto\" \n\036DatanodeHeartbeatRespons"
    "eProto\"\?\n\032DataTransferTraceInfoProto\022\017\n\007"
    "traceId\030\001 \002(\004\022\020\n\010parentId\030\002 \002(\004\"\201\001\n\017Base"
    "HeaderProto\022\"\n\005block\030\001 \002(\0132\023.ExtendedBlo"
    "ckProto\022\032\n\005token\030\002 \001(\0132\013.TokenProto\022.\n\tt"
    "raceInfo\030\003 \001(\0132\033.DataTransferTraceInfoPr"
    "oto\"V\n\032ClientOperationHeaderProto\022$\n\nbas"
    "eHeader\030\001 \002(\0132\020.BaseHeaderProto\022\022\n\nclien"
    "tName\030\002 \002(\t\"\227\001\n\024OpTransferBlockProto\022+\n\006"
    "header\030\001 \002(\0132\033.ClientOperationHeaderProt"
    "o\022#\n\007targets\030\002 \003(\0132\022.DatanodeInfoProto\022-"
    "\n\022targetStorageTypes\030\003 \003(\0162\021.StorageType"
    "Proto\"z\n\034OpBlockChecksumResponseProto\022\023\n"
    "\013bytesPerCrc\030\001 \002(\r\022\023\n\013crcPerBlock\030\002 \002(\004\022"
    "\013\n\003md5\030\003 \002(\014\022#\n\007crcType\030\004 \001(\0162\022.Checksum"
    "TypeProto\"K\n\rChecksumProto\022 \n\004type\030\001 \002(\016"
    "2\022.ChecksumTypeProto\022\030\n\020bytesPerChecksum"
    "\030\002 \002(\r\"P\n\027ReadOpChecksumInfoProto\022 \n\010che"
    "cksum\030\001 \002(\0132\016.ChecksumProto\022\023\n\013chunkOffs"
    "et\030\002 \002(\004\"\350\001\n\024BlockOpResponseProto\022\027\n\006sta"
    "tus\030\001 \002(\0162\007.Status\022\024\n\014firstBadLink\030\002 \001(\t"
    "\0227\n\020checksumResponse\030\003 \001(\0132\035.OpBlockChec"
    "ksumResponseProto\0224\n\022readOpChecksumInfo\030"
    "\004 \001(\0132\030.ReadOpChecksumInfoProto\022\017\n\007messa"
    "ge\030\005 \001(\t\022!\n\031shortCircuitAccessVersion\030\006 "
    "\001(\r*J\n\014RpcKindProto\022\017\n\013RPC_BUILTIN\020\000\022\020\n\014"
    "RPC_WRITABLE\020\001\022\027\n\023RPC_PROTOCOL_BUFFER\020\002*"
    "@\n\020StorageTypeProto\022\010\n\004DISK\020\001\022\007\n\003SSD\020\002\022\013"
    "\n\007ARCHIVE\020\003\022\014\n\010RAM_DISK\020\004*6\n\020CipherSuite"
    "Proto\022\013\n\007UNKNOWN\020\001\022\025\n\021AES_CTR_NOPADDING\020"
    "\002*P\n\032CryptoProtocolVersionProto\022\034\n\030UNKNO"
    "WN_PROTOCOL_VERSION\020\001\022\024\n\020ENCRYPTION_ZONE"
    "S\020\002*O\n\021ChecksumTypeProto\022\021\n\rCHECKSUM_NUL"
    "L\020\000\022\022\n\016CHECKSUM_CRC32\020\001\022\023\n\017CHECKSUM_CRC3"
    "2C\020\002*\364\001\n\006Status\022\013\n\007SUCCESS\020\000\022\t\n\005ERROR\020\001\022"
    "\022\n\016ERROR_CHECKSUM\020\002\022\021\n\rERROR_INVALID\020\003\022\020"
    "\n\014ERROR_EXISTS\020\004\022\026\n\022ERROR_ACCESS_TOKEN\020\005"
    "\022\017\n\013CHECKSUM_OK\020\006\022\025\n\021ERROR_UNSUPPORTED\020\007"
    "\022\017\n\013OOB_RESTART\020\010\022\021\n\rOOB_RESERVED1\020\t\022\021\n\r"
    "OOB_RESERVED2\020\n\022\021\n\rOOB_RESERVED3\020\013\022\017\n\013IN"
    "_PROGRESS\020\014", 5131);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "common.proto", &protobuf_RegisterTypes);
  RPCTraceInfoProto::default_instance_ = new RPCTraceInfoProto();
  RPCCallerContextProto::default_instance_ = new RPCCallerContextProto();
  RpcRequestHeaderProto::default_instance_ = new RpcRequestHeaderProto();
  RpcResponseHeaderProto::default_instance_ = new RpcResponseHeaderProto();
  FsPermissionProto::default_instance_ = new FsPermissionProto();
  ExtendedBlockProto::default_instance_ = new ExtendedBlockProto();
  DatanodeIDProto::default_instance_ = new DatanodeIDProto();
  DatanodeInfoProto::default_instance_ = new DatanodeInfoProto();
  TokenProto::default_instance_ = new TokenProto();
  FileEncryptionInfoProto::default_instance_ = new FileEncryptionInfoProto();
  LocatedBlockProto::default_instance_ = new LocatedBlockProto();
  LocatedBlocksProto::default_instance_ = new LocatedBlocksProto();
  RequestHeaderProto::default_instance_ = new RequestHeaderProto();
  StorageInfoProto::default_instance_ = new StorageInfoProto();
  BlockKeyProto::default_instance_ = new BlockKeyProto();
  ExportedBlockKeysProto::default_instance_ = new ExportedBlockKeysProto();
  DatanodeRegistrationProto::default_instance_ = new DatanodeRegistrationProto();
  RegisterDatanodeRequestProto::default_instance_ = new RegisterDatanodeRequestProto();
  RegisterDatanodeResponseProto::default_instance_ = new RegisterDatanodeResponseProto();
  DatanodeHeartbeatRequestProto::default_instance_ = new DatanodeHeartbeatRequestProto();
  DatanodeHeartbeatResponseProto::default_instance_ = new DatanodeHeartbeatResponseProto();
  DataTransferTraceInfoProto::default_instance_ = new DataTransferTraceInfoProto();
  BaseHeaderProto::default_instance_ = new BaseHeaderProto();
  ClientOperationHeaderProto::default_instance_ = new ClientOperationHeaderProto();
  OpTransferBlockProto::default_instance_ = new OpTransferBlockProto();
  OpBlockChecksumResponseProto::default_instance_ = new OpBlockChecksumResponseProto();
  ChecksumProto::default_instance_ = new ChecksumProto();
  ReadOpChecksumInfoProto::default_instance_ = new ReadOpChecksumInfoProto();
  BlockOpResponseProto::default_instance_ = new BlockOpResponseProto();
  RPCTraceInfoProto::default_instance_->InitAsDefaultInstance();
  RPCCallerContextProto::default_instance_->InitAsDefaultInstance();
  RpcRequestHeaderProto::default_instance_->InitAsDefaultInstance();
  RpcResponseHeaderProto::default_instance_->InitAsDefaultInstance();
  FsPermissionProto::default_instance_->InitAsDefaultInstance();
  ExtendedBlockProto::default_instance_->InitAsDefaultInstance();
  DatanodeIDProto::default_instance_->InitAsDefaultInstance();
  DatanodeInfoProto::default_instance_->InitAsDefaultInstance();
  TokenProto::default_instance_->InitAsDefaultInstance();
  FileEncryptionInfoProto::default_instance_->InitAsDefaultInstance();
  LocatedBlockProto::default_instance_->InitAsDefaultInstance();
  LocatedBlocksProto::default_instance_->InitAsDefaultInstance();
  RequestHeaderProto::default_instance_->InitAsDefaultInstance();
  StorageInfoProto::default_instance_->InitAsDefaultInstance();
  BlockKeyProto::default_instance_->InitAsDefaultInstance();
  ExportedBlockKeysProto::default_instance_->InitAsDefaultInstance();
  DatanodeRegistrationProto::default_instance_->InitAsDefaultInstance();
  RegisterDatanodeRequestProto::default_instance_->InitAsDefaultInstance();
  RegisterDatanodeResponseProto::default_instance_->InitAsDefaultInstance();
  DatanodeHeartbeatRequestProto::default_instance_->InitAsDefaultInstance();
  DatanodeHeartbeatResponseProto::default_instance_->InitAsDefaultInstance();
  DataTransferTraceInfoProto::default_instance_->InitAsDefaultInstance();
  BaseHeaderProto::default_instance_->InitAsDefaultInstance();
  ClientOperationHeaderProto::default_instance_->InitAsDefaultInstance();
  OpTransferBlockProto::default_instance_->InitAsDefaultInstance();
  OpBlockChecksumResponseProto::default_instance_->InitAsDefaultInstance();
  ChecksumProto::default_instance_->InitAsDefaultInstance();
  ReadOpChecksumInfoProto::default_instance_->InitAsDefaultInstance();
  BlockOpResponseProto::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_common_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_common_2eproto {
  StaticDescriptorInitializer_common_2eproto() {
    protobuf_AddDesc_common_2eproto();
  }
} static_descriptor_initializer_common_2eproto_;
const ::google::protobuf::EnumDescriptor* RpcKindProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RpcKindProto_descriptor_;
}
bool RpcKindProto_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StorageTypeProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StorageTypeProto_descriptor_;
}
bool StorageTypeProto_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CipherSuiteProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CipherSuiteProto_descriptor_;
}
bool CipherSuiteProto_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CryptoProtocolVersionProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CryptoProtocolVersionProto_descriptor_;
}
bool CryptoProtocolVersionProto_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ChecksumTypeProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChecksumTypeProto_descriptor_;
}
bool ChecksumTypeProto_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Status_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Status_descriptor_;
}
bool Status_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RPCTraceInfoProto::kTraceIdFieldNumber;
const int RPCTraceInfoProto::kParentIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RPCTraceInfoProto::RPCTraceInfoProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RPCTraceInfoProto)
}

void RPCTraceInfoProto::InitAsDefaultInstance() {
}

RPCTraceInfoProto::RPCTraceInfoProto(const RPCTraceInfoProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RPCTraceInfoProto)
}

void RPCTraceInfoProto::SharedCtor() {
  _cached_size_ = 0;
  traceid_ = GOOGLE_LONGLONG(0);
  parentid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RPCTraceInfoProto::~RPCTraceInfoProto() {
  // @@protoc_insertion_point(destructor:RPCTraceInfoProto)
  SharedDtor();
}

void RPCTraceInfoProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RPCTraceInfoProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RPCTraceInfoProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RPCTraceInfoProto_descriptor_;
}

const RPCTraceInfoProto& RPCTraceInfoProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

RPCTraceInfoProto* RPCTraceInfoProto::default_instance_ = NULL;

RPCTraceInfoProto* RPCTraceInfoProto::New(::google::protobuf::Arena* arena) const {
  RPCTraceInfoProto* n = new RPCTraceInfoProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RPCTraceInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:RPCTraceInfoProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RPCTraceInfoProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RPCTraceInfoProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(traceid_, parentid_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RPCTraceInfoProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RPCTraceInfoProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 traceId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &traceid_)));
          set_has_traceid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_parentId;
        break;
      }

      // optional int64 parentId = 2;
      case 2: {
        if (tag == 16) {
         parse_parentId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &parentid_)));
          set_has_parentid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RPCTraceInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RPCTraceInfoProto)
  return false;
#undef DO_
}

void RPCTraceInfoProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RPCTraceInfoProto)
  // optional int64 traceId = 1;
  if (has_traceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->traceid(), output);
  }

  // optional int64 parentId = 2;
  if (has_parentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->parentid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RPCTraceInfoProto)
}

::google::protobuf::uint8* RPCTraceInfoProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RPCTraceInfoProto)
  // optional int64 traceId = 1;
  if (has_traceid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->traceid(), target);
  }

  // optional int64 parentId = 2;
  if (has_parentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->parentid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RPCTraceInfoProto)
  return target;
}

int RPCTraceInfoProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RPCTraceInfoProto)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional int64 traceId = 1;
    if (has_traceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->traceid());
    }

    // optional int64 parentId = 2;
    if (has_parentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->parentid());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RPCTraceInfoProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RPCTraceInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RPCTraceInfoProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RPCTraceInfoProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RPCTraceInfoProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RPCTraceInfoProto)
    MergeFrom(*source);
  }
}

void RPCTraceInfoProto::MergeFrom(const RPCTraceInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RPCTraceInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_traceid()) {
      set_traceid(from.traceid());
    }
    if (from.has_parentid()) {
      set_parentid(from.parentid());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RPCTraceInfoProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RPCTraceInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RPCTraceInfoProto::CopyFrom(const RPCTraceInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RPCTraceInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RPCTraceInfoProto::IsInitialized() const {

  return true;
}

void RPCTraceInfoProto::Swap(RPCTraceInfoProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RPCTraceInfoProto::InternalSwap(RPCTraceInfoProto* other) {
  std::swap(traceid_, other->traceid_);
  std::swap(parentid_, other->parentid_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RPCTraceInfoProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RPCTraceInfoProto_descriptor_;
  metadata.reflection = RPCTraceInfoProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RPCTraceInfoProto

// optional int64 traceId = 1;
bool RPCTraceInfoProto::has_traceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RPCTraceInfoProto::set_has_traceid() {
  _has_bits_[0] |= 0x00000001u;
}
void RPCTraceInfoProto::clear_has_traceid() {
  _has_bits_[0] &= ~0x00000001u;
}
void RPCTraceInfoProto::clear_traceid() {
  traceid_ = GOOGLE_LONGLONG(0);
  clear_has_traceid();
}
 ::google::protobuf::int64 RPCTraceInfoProto::traceid() const {
  // @@protoc_insertion_point(field_get:RPCTraceInfoProto.traceId)
  return traceid_;
}
 void RPCTraceInfoProto::set_traceid(::google::protobuf::int64 value) {
  set_has_traceid();
  traceid_ = value;
  // @@protoc_insertion_point(field_set:RPCTraceInfoProto.traceId)
}

// optional int64 parentId = 2;
bool RPCTraceInfoProto::has_parentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RPCTraceInfoProto::set_has_parentid() {
  _has_bits_[0] |= 0x00000002u;
}
void RPCTraceInfoProto::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000002u;
}
void RPCTraceInfoProto::clear_parentid() {
  parentid_ = GOOGLE_LONGLONG(0);
  clear_has_parentid();
}
 ::google::protobuf::int64 RPCTraceInfoProto::parentid() const {
  // @@protoc_insertion_point(field_get:RPCTraceInfoProto.parentId)
  return parentid_;
}
 void RPCTraceInfoProto::set_parentid(::google::protobuf::int64 value) {
  set_has_parentid();
  parentid_ = value;
  // @@protoc_insertion_point(field_set:RPCTraceInfoProto.parentId)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RPCCallerContextProto::kContextFieldNumber;
const int RPCCallerContextProto::kSignatureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RPCCallerContextProto::RPCCallerContextProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RPCCallerContextProto)
}

void RPCCallerContextProto::InitAsDefaultInstance() {
}

RPCCallerContextProto::RPCCallerContextProto(const RPCCallerContextProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RPCCallerContextProto)
}

void RPCCallerContextProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  context_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RPCCallerContextProto::~RPCCallerContextProto() {
  // @@protoc_insertion_point(destructor:RPCCallerContextProto)
  SharedDtor();
}

void RPCCallerContextProto::SharedDtor() {
  context_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RPCCallerContextProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RPCCallerContextProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RPCCallerContextProto_descriptor_;
}

const RPCCallerContextProto& RPCCallerContextProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

RPCCallerContextProto* RPCCallerContextProto::default_instance_ = NULL;

RPCCallerContextProto* RPCCallerContextProto::New(::google::protobuf::Arena* arena) const {
  RPCCallerContextProto* n = new RPCCallerContextProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RPCCallerContextProto::Clear() {
// @@protoc_insertion_point(message_clear_start:RPCCallerContextProto)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_context()) {
      context_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_signature()) {
      signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RPCCallerContextProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RPCCallerContextProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string context = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_context()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->context().data(), this->context().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "RPCCallerContextProto.context");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_signature;
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (tag == 18) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RPCCallerContextProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RPCCallerContextProto)
  return false;
#undef DO_
}

void RPCCallerContextProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RPCCallerContextProto)
  // required string context = 1;
  if (has_context()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->context().data(), this->context().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RPCCallerContextProto.context");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->context(), output);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RPCCallerContextProto)
}

::google::protobuf::uint8* RPCCallerContextProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RPCCallerContextProto)
  // required string context = 1;
  if (has_context()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->context().data(), this->context().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RPCCallerContextProto.context");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->context(), target);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RPCCallerContextProto)
  return target;
}

int RPCCallerContextProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RPCCallerContextProto)
  int total_size = 0;

  // required string context = 1;
  if (has_context()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->context());
  }
  // optional bytes signature = 2;
  if (has_signature()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->signature());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RPCCallerContextProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RPCCallerContextProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RPCCallerContextProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RPCCallerContextProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RPCCallerContextProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RPCCallerContextProto)
    MergeFrom(*source);
  }
}

void RPCCallerContextProto::MergeFrom(const RPCCallerContextProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RPCCallerContextProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_context()) {
      set_has_context();
      context_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.context_);
    }
    if (from.has_signature()) {
      set_has_signature();
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RPCCallerContextProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RPCCallerContextProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RPCCallerContextProto::CopyFrom(const RPCCallerContextProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RPCCallerContextProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RPCCallerContextProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RPCCallerContextProto::Swap(RPCCallerContextProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RPCCallerContextProto::InternalSwap(RPCCallerContextProto* other) {
  context_.Swap(&other->context_);
  signature_.Swap(&other->signature_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RPCCallerContextProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RPCCallerContextProto_descriptor_;
  metadata.reflection = RPCCallerContextProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RPCCallerContextProto

// required string context = 1;
bool RPCCallerContextProto::has_context() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RPCCallerContextProto::set_has_context() {
  _has_bits_[0] |= 0x00000001u;
}
void RPCCallerContextProto::clear_has_context() {
  _has_bits_[0] &= ~0x00000001u;
}
void RPCCallerContextProto::clear_context() {
  context_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_context();
}
 const ::std::string& RPCCallerContextProto::context() const {
  // @@protoc_insertion_point(field_get:RPCCallerContextProto.context)
  return context_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RPCCallerContextProto::set_context(const ::std::string& value) {
  set_has_context();
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RPCCallerContextProto.context)
}
 void RPCCallerContextProto::set_context(const char* value) {
  set_has_context();
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RPCCallerContextProto.context)
}
 void RPCCallerContextProto::set_context(const char* value, size_t size) {
  set_has_context();
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RPCCallerContextProto.context)
}
 ::std::string* RPCCallerContextProto::mutable_context() {
  set_has_context();
  // @@protoc_insertion_point(field_mutable:RPCCallerContextProto.context)
  return context_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RPCCallerContextProto::release_context() {
  // @@protoc_insertion_point(field_release:RPCCallerContextProto.context)
  clear_has_context();
  return context_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RPCCallerContextProto::set_allocated_context(::std::string* context) {
  if (context != NULL) {
    set_has_context();
  } else {
    clear_has_context();
  }
  context_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), context);
  // @@protoc_insertion_point(field_set_allocated:RPCCallerContextProto.context)
}

// optional bytes signature = 2;
bool RPCCallerContextProto::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RPCCallerContextProto::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
void RPCCallerContextProto::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
void RPCCallerContextProto::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
 const ::std::string& RPCCallerContextProto::signature() const {
  // @@protoc_insertion_point(field_get:RPCCallerContextProto.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RPCCallerContextProto::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RPCCallerContextProto.signature)
}
 void RPCCallerContextProto::set_signature(const char* value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RPCCallerContextProto.signature)
}
 void RPCCallerContextProto::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RPCCallerContextProto.signature)
}
 ::std::string* RPCCallerContextProto::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:RPCCallerContextProto.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RPCCallerContextProto::release_signature() {
  // @@protoc_insertion_point(field_release:RPCCallerContextProto.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RPCCallerContextProto::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:RPCCallerContextProto.signature)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* RpcRequestHeaderProto_OperationProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RpcRequestHeaderProto_OperationProto_descriptor_;
}
bool RpcRequestHeaderProto_OperationProto_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto::RPC_FINAL_PACKET;
const RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto::RPC_CONTINUATION_PACKET;
const RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto::RPC_CLOSE_CONNECTION;
const RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto::OperationProto_MIN;
const RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto::OperationProto_MAX;
const int RpcRequestHeaderProto::OperationProto_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RpcRequestHeaderProto::kRpcKindFieldNumber;
const int RpcRequestHeaderProto::kRpcOpFieldNumber;
const int RpcRequestHeaderProto::kCallIdFieldNumber;
const int RpcRequestHeaderProto::kClientIdFieldNumber;
const int RpcRequestHeaderProto::kRetryCountFieldNumber;
const int RpcRequestHeaderProto::kTraceInfoFieldNumber;
const int RpcRequestHeaderProto::kCallerContextFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RpcRequestHeaderProto::RpcRequestHeaderProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RpcRequestHeaderProto)
}

void RpcRequestHeaderProto::InitAsDefaultInstance() {
  traceinfo_ = const_cast< ::RPCTraceInfoProto*>(&::RPCTraceInfoProto::default_instance());
  callercontext_ = const_cast< ::RPCCallerContextProto*>(&::RPCCallerContextProto::default_instance());
}

RpcRequestHeaderProto::RpcRequestHeaderProto(const RpcRequestHeaderProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RpcRequestHeaderProto)
}

void RpcRequestHeaderProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  rpckind_ = 0;
  rpcop_ = 0;
  callid_ = 0;
  clientid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  retrycount_ = -1;
  traceinfo_ = NULL;
  callercontext_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RpcRequestHeaderProto::~RpcRequestHeaderProto() {
  // @@protoc_insertion_point(destructor:RpcRequestHeaderProto)
  SharedDtor();
}

void RpcRequestHeaderProto::SharedDtor() {
  clientid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete traceinfo_;
    delete callercontext_;
  }
}

void RpcRequestHeaderProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RpcRequestHeaderProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RpcRequestHeaderProto_descriptor_;
}

const RpcRequestHeaderProto& RpcRequestHeaderProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

RpcRequestHeaderProto* RpcRequestHeaderProto::default_instance_ = NULL;

RpcRequestHeaderProto* RpcRequestHeaderProto::New(::google::protobuf::Arena* arena) const {
  RpcRequestHeaderProto* n = new RpcRequestHeaderProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RpcRequestHeaderProto::Clear() {
// @@protoc_insertion_point(message_clear_start:RpcRequestHeaderProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RpcRequestHeaderProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RpcRequestHeaderProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(rpckind_, rpcop_);
    callid_ = 0;
    if (has_clientid()) {
      clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    retrycount_ = -1;
    if (has_traceinfo()) {
      if (traceinfo_ != NULL) traceinfo_->::RPCTraceInfoProto::Clear();
    }
    if (has_callercontext()) {
      if (callercontext_ != NULL) callercontext_->::RPCCallerContextProto::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RpcRequestHeaderProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RpcRequestHeaderProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .RpcKindProto rpcKind = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::RpcKindProto_IsValid(value)) {
            set_rpckind(static_cast< ::RpcKindProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_rpcOp;
        break;
      }

      // optional .RpcRequestHeaderProto.OperationProto rpcOp = 2;
      case 2: {
        if (tag == 16) {
         parse_rpcOp:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::RpcRequestHeaderProto_OperationProto_IsValid(value)) {
            set_rpcop(static_cast< ::RpcRequestHeaderProto_OperationProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_callId;
        break;
      }

      // required sint32 callId = 3;
      case 3: {
        if (tag == 24) {
         parse_callId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_clientId;
        break;
      }

      // required bytes clientId = 4;
      case 4: {
        if (tag == 34) {
         parse_clientId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_clientid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_retryCount;
        break;
      }

      // optional sint32 retryCount = 5 [default = -1];
      case 5: {
        if (tag == 40) {
         parse_retryCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &retrycount_)));
          set_has_retrycount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_traceInfo;
        break;
      }

      // optional .RPCTraceInfoProto traceInfo = 6;
      case 6: {
        if (tag == 50) {
         parse_traceInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_traceinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_callerContext;
        break;
      }

      // optional .RPCCallerContextProto callerContext = 7;
      case 7: {
        if (tag == 58) {
         parse_callerContext:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_callercontext()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RpcRequestHeaderProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RpcRequestHeaderProto)
  return false;
#undef DO_
}

void RpcRequestHeaderProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RpcRequestHeaderProto)
  // optional .RpcKindProto rpcKind = 1;
  if (has_rpckind()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->rpckind(), output);
  }

  // optional .RpcRequestHeaderProto.OperationProto rpcOp = 2;
  if (has_rpcop()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->rpcop(), output);
  }

  // required sint32 callId = 3;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->callid(), output);
  }

  // required bytes clientId = 4;
  if (has_clientid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->clientid(), output);
  }

  // optional sint32 retryCount = 5 [default = -1];
  if (has_retrycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->retrycount(), output);
  }

  // optional .RPCTraceInfoProto traceInfo = 6;
  if (has_traceinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->traceinfo_, output);
  }

  // optional .RPCCallerContextProto callerContext = 7;
  if (has_callercontext()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->callercontext_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RpcRequestHeaderProto)
}

::google::protobuf::uint8* RpcRequestHeaderProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RpcRequestHeaderProto)
  // optional .RpcKindProto rpcKind = 1;
  if (has_rpckind()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->rpckind(), target);
  }

  // optional .RpcRequestHeaderProto.OperationProto rpcOp = 2;
  if (has_rpcop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->rpcop(), target);
  }

  // required sint32 callId = 3;
  if (has_callid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(3, this->callid(), target);
  }

  // required bytes clientId = 4;
  if (has_clientid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->clientid(), target);
  }

  // optional sint32 retryCount = 5 [default = -1];
  if (has_retrycount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->retrycount(), target);
  }

  // optional .RPCTraceInfoProto traceInfo = 6;
  if (has_traceinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->traceinfo_, false, target);
  }

  // optional .RPCCallerContextProto callerContext = 7;
  if (has_callercontext()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->callercontext_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RpcRequestHeaderProto)
  return target;
}

int RpcRequestHeaderProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RpcRequestHeaderProto)
  int total_size = 0;

  if (has_callid()) {
    // required sint32 callId = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->callid());
  }

  if (has_clientid()) {
    // required bytes clientId = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->clientid());
  }

  return total_size;
}
int RpcRequestHeaderProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RpcRequestHeaderProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000c) ^ 0x0000000c) == 0) {  // All required fields are present.
    // required sint32 callId = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::SInt32Size(
        this->callid());

    // required bytes clientId = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->clientid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 115u) {
    // optional .RpcKindProto rpcKind = 1;
    if (has_rpckind()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rpckind());
    }

    // optional .RpcRequestHeaderProto.OperationProto rpcOp = 2;
    if (has_rpcop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rpcop());
    }

    // optional sint32 retryCount = 5 [default = -1];
    if (has_retrycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->retrycount());
    }

    // optional .RPCTraceInfoProto traceInfo = 6;
    if (has_traceinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->traceinfo_);
    }

    // optional .RPCCallerContextProto callerContext = 7;
    if (has_callercontext()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->callercontext_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RpcRequestHeaderProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RpcRequestHeaderProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RpcRequestHeaderProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RpcRequestHeaderProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RpcRequestHeaderProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RpcRequestHeaderProto)
    MergeFrom(*source);
  }
}

void RpcRequestHeaderProto::MergeFrom(const RpcRequestHeaderProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RpcRequestHeaderProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rpckind()) {
      set_rpckind(from.rpckind());
    }
    if (from.has_rpcop()) {
      set_rpcop(from.rpcop());
    }
    if (from.has_callid()) {
      set_callid(from.callid());
    }
    if (from.has_clientid()) {
      set_has_clientid();
      clientid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.clientid_);
    }
    if (from.has_retrycount()) {
      set_retrycount(from.retrycount());
    }
    if (from.has_traceinfo()) {
      mutable_traceinfo()->::RPCTraceInfoProto::MergeFrom(from.traceinfo());
    }
    if (from.has_callercontext()) {
      mutable_callercontext()->::RPCCallerContextProto::MergeFrom(from.callercontext());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RpcRequestHeaderProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RpcRequestHeaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RpcRequestHeaderProto::CopyFrom(const RpcRequestHeaderProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RpcRequestHeaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RpcRequestHeaderProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000c) != 0x0000000c) return false;

  if (has_callercontext()) {
    if (!this->callercontext_->IsInitialized()) return false;
  }
  return true;
}

void RpcRequestHeaderProto::Swap(RpcRequestHeaderProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RpcRequestHeaderProto::InternalSwap(RpcRequestHeaderProto* other) {
  std::swap(rpckind_, other->rpckind_);
  std::swap(rpcop_, other->rpcop_);
  std::swap(callid_, other->callid_);
  clientid_.Swap(&other->clientid_);
  std::swap(retrycount_, other->retrycount_);
  std::swap(traceinfo_, other->traceinfo_);
  std::swap(callercontext_, other->callercontext_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RpcRequestHeaderProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RpcRequestHeaderProto_descriptor_;
  metadata.reflection = RpcRequestHeaderProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RpcRequestHeaderProto

// optional .RpcKindProto rpcKind = 1;
bool RpcRequestHeaderProto::has_rpckind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RpcRequestHeaderProto::set_has_rpckind() {
  _has_bits_[0] |= 0x00000001u;
}
void RpcRequestHeaderProto::clear_has_rpckind() {
  _has_bits_[0] &= ~0x00000001u;
}
void RpcRequestHeaderProto::clear_rpckind() {
  rpckind_ = 0;
  clear_has_rpckind();
}
 ::RpcKindProto RpcRequestHeaderProto::rpckind() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.rpcKind)
  return static_cast< ::RpcKindProto >(rpckind_);
}
 void RpcRequestHeaderProto::set_rpckind(::RpcKindProto value) {
  assert(::RpcKindProto_IsValid(value));
  set_has_rpckind();
  rpckind_ = value;
  // @@protoc_insertion_point(field_set:RpcRequestHeaderProto.rpcKind)
}

// optional .RpcRequestHeaderProto.OperationProto rpcOp = 2;
bool RpcRequestHeaderProto::has_rpcop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RpcRequestHeaderProto::set_has_rpcop() {
  _has_bits_[0] |= 0x00000002u;
}
void RpcRequestHeaderProto::clear_has_rpcop() {
  _has_bits_[0] &= ~0x00000002u;
}
void RpcRequestHeaderProto::clear_rpcop() {
  rpcop_ = 0;
  clear_has_rpcop();
}
 ::RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto::rpcop() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.rpcOp)
  return static_cast< ::RpcRequestHeaderProto_OperationProto >(rpcop_);
}
 void RpcRequestHeaderProto::set_rpcop(::RpcRequestHeaderProto_OperationProto value) {
  assert(::RpcRequestHeaderProto_OperationProto_IsValid(value));
  set_has_rpcop();
  rpcop_ = value;
  // @@protoc_insertion_point(field_set:RpcRequestHeaderProto.rpcOp)
}

// required sint32 callId = 3;
bool RpcRequestHeaderProto::has_callid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RpcRequestHeaderProto::set_has_callid() {
  _has_bits_[0] |= 0x00000004u;
}
void RpcRequestHeaderProto::clear_has_callid() {
  _has_bits_[0] &= ~0x00000004u;
}
void RpcRequestHeaderProto::clear_callid() {
  callid_ = 0;
  clear_has_callid();
}
 ::google::protobuf::int32 RpcRequestHeaderProto::callid() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.callId)
  return callid_;
}
 void RpcRequestHeaderProto::set_callid(::google::protobuf::int32 value) {
  set_has_callid();
  callid_ = value;
  // @@protoc_insertion_point(field_set:RpcRequestHeaderProto.callId)
}

// required bytes clientId = 4;
bool RpcRequestHeaderProto::has_clientid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RpcRequestHeaderProto::set_has_clientid() {
  _has_bits_[0] |= 0x00000008u;
}
void RpcRequestHeaderProto::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000008u;
}
void RpcRequestHeaderProto::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
 const ::std::string& RpcRequestHeaderProto::clientid() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.clientId)
  return clientid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RpcRequestHeaderProto::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RpcRequestHeaderProto.clientId)
}
 void RpcRequestHeaderProto::set_clientid(const char* value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RpcRequestHeaderProto.clientId)
}
 void RpcRequestHeaderProto::set_clientid(const void* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RpcRequestHeaderProto.clientId)
}
 ::std::string* RpcRequestHeaderProto::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:RpcRequestHeaderProto.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RpcRequestHeaderProto::release_clientid() {
  // @@protoc_insertion_point(field_release:RpcRequestHeaderProto.clientId)
  clear_has_clientid();
  return clientid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RpcRequestHeaderProto::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:RpcRequestHeaderProto.clientId)
}

// optional sint32 retryCount = 5 [default = -1];
bool RpcRequestHeaderProto::has_retrycount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RpcRequestHeaderProto::set_has_retrycount() {
  _has_bits_[0] |= 0x00000010u;
}
void RpcRequestHeaderProto::clear_has_retrycount() {
  _has_bits_[0] &= ~0x00000010u;
}
void RpcRequestHeaderProto::clear_retrycount() {
  retrycount_ = -1;
  clear_has_retrycount();
}
 ::google::protobuf::int32 RpcRequestHeaderProto::retrycount() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.retryCount)
  return retrycount_;
}
 void RpcRequestHeaderProto::set_retrycount(::google::protobuf::int32 value) {
  set_has_retrycount();
  retrycount_ = value;
  // @@protoc_insertion_point(field_set:RpcRequestHeaderProto.retryCount)
}

// optional .RPCTraceInfoProto traceInfo = 6;
bool RpcRequestHeaderProto::has_traceinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RpcRequestHeaderProto::set_has_traceinfo() {
  _has_bits_[0] |= 0x00000020u;
}
void RpcRequestHeaderProto::clear_has_traceinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
void RpcRequestHeaderProto::clear_traceinfo() {
  if (traceinfo_ != NULL) traceinfo_->::RPCTraceInfoProto::Clear();
  clear_has_traceinfo();
}
const ::RPCTraceInfoProto& RpcRequestHeaderProto::traceinfo() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.traceInfo)
  return traceinfo_ != NULL ? *traceinfo_ : *default_instance_->traceinfo_;
}
::RPCTraceInfoProto* RpcRequestHeaderProto::mutable_traceinfo() {
  set_has_traceinfo();
  if (traceinfo_ == NULL) {
    traceinfo_ = new ::RPCTraceInfoProto;
  }
  // @@protoc_insertion_point(field_mutable:RpcRequestHeaderProto.traceInfo)
  return traceinfo_;
}
::RPCTraceInfoProto* RpcRequestHeaderProto::release_traceinfo() {
  // @@protoc_insertion_point(field_release:RpcRequestHeaderProto.traceInfo)
  clear_has_traceinfo();
  ::RPCTraceInfoProto* temp = traceinfo_;
  traceinfo_ = NULL;
  return temp;
}
void RpcRequestHeaderProto::set_allocated_traceinfo(::RPCTraceInfoProto* traceinfo) {
  delete traceinfo_;
  traceinfo_ = traceinfo;
  if (traceinfo) {
    set_has_traceinfo();
  } else {
    clear_has_traceinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:RpcRequestHeaderProto.traceInfo)
}

// optional .RPCCallerContextProto callerContext = 7;
bool RpcRequestHeaderProto::has_callercontext() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void RpcRequestHeaderProto::set_has_callercontext() {
  _has_bits_[0] |= 0x00000040u;
}
void RpcRequestHeaderProto::clear_has_callercontext() {
  _has_bits_[0] &= ~0x00000040u;
}
void RpcRequestHeaderProto::clear_callercontext() {
  if (callercontext_ != NULL) callercontext_->::RPCCallerContextProto::Clear();
  clear_has_callercontext();
}
const ::RPCCallerContextProto& RpcRequestHeaderProto::callercontext() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.callerContext)
  return callercontext_ != NULL ? *callercontext_ : *default_instance_->callercontext_;
}
::RPCCallerContextProto* RpcRequestHeaderProto::mutable_callercontext() {
  set_has_callercontext();
  if (callercontext_ == NULL) {
    callercontext_ = new ::RPCCallerContextProto;
  }
  // @@protoc_insertion_point(field_mutable:RpcRequestHeaderProto.callerContext)
  return callercontext_;
}
::RPCCallerContextProto* RpcRequestHeaderProto::release_callercontext() {
  // @@protoc_insertion_point(field_release:RpcRequestHeaderProto.callerContext)
  clear_has_callercontext();
  ::RPCCallerContextProto* temp = callercontext_;
  callercontext_ = NULL;
  return temp;
}
void RpcRequestHeaderProto::set_allocated_callercontext(::RPCCallerContextProto* callercontext) {
  delete callercontext_;
  callercontext_ = callercontext;
  if (callercontext) {
    set_has_callercontext();
  } else {
    clear_has_callercontext();
  }
  // @@protoc_insertion_point(field_set_allocated:RpcRequestHeaderProto.callerContext)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* RpcResponseHeaderProto_RpcStatusProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RpcResponseHeaderProto_RpcStatusProto_descriptor_;
}
bool RpcResponseHeaderProto_RpcStatusProto_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto::SUCCESS;
const RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto::ERROR;
const RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto::FATAL;
const RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto::RpcStatusProto_MIN;
const RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto::RpcStatusProto_MAX;
const int RpcResponseHeaderProto::RpcStatusProto_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* RpcResponseHeaderProto_RpcErrorCodeProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RpcResponseHeaderProto_RpcErrorCodeProto_descriptor_;
}
bool RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::ERROR_APPLICATION;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::ERROR_NO_SUCH_METHOD;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::ERROR_NO_SUCH_PROTOCOL;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::ERROR_RPC_SERVER;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::ERROR_SERIALIZING_RESPONSE;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::ERROR_RPC_VERSION_MISMATCH;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::FATAL_UNKNOWN;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::FATAL_UNSUPPORTED_SERIALIZATION;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::FATAL_INVALID_RPC_HEADER;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::FATAL_DESERIALIZING_REQUEST;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::FATAL_VERSION_MISMATCH;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::FATAL_UNAUTHORIZED;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::RpcErrorCodeProto_MIN;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::RpcErrorCodeProto_MAX;
const int RpcResponseHeaderProto::RpcErrorCodeProto_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RpcResponseHeaderProto::kCallIdFieldNumber;
const int RpcResponseHeaderProto::kStatusFieldNumber;
const int RpcResponseHeaderProto::kServerIpcVersionNumFieldNumber;
const int RpcResponseHeaderProto::kExceptionClassNameFieldNumber;
const int RpcResponseHeaderProto::kErrorMsgFieldNumber;
const int RpcResponseHeaderProto::kErrorDetailFieldNumber;
const int RpcResponseHeaderProto::kClientIdFieldNumber;
const int RpcResponseHeaderProto::kRetryCountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RpcResponseHeaderProto::RpcResponseHeaderProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RpcResponseHeaderProto)
}

void RpcResponseHeaderProto::InitAsDefaultInstance() {
}

RpcResponseHeaderProto::RpcResponseHeaderProto(const RpcResponseHeaderProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RpcResponseHeaderProto)
}

void RpcResponseHeaderProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  callid_ = 0u;
  status_ = 0;
  serveripcversionnum_ = 0u;
  exceptionclassname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  errormsg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  errordetail_ = 1;
  clientid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  retrycount_ = -1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RpcResponseHeaderProto::~RpcResponseHeaderProto() {
  // @@protoc_insertion_point(destructor:RpcResponseHeaderProto)
  SharedDtor();
}

void RpcResponseHeaderProto::SharedDtor() {
  exceptionclassname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  errormsg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clientid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RpcResponseHeaderProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RpcResponseHeaderProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RpcResponseHeaderProto_descriptor_;
}

const RpcResponseHeaderProto& RpcResponseHeaderProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

RpcResponseHeaderProto* RpcResponseHeaderProto::default_instance_ = NULL;

RpcResponseHeaderProto* RpcResponseHeaderProto::New(::google::protobuf::Arena* arena) const {
  RpcResponseHeaderProto* n = new RpcResponseHeaderProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RpcResponseHeaderProto::Clear() {
// @@protoc_insertion_point(message_clear_start:RpcResponseHeaderProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RpcResponseHeaderProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RpcResponseHeaderProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(callid_, status_);
    serveripcversionnum_ = 0u;
    if (has_exceptionclassname()) {
      exceptionclassname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_errormsg()) {
      errormsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    errordetail_ = 1;
    if (has_clientid()) {
      clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    retrycount_ = -1;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RpcResponseHeaderProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RpcResponseHeaderProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 callId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &callid_)));
          set_has_callid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .RpcResponseHeaderProto.RpcStatusProto status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::RpcResponseHeaderProto_RpcStatusProto_IsValid(value)) {
            set_status(static_cast< ::RpcResponseHeaderProto_RpcStatusProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_serverIpcVersionNum;
        break;
      }

      // optional uint32 serverIpcVersionNum = 3;
      case 3: {
        if (tag == 24) {
         parse_serverIpcVersionNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serveripcversionnum_)));
          set_has_serveripcversionnum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_exceptionClassName;
        break;
      }

      // optional string exceptionClassName = 4;
      case 4: {
        if (tag == 34) {
         parse_exceptionClassName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_exceptionclassname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->exceptionclassname().data(), this->exceptionclassname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "RpcResponseHeaderProto.exceptionClassName");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_errorMsg;
        break;
      }

      // optional string errorMsg = 5;
      case 5: {
        if (tag == 42) {
         parse_errorMsg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_errormsg()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->errormsg().data(), this->errormsg().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "RpcResponseHeaderProto.errorMsg");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_errorDetail;
        break;
      }

      // optional .RpcResponseHeaderProto.RpcErrorCodeProto errorDetail = 6;
      case 6: {
        if (tag == 48) {
         parse_errorDetail:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(value)) {
            set_errordetail(static_cast< ::RpcResponseHeaderProto_RpcErrorCodeProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_clientId;
        break;
      }

      // optional bytes clientId = 7;
      case 7: {
        if (tag == 58) {
         parse_clientId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_clientid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_retryCount;
        break;
      }

      // optional sint32 retryCount = 8 [default = -1];
      case 8: {
        if (tag == 64) {
         parse_retryCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &retrycount_)));
          set_has_retrycount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RpcResponseHeaderProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RpcResponseHeaderProto)
  return false;
#undef DO_
}

void RpcResponseHeaderProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RpcResponseHeaderProto)
  // required uint32 callId = 1;
  if (has_callid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->callid(), output);
  }

  // required .RpcResponseHeaderProto.RpcStatusProto status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional uint32 serverIpcVersionNum = 3;
  if (has_serveripcversionnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->serveripcversionnum(), output);
  }

  // optional string exceptionClassName = 4;
  if (has_exceptionclassname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->exceptionclassname().data(), this->exceptionclassname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RpcResponseHeaderProto.exceptionClassName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->exceptionclassname(), output);
  }

  // optional string errorMsg = 5;
  if (has_errormsg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->errormsg().data(), this->errormsg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RpcResponseHeaderProto.errorMsg");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->errormsg(), output);
  }

  // optional .RpcResponseHeaderProto.RpcErrorCodeProto errorDetail = 6;
  if (has_errordetail()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->errordetail(), output);
  }

  // optional bytes clientId = 7;
  if (has_clientid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->clientid(), output);
  }

  // optional sint32 retryCount = 8 [default = -1];
  if (has_retrycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(8, this->retrycount(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RpcResponseHeaderProto)
}

::google::protobuf::uint8* RpcResponseHeaderProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RpcResponseHeaderProto)
  // required uint32 callId = 1;
  if (has_callid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->callid(), target);
  }

  // required .RpcResponseHeaderProto.RpcStatusProto status = 2;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->status(), target);
  }

  // optional uint32 serverIpcVersionNum = 3;
  if (has_serveripcversionnum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->serveripcversionnum(), target);
  }

  // optional string exceptionClassName = 4;
  if (has_exceptionclassname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->exceptionclassname().data(), this->exceptionclassname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RpcResponseHeaderProto.exceptionClassName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->exceptionclassname(), target);
  }

  // optional string errorMsg = 5;
  if (has_errormsg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->errormsg().data(), this->errormsg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RpcResponseHeaderProto.errorMsg");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->errormsg(), target);
  }

  // optional .RpcResponseHeaderProto.RpcErrorCodeProto errorDetail = 6;
  if (has_errordetail()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->errordetail(), target);
  }

  // optional bytes clientId = 7;
  if (has_clientid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->clientid(), target);
  }

  // optional sint32 retryCount = 8 [default = -1];
  if (has_retrycount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(8, this->retrycount(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RpcResponseHeaderProto)
  return target;
}

int RpcResponseHeaderProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RpcResponseHeaderProto)
  int total_size = 0;

  if (has_callid()) {
    // required uint32 callId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->callid());
  }

  if (has_status()) {
    // required .RpcResponseHeaderProto.RpcStatusProto status = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
  }

  return total_size;
}
int RpcResponseHeaderProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RpcResponseHeaderProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 callId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->callid());

    // required .RpcResponseHeaderProto.RpcStatusProto status = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[2 / 32] & 252u) {
    // optional uint32 serverIpcVersionNum = 3;
    if (has_serveripcversionnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serveripcversionnum());
    }

    // optional string exceptionClassName = 4;
    if (has_exceptionclassname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->exceptionclassname());
    }

    // optional string errorMsg = 5;
    if (has_errormsg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->errormsg());
    }

    // optional .RpcResponseHeaderProto.RpcErrorCodeProto errorDetail = 6;
    if (has_errordetail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->errordetail());
    }

    // optional bytes clientId = 7;
    if (has_clientid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->clientid());
    }

    // optional sint32 retryCount = 8 [default = -1];
    if (has_retrycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->retrycount());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RpcResponseHeaderProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RpcResponseHeaderProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RpcResponseHeaderProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RpcResponseHeaderProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RpcResponseHeaderProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RpcResponseHeaderProto)
    MergeFrom(*source);
  }
}

void RpcResponseHeaderProto::MergeFrom(const RpcResponseHeaderProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RpcResponseHeaderProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_callid()) {
      set_callid(from.callid());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_serveripcversionnum()) {
      set_serveripcversionnum(from.serveripcversionnum());
    }
    if (from.has_exceptionclassname()) {
      set_has_exceptionclassname();
      exceptionclassname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.exceptionclassname_);
    }
    if (from.has_errormsg()) {
      set_has_errormsg();
      errormsg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.errormsg_);
    }
    if (from.has_errordetail()) {
      set_errordetail(from.errordetail());
    }
    if (from.has_clientid()) {
      set_has_clientid();
      clientid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.clientid_);
    }
    if (from.has_retrycount()) {
      set_retrycount(from.retrycount());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RpcResponseHeaderProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RpcResponseHeaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RpcResponseHeaderProto::CopyFrom(const RpcResponseHeaderProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RpcResponseHeaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RpcResponseHeaderProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RpcResponseHeaderProto::Swap(RpcResponseHeaderProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RpcResponseHeaderProto::InternalSwap(RpcResponseHeaderProto* other) {
  std::swap(callid_, other->callid_);
  std::swap(status_, other->status_);
  std::swap(serveripcversionnum_, other->serveripcversionnum_);
  exceptionclassname_.Swap(&other->exceptionclassname_);
  errormsg_.Swap(&other->errormsg_);
  std::swap(errordetail_, other->errordetail_);
  clientid_.Swap(&other->clientid_);
  std::swap(retrycount_, other->retrycount_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RpcResponseHeaderProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RpcResponseHeaderProto_descriptor_;
  metadata.reflection = RpcResponseHeaderProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RpcResponseHeaderProto

// required uint32 callId = 1;
bool RpcResponseHeaderProto::has_callid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RpcResponseHeaderProto::set_has_callid() {
  _has_bits_[0] |= 0x00000001u;
}
void RpcResponseHeaderProto::clear_has_callid() {
  _has_bits_[0] &= ~0x00000001u;
}
void RpcResponseHeaderProto::clear_callid() {
  callid_ = 0u;
  clear_has_callid();
}
 ::google::protobuf::uint32 RpcResponseHeaderProto::callid() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.callId)
  return callid_;
}
 void RpcResponseHeaderProto::set_callid(::google::protobuf::uint32 value) {
  set_has_callid();
  callid_ = value;
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.callId)
}

// required .RpcResponseHeaderProto.RpcStatusProto status = 2;
bool RpcResponseHeaderProto::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RpcResponseHeaderProto::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
void RpcResponseHeaderProto::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
void RpcResponseHeaderProto::clear_status() {
  status_ = 0;
  clear_has_status();
}
 ::RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto::status() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.status)
  return static_cast< ::RpcResponseHeaderProto_RpcStatusProto >(status_);
}
 void RpcResponseHeaderProto::set_status(::RpcResponseHeaderProto_RpcStatusProto value) {
  assert(::RpcResponseHeaderProto_RpcStatusProto_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.status)
}

// optional uint32 serverIpcVersionNum = 3;
bool RpcResponseHeaderProto::has_serveripcversionnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RpcResponseHeaderProto::set_has_serveripcversionnum() {
  _has_bits_[0] |= 0x00000004u;
}
void RpcResponseHeaderProto::clear_has_serveripcversionnum() {
  _has_bits_[0] &= ~0x00000004u;
}
void RpcResponseHeaderProto::clear_serveripcversionnum() {
  serveripcversionnum_ = 0u;
  clear_has_serveripcversionnum();
}
 ::google::protobuf::uint32 RpcResponseHeaderProto::serveripcversionnum() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.serverIpcVersionNum)
  return serveripcversionnum_;
}
 void RpcResponseHeaderProto::set_serveripcversionnum(::google::protobuf::uint32 value) {
  set_has_serveripcversionnum();
  serveripcversionnum_ = value;
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.serverIpcVersionNum)
}

// optional string exceptionClassName = 4;
bool RpcResponseHeaderProto::has_exceptionclassname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RpcResponseHeaderProto::set_has_exceptionclassname() {
  _has_bits_[0] |= 0x00000008u;
}
void RpcResponseHeaderProto::clear_has_exceptionclassname() {
  _has_bits_[0] &= ~0x00000008u;
}
void RpcResponseHeaderProto::clear_exceptionclassname() {
  exceptionclassname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exceptionclassname();
}
 const ::std::string& RpcResponseHeaderProto::exceptionclassname() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.exceptionClassName)
  return exceptionclassname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RpcResponseHeaderProto::set_exceptionclassname(const ::std::string& value) {
  set_has_exceptionclassname();
  exceptionclassname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.exceptionClassName)
}
 void RpcResponseHeaderProto::set_exceptionclassname(const char* value) {
  set_has_exceptionclassname();
  exceptionclassname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RpcResponseHeaderProto.exceptionClassName)
}
 void RpcResponseHeaderProto::set_exceptionclassname(const char* value, size_t size) {
  set_has_exceptionclassname();
  exceptionclassname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RpcResponseHeaderProto.exceptionClassName)
}
 ::std::string* RpcResponseHeaderProto::mutable_exceptionclassname() {
  set_has_exceptionclassname();
  // @@protoc_insertion_point(field_mutable:RpcResponseHeaderProto.exceptionClassName)
  return exceptionclassname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RpcResponseHeaderProto::release_exceptionclassname() {
  // @@protoc_insertion_point(field_release:RpcResponseHeaderProto.exceptionClassName)
  clear_has_exceptionclassname();
  return exceptionclassname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RpcResponseHeaderProto::set_allocated_exceptionclassname(::std::string* exceptionclassname) {
  if (exceptionclassname != NULL) {
    set_has_exceptionclassname();
  } else {
    clear_has_exceptionclassname();
  }
  exceptionclassname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exceptionclassname);
  // @@protoc_insertion_point(field_set_allocated:RpcResponseHeaderProto.exceptionClassName)
}

// optional string errorMsg = 5;
bool RpcResponseHeaderProto::has_errormsg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RpcResponseHeaderProto::set_has_errormsg() {
  _has_bits_[0] |= 0x00000010u;
}
void RpcResponseHeaderProto::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000010u;
}
void RpcResponseHeaderProto::clear_errormsg() {
  errormsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errormsg();
}
 const ::std::string& RpcResponseHeaderProto::errormsg() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.errorMsg)
  return errormsg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RpcResponseHeaderProto::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.errorMsg)
}
 void RpcResponseHeaderProto::set_errormsg(const char* value) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RpcResponseHeaderProto.errorMsg)
}
 void RpcResponseHeaderProto::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RpcResponseHeaderProto.errorMsg)
}
 ::std::string* RpcResponseHeaderProto::mutable_errormsg() {
  set_has_errormsg();
  // @@protoc_insertion_point(field_mutable:RpcResponseHeaderProto.errorMsg)
  return errormsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RpcResponseHeaderProto::release_errormsg() {
  // @@protoc_insertion_point(field_release:RpcResponseHeaderProto.errorMsg)
  clear_has_errormsg();
  return errormsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RpcResponseHeaderProto::set_allocated_errormsg(::std::string* errormsg) {
  if (errormsg != NULL) {
    set_has_errormsg();
  } else {
    clear_has_errormsg();
  }
  errormsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormsg);
  // @@protoc_insertion_point(field_set_allocated:RpcResponseHeaderProto.errorMsg)
}

// optional .RpcResponseHeaderProto.RpcErrorCodeProto errorDetail = 6;
bool RpcResponseHeaderProto::has_errordetail() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RpcResponseHeaderProto::set_has_errordetail() {
  _has_bits_[0] |= 0x00000020u;
}
void RpcResponseHeaderProto::clear_has_errordetail() {
  _has_bits_[0] &= ~0x00000020u;
}
void RpcResponseHeaderProto::clear_errordetail() {
  errordetail_ = 1;
  clear_has_errordetail();
}
 ::RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::errordetail() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.errorDetail)
  return static_cast< ::RpcResponseHeaderProto_RpcErrorCodeProto >(errordetail_);
}
 void RpcResponseHeaderProto::set_errordetail(::RpcResponseHeaderProto_RpcErrorCodeProto value) {
  assert(::RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(value));
  set_has_errordetail();
  errordetail_ = value;
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.errorDetail)
}

// optional bytes clientId = 7;
bool RpcResponseHeaderProto::has_clientid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void RpcResponseHeaderProto::set_has_clientid() {
  _has_bits_[0] |= 0x00000040u;
}
void RpcResponseHeaderProto::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000040u;
}
void RpcResponseHeaderProto::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
 const ::std::string& RpcResponseHeaderProto::clientid() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.clientId)
  return clientid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RpcResponseHeaderProto::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.clientId)
}
 void RpcResponseHeaderProto::set_clientid(const char* value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RpcResponseHeaderProto.clientId)
}
 void RpcResponseHeaderProto::set_clientid(const void* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RpcResponseHeaderProto.clientId)
}
 ::std::string* RpcResponseHeaderProto::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:RpcResponseHeaderProto.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RpcResponseHeaderProto::release_clientid() {
  // @@protoc_insertion_point(field_release:RpcResponseHeaderProto.clientId)
  clear_has_clientid();
  return clientid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RpcResponseHeaderProto::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:RpcResponseHeaderProto.clientId)
}

// optional sint32 retryCount = 8 [default = -1];
bool RpcResponseHeaderProto::has_retrycount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void RpcResponseHeaderProto::set_has_retrycount() {
  _has_bits_[0] |= 0x00000080u;
}
void RpcResponseHeaderProto::clear_has_retrycount() {
  _has_bits_[0] &= ~0x00000080u;
}
void RpcResponseHeaderProto::clear_retrycount() {
  retrycount_ = -1;
  clear_has_retrycount();
}
 ::google::protobuf::int32 RpcResponseHeaderProto::retrycount() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.retryCount)
  return retrycount_;
}
 void RpcResponseHeaderProto::set_retrycount(::google::protobuf::int32 value) {
  set_has_retrycount();
  retrycount_ = value;
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.retryCount)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FsPermissionProto::kPermFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FsPermissionProto::FsPermissionProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FsPermissionProto)
}

void FsPermissionProto::InitAsDefaultInstance() {
}

FsPermissionProto::FsPermissionProto(const FsPermissionProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FsPermissionProto)
}

void FsPermissionProto::SharedCtor() {
  _cached_size_ = 0;
  perm_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FsPermissionProto::~FsPermissionProto() {
  // @@protoc_insertion_point(destructor:FsPermissionProto)
  SharedDtor();
}

void FsPermissionProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FsPermissionProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FsPermissionProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FsPermissionProto_descriptor_;
}

const FsPermissionProto& FsPermissionProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

FsPermissionProto* FsPermissionProto::default_instance_ = NULL;

FsPermissionProto* FsPermissionProto::New(::google::protobuf::Arena* arena) const {
  FsPermissionProto* n = new FsPermissionProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FsPermissionProto::Clear() {
// @@protoc_insertion_point(message_clear_start:FsPermissionProto)
  perm_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool FsPermissionProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:FsPermissionProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 perm = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &perm_)));
          set_has_perm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:FsPermissionProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FsPermissionProto)
  return false;
#undef DO_
}

void FsPermissionProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FsPermissionProto)
  // required uint32 perm = 1;
  if (has_perm()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->perm(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:FsPermissionProto)
}

::google::protobuf::uint8* FsPermissionProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:FsPermissionProto)
  // required uint32 perm = 1;
  if (has_perm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->perm(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:FsPermissionProto)
  return target;
}

int FsPermissionProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:FsPermissionProto)
  int total_size = 0;

  // required uint32 perm = 1;
  if (has_perm()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->perm());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FsPermissionProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:FsPermissionProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const FsPermissionProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const FsPermissionProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:FsPermissionProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:FsPermissionProto)
    MergeFrom(*source);
  }
}

void FsPermissionProto::MergeFrom(const FsPermissionProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:FsPermissionProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_perm()) {
      set_perm(from.perm());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void FsPermissionProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:FsPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FsPermissionProto::CopyFrom(const FsPermissionProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:FsPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FsPermissionProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FsPermissionProto::Swap(FsPermissionProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FsPermissionProto::InternalSwap(FsPermissionProto* other) {
  std::swap(perm_, other->perm_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FsPermissionProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FsPermissionProto_descriptor_;
  metadata.reflection = FsPermissionProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FsPermissionProto

// required uint32 perm = 1;
bool FsPermissionProto::has_perm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FsPermissionProto::set_has_perm() {
  _has_bits_[0] |= 0x00000001u;
}
void FsPermissionProto::clear_has_perm() {
  _has_bits_[0] &= ~0x00000001u;
}
void FsPermissionProto::clear_perm() {
  perm_ = 0u;
  clear_has_perm();
}
 ::google::protobuf::uint32 FsPermissionProto::perm() const {
  // @@protoc_insertion_point(field_get:FsPermissionProto.perm)
  return perm_;
}
 void FsPermissionProto::set_perm(::google::protobuf::uint32 value) {
  set_has_perm();
  perm_ = value;
  // @@protoc_insertion_point(field_set:FsPermissionProto.perm)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ExtendedBlockProto::kPoolIdFieldNumber;
const int ExtendedBlockProto::kBlockIdFieldNumber;
const int ExtendedBlockProto::kGenerationStampFieldNumber;
const int ExtendedBlockProto::kNumBytesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ExtendedBlockProto::ExtendedBlockProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ExtendedBlockProto)
}

void ExtendedBlockProto::InitAsDefaultInstance() {
}

ExtendedBlockProto::ExtendedBlockProto(const ExtendedBlockProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ExtendedBlockProto)
}

void ExtendedBlockProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  poolid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  blockid_ = GOOGLE_ULONGLONG(0);
  generationstamp_ = GOOGLE_ULONGLONG(0);
  numbytes_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExtendedBlockProto::~ExtendedBlockProto() {
  // @@protoc_insertion_point(destructor:ExtendedBlockProto)
  SharedDtor();
}

void ExtendedBlockProto::SharedDtor() {
  poolid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void ExtendedBlockProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExtendedBlockProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExtendedBlockProto_descriptor_;
}

const ExtendedBlockProto& ExtendedBlockProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

ExtendedBlockProto* ExtendedBlockProto::default_instance_ = NULL;

ExtendedBlockProto* ExtendedBlockProto::New(::google::protobuf::Arena* arena) const {
  ExtendedBlockProto* n = new ExtendedBlockProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ExtendedBlockProto::Clear() {
// @@protoc_insertion_point(message_clear_start:ExtendedBlockProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ExtendedBlockProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ExtendedBlockProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(blockid_, numbytes_);
    if (has_poolid()) {
      poolid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ExtendedBlockProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ExtendedBlockProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string poolId = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_poolid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->poolid().data(), this->poolid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ExtendedBlockProto.poolId");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_blockId;
        break;
      }

      // required uint64 blockId = 2;
      case 2: {
        if (tag == 16) {
         parse_blockId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blockid_)));
          set_has_blockid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_generationStamp;
        break;
      }

      // required uint64 generationStamp = 3;
      case 3: {
        if (tag == 24) {
         parse_generationStamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &generationstamp_)));
          set_has_generationstamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_numBytes;
        break;
      }

      // optional uint64 numBytes = 4 [default = 0];
      case 4: {
        if (tag == 32) {
         parse_numBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &numbytes_)));
          set_has_numbytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ExtendedBlockProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ExtendedBlockProto)
  return false;
#undef DO_
}

void ExtendedBlockProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ExtendedBlockProto)
  // required string poolId = 1;
  if (has_poolid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->poolid().data(), this->poolid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ExtendedBlockProto.poolId");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->poolid(), output);
  }

  // required uint64 blockId = 2;
  if (has_blockid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->blockid(), output);
  }

  // required uint64 generationStamp = 3;
  if (has_generationstamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->generationstamp(), output);
  }

  // optional uint64 numBytes = 4 [default = 0];
  if (has_numbytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->numbytes(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ExtendedBlockProto)
}

::google::protobuf::uint8* ExtendedBlockProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ExtendedBlockProto)
  // required string poolId = 1;
  if (has_poolid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->poolid().data(), this->poolid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ExtendedBlockProto.poolId");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->poolid(), target);
  }

  // required uint64 blockId = 2;
  if (has_blockid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->blockid(), target);
  }

  // required uint64 generationStamp = 3;
  if (has_generationstamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->generationstamp(), target);
  }

  // optional uint64 numBytes = 4 [default = 0];
  if (has_numbytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->numbytes(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ExtendedBlockProto)
  return target;
}

int ExtendedBlockProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ExtendedBlockProto)
  int total_size = 0;

  if (has_poolid()) {
    // required string poolId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->poolid());
  }

  if (has_blockid()) {
    // required uint64 blockId = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->blockid());
  }

  if (has_generationstamp()) {
    // required uint64 generationStamp = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->generationstamp());
  }

  return total_size;
}
int ExtendedBlockProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:ExtendedBlockProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string poolId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->poolid());

    // required uint64 blockId = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->blockid());

    // required uint64 generationStamp = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->generationstamp());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional uint64 numBytes = 4 [default = 0];
  if (has_numbytes()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->numbytes());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExtendedBlockProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ExtendedBlockProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ExtendedBlockProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ExtendedBlockProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ExtendedBlockProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ExtendedBlockProto)
    MergeFrom(*source);
  }
}

void ExtendedBlockProto::MergeFrom(const ExtendedBlockProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ExtendedBlockProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_poolid()) {
      set_has_poolid();
      poolid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.poolid_);
    }
    if (from.has_blockid()) {
      set_blockid(from.blockid());
    }
    if (from.has_generationstamp()) {
      set_generationstamp(from.generationstamp());
    }
    if (from.has_numbytes()) {
      set_numbytes(from.numbytes());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ExtendedBlockProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ExtendedBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExtendedBlockProto::CopyFrom(const ExtendedBlockProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ExtendedBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtendedBlockProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ExtendedBlockProto::Swap(ExtendedBlockProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ExtendedBlockProto::InternalSwap(ExtendedBlockProto* other) {
  poolid_.Swap(&other->poolid_);
  std::swap(blockid_, other->blockid_);
  std::swap(generationstamp_, other->generationstamp_);
  std::swap(numbytes_, other->numbytes_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ExtendedBlockProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExtendedBlockProto_descriptor_;
  metadata.reflection = ExtendedBlockProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ExtendedBlockProto

// required string poolId = 1;
bool ExtendedBlockProto::has_poolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ExtendedBlockProto::set_has_poolid() {
  _has_bits_[0] |= 0x00000001u;
}
void ExtendedBlockProto::clear_has_poolid() {
  _has_bits_[0] &= ~0x00000001u;
}
void ExtendedBlockProto::clear_poolid() {
  poolid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_poolid();
}
 const ::std::string& ExtendedBlockProto::poolid() const {
  // @@protoc_insertion_point(field_get:ExtendedBlockProto.poolId)
  return poolid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExtendedBlockProto::set_poolid(const ::std::string& value) {
  set_has_poolid();
  poolid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ExtendedBlockProto.poolId)
}
 void ExtendedBlockProto::set_poolid(const char* value) {
  set_has_poolid();
  poolid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ExtendedBlockProto.poolId)
}
 void ExtendedBlockProto::set_poolid(const char* value, size_t size) {
  set_has_poolid();
  poolid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ExtendedBlockProto.poolId)
}
 ::std::string* ExtendedBlockProto::mutable_poolid() {
  set_has_poolid();
  // @@protoc_insertion_point(field_mutable:ExtendedBlockProto.poolId)
  return poolid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ExtendedBlockProto::release_poolid() {
  // @@protoc_insertion_point(field_release:ExtendedBlockProto.poolId)
  clear_has_poolid();
  return poolid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExtendedBlockProto::set_allocated_poolid(::std::string* poolid) {
  if (poolid != NULL) {
    set_has_poolid();
  } else {
    clear_has_poolid();
  }
  poolid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), poolid);
  // @@protoc_insertion_point(field_set_allocated:ExtendedBlockProto.poolId)
}

// required uint64 blockId = 2;
bool ExtendedBlockProto::has_blockid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ExtendedBlockProto::set_has_blockid() {
  _has_bits_[0] |= 0x00000002u;
}
void ExtendedBlockProto::clear_has_blockid() {
  _has_bits_[0] &= ~0x00000002u;
}
void ExtendedBlockProto::clear_blockid() {
  blockid_ = GOOGLE_ULONGLONG(0);
  clear_has_blockid();
}
 ::google::protobuf::uint64 ExtendedBlockProto::blockid() const {
  // @@protoc_insertion_point(field_get:ExtendedBlockProto.blockId)
  return blockid_;
}
 void ExtendedBlockProto::set_blockid(::google::protobuf::uint64 value) {
  set_has_blockid();
  blockid_ = value;
  // @@protoc_insertion_point(field_set:ExtendedBlockProto.blockId)
}

// required uint64 generationStamp = 3;
bool ExtendedBlockProto::has_generationstamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ExtendedBlockProto::set_has_generationstamp() {
  _has_bits_[0] |= 0x00000004u;
}
void ExtendedBlockProto::clear_has_generationstamp() {
  _has_bits_[0] &= ~0x00000004u;
}
void ExtendedBlockProto::clear_generationstamp() {
  generationstamp_ = GOOGLE_ULONGLONG(0);
  clear_has_generationstamp();
}
 ::google::protobuf::uint64 ExtendedBlockProto::generationstamp() const {
  // @@protoc_insertion_point(field_get:ExtendedBlockProto.generationStamp)
  return generationstamp_;
}
 void ExtendedBlockProto::set_generationstamp(::google::protobuf::uint64 value) {
  set_has_generationstamp();
  generationstamp_ = value;
  // @@protoc_insertion_point(field_set:ExtendedBlockProto.generationStamp)
}

// optional uint64 numBytes = 4 [default = 0];
bool ExtendedBlockProto::has_numbytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ExtendedBlockProto::set_has_numbytes() {
  _has_bits_[0] |= 0x00000008u;
}
void ExtendedBlockProto::clear_has_numbytes() {
  _has_bits_[0] &= ~0x00000008u;
}
void ExtendedBlockProto::clear_numbytes() {
  numbytes_ = GOOGLE_ULONGLONG(0);
  clear_has_numbytes();
}
 ::google::protobuf::uint64 ExtendedBlockProto::numbytes() const {
  // @@protoc_insertion_point(field_get:ExtendedBlockProto.numBytes)
  return numbytes_;
}
 void ExtendedBlockProto::set_numbytes(::google::protobuf::uint64 value) {
  set_has_numbytes();
  numbytes_ = value;
  // @@protoc_insertion_point(field_set:ExtendedBlockProto.numBytes)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DatanodeIDProto::kIpAddrFieldNumber;
const int DatanodeIDProto::kHostNameFieldNumber;
const int DatanodeIDProto::kDatanodeUuidFieldNumber;
const int DatanodeIDProto::kXferPortFieldNumber;
const int DatanodeIDProto::kInfoPortFieldNumber;
const int DatanodeIDProto::kIpcPortFieldNumber;
const int DatanodeIDProto::kInfoSecurePortFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DatanodeIDProto::DatanodeIDProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DatanodeIDProto)
}

void DatanodeIDProto::InitAsDefaultInstance() {
}

DatanodeIDProto::DatanodeIDProto(const DatanodeIDProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DatanodeIDProto)
}

void DatanodeIDProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ipaddr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hostname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  datanodeuuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  xferport_ = 0u;
  infoport_ = 0u;
  ipcport_ = 0u;
  infosecureport_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DatanodeIDProto::~DatanodeIDProto() {
  // @@protoc_insertion_point(destructor:DatanodeIDProto)
  SharedDtor();
}

void DatanodeIDProto::SharedDtor() {
  ipaddr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hostname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  datanodeuuid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void DatanodeIDProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DatanodeIDProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DatanodeIDProto_descriptor_;
}

const DatanodeIDProto& DatanodeIDProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

DatanodeIDProto* DatanodeIDProto::default_instance_ = NULL;

DatanodeIDProto* DatanodeIDProto::New(::google::protobuf::Arena* arena) const {
  DatanodeIDProto* n = new DatanodeIDProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DatanodeIDProto::Clear() {
// @@protoc_insertion_point(message_clear_start:DatanodeIDProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(DatanodeIDProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DatanodeIDProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(xferport_, infosecureport_);
    if (has_ipaddr()) {
      ipaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_hostname()) {
      hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_datanodeuuid()) {
      datanodeuuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DatanodeIDProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DatanodeIDProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ipAddr = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ipaddr()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ipaddr().data(), this->ipaddr().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "DatanodeIDProto.ipAddr");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_hostName;
        break;
      }

      // required string hostName = 2;
      case 2: {
        if (tag == 18) {
         parse_hostName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "DatanodeIDProto.hostName");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_datanodeUuid;
        break;
      }

      // required string datanodeUuid = 3;
      case 3: {
        if (tag == 26) {
         parse_datanodeUuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_datanodeuuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->datanodeuuid().data(), this->datanodeuuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "DatanodeIDProto.datanodeUuid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_xferPort;
        break;
      }

      // required uint32 xferPort = 4;
      case 4: {
        if (tag == 32) {
         parse_xferPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &xferport_)));
          set_has_xferport();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_infoPort;
        break;
      }

      // required uint32 infoPort = 5;
      case 5: {
        if (tag == 40) {
         parse_infoPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &infoport_)));
          set_has_infoport();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_ipcPort;
        break;
      }

      // required uint32 ipcPort = 6;
      case 6: {
        if (tag == 48) {
         parse_ipcPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ipcport_)));
          set_has_ipcport();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_infoSecurePort;
        break;
      }

      // optional uint32 infoSecurePort = 7 [default = 0];
      case 7: {
        if (tag == 56) {
         parse_infoSecurePort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &infosecureport_)));
          set_has_infosecureport();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DatanodeIDProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DatanodeIDProto)
  return false;
#undef DO_
}

void DatanodeIDProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DatanodeIDProto)
  // required string ipAddr = 1;
  if (has_ipaddr()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ipaddr().data(), this->ipaddr().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeIDProto.ipAddr");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->ipaddr(), output);
  }

  // required string hostName = 2;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeIDProto.hostName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->hostname(), output);
  }

  // required string datanodeUuid = 3;
  if (has_datanodeuuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->datanodeuuid().data(), this->datanodeuuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeIDProto.datanodeUuid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->datanodeuuid(), output);
  }

  // required uint32 xferPort = 4;
  if (has_xferport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->xferport(), output);
  }

  // required uint32 infoPort = 5;
  if (has_infoport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->infoport(), output);
  }

  // required uint32 ipcPort = 6;
  if (has_ipcport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->ipcport(), output);
  }

  // optional uint32 infoSecurePort = 7 [default = 0];
  if (has_infosecureport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->infosecureport(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DatanodeIDProto)
}

::google::protobuf::uint8* DatanodeIDProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DatanodeIDProto)
  // required string ipAddr = 1;
  if (has_ipaddr()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ipaddr().data(), this->ipaddr().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeIDProto.ipAddr");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->ipaddr(), target);
  }

  // required string hostName = 2;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeIDProto.hostName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->hostname(), target);
  }

  // required string datanodeUuid = 3;
  if (has_datanodeuuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->datanodeuuid().data(), this->datanodeuuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeIDProto.datanodeUuid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->datanodeuuid(), target);
  }

  // required uint32 xferPort = 4;
  if (has_xferport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->xferport(), target);
  }

  // required uint32 infoPort = 5;
  if (has_infoport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->infoport(), target);
  }

  // required uint32 ipcPort = 6;
  if (has_ipcport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->ipcport(), target);
  }

  // optional uint32 infoSecurePort = 7 [default = 0];
  if (has_infosecureport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->infosecureport(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DatanodeIDProto)
  return target;
}

int DatanodeIDProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DatanodeIDProto)
  int total_size = 0;

  if (has_ipaddr()) {
    // required string ipAddr = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ipaddr());
  }

  if (has_hostname()) {
    // required string hostName = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->hostname());
  }

  if (has_datanodeuuid()) {
    // required string datanodeUuid = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->datanodeuuid());
  }

  if (has_xferport()) {
    // required uint32 xferPort = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->xferport());
  }

  if (has_infoport()) {
    // required uint32 infoPort = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->infoport());
  }

  if (has_ipcport()) {
    // required uint32 ipcPort = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ipcport());
  }

  return total_size;
}
int DatanodeIDProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DatanodeIDProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required string ipAddr = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ipaddr());

    // required string hostName = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->hostname());

    // required string datanodeUuid = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->datanodeuuid());

    // required uint32 xferPort = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->xferport());

    // required uint32 infoPort = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->infoport());

    // required uint32 ipcPort = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ipcport());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional uint32 infoSecurePort = 7 [default = 0];
  if (has_infosecureport()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->infosecureport());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DatanodeIDProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DatanodeIDProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const DatanodeIDProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DatanodeIDProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DatanodeIDProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DatanodeIDProto)
    MergeFrom(*source);
  }
}

void DatanodeIDProto::MergeFrom(const DatanodeIDProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DatanodeIDProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ipaddr()) {
      set_has_ipaddr();
      ipaddr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ipaddr_);
    }
    if (from.has_hostname()) {
      set_has_hostname();
      hostname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hostname_);
    }
    if (from.has_datanodeuuid()) {
      set_has_datanodeuuid();
      datanodeuuid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.datanodeuuid_);
    }
    if (from.has_xferport()) {
      set_xferport(from.xferport());
    }
    if (from.has_infoport()) {
      set_infoport(from.infoport());
    }
    if (from.has_ipcport()) {
      set_ipcport(from.ipcport());
    }
    if (from.has_infosecureport()) {
      set_infosecureport(from.infosecureport());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DatanodeIDProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DatanodeIDProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DatanodeIDProto::CopyFrom(const DatanodeIDProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DatanodeIDProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatanodeIDProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void DatanodeIDProto::Swap(DatanodeIDProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DatanodeIDProto::InternalSwap(DatanodeIDProto* other) {
  ipaddr_.Swap(&other->ipaddr_);
  hostname_.Swap(&other->hostname_);
  datanodeuuid_.Swap(&other->datanodeuuid_);
  std::swap(xferport_, other->xferport_);
  std::swap(infoport_, other->infoport_);
  std::swap(ipcport_, other->ipcport_);
  std::swap(infosecureport_, other->infosecureport_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DatanodeIDProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DatanodeIDProto_descriptor_;
  metadata.reflection = DatanodeIDProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DatanodeIDProto

// required string ipAddr = 1;
bool DatanodeIDProto::has_ipaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DatanodeIDProto::set_has_ipaddr() {
  _has_bits_[0] |= 0x00000001u;
}
void DatanodeIDProto::clear_has_ipaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
void DatanodeIDProto::clear_ipaddr() {
  ipaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ipaddr();
}
 const ::std::string& DatanodeIDProto::ipaddr() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.ipAddr)
  return ipaddr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeIDProto::set_ipaddr(const ::std::string& value) {
  set_has_ipaddr();
  ipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeIDProto.ipAddr)
}
 void DatanodeIDProto::set_ipaddr(const char* value) {
  set_has_ipaddr();
  ipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeIDProto.ipAddr)
}
 void DatanodeIDProto::set_ipaddr(const char* value, size_t size) {
  set_has_ipaddr();
  ipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeIDProto.ipAddr)
}
 ::std::string* DatanodeIDProto::mutable_ipaddr() {
  set_has_ipaddr();
  // @@protoc_insertion_point(field_mutable:DatanodeIDProto.ipAddr)
  return ipaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DatanodeIDProto::release_ipaddr() {
  // @@protoc_insertion_point(field_release:DatanodeIDProto.ipAddr)
  clear_has_ipaddr();
  return ipaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeIDProto::set_allocated_ipaddr(::std::string* ipaddr) {
  if (ipaddr != NULL) {
    set_has_ipaddr();
  } else {
    clear_has_ipaddr();
  }
  ipaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipaddr);
  // @@protoc_insertion_point(field_set_allocated:DatanodeIDProto.ipAddr)
}

// required string hostName = 2;
bool DatanodeIDProto::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DatanodeIDProto::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
void DatanodeIDProto::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
void DatanodeIDProto::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
 const ::std::string& DatanodeIDProto::hostname() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.hostName)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeIDProto::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeIDProto.hostName)
}
 void DatanodeIDProto::set_hostname(const char* value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeIDProto.hostName)
}
 void DatanodeIDProto::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeIDProto.hostName)
}
 ::std::string* DatanodeIDProto::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:DatanodeIDProto.hostName)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DatanodeIDProto::release_hostname() {
  // @@protoc_insertion_point(field_release:DatanodeIDProto.hostName)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeIDProto::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:DatanodeIDProto.hostName)
}

// required string datanodeUuid = 3;
bool DatanodeIDProto::has_datanodeuuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DatanodeIDProto::set_has_datanodeuuid() {
  _has_bits_[0] |= 0x00000004u;
}
void DatanodeIDProto::clear_has_datanodeuuid() {
  _has_bits_[0] &= ~0x00000004u;
}
void DatanodeIDProto::clear_datanodeuuid() {
  datanodeuuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_datanodeuuid();
}
 const ::std::string& DatanodeIDProto::datanodeuuid() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.datanodeUuid)
  return datanodeuuid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeIDProto::set_datanodeuuid(const ::std::string& value) {
  set_has_datanodeuuid();
  datanodeuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeIDProto.datanodeUuid)
}
 void DatanodeIDProto::set_datanodeuuid(const char* value) {
  set_has_datanodeuuid();
  datanodeuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeIDProto.datanodeUuid)
}
 void DatanodeIDProto::set_datanodeuuid(const char* value, size_t size) {
  set_has_datanodeuuid();
  datanodeuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeIDProto.datanodeUuid)
}
 ::std::string* DatanodeIDProto::mutable_datanodeuuid() {
  set_has_datanodeuuid();
  // @@protoc_insertion_point(field_mutable:DatanodeIDProto.datanodeUuid)
  return datanodeuuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DatanodeIDProto::release_datanodeuuid() {
  // @@protoc_insertion_point(field_release:DatanodeIDProto.datanodeUuid)
  clear_has_datanodeuuid();
  return datanodeuuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeIDProto::set_allocated_datanodeuuid(::std::string* datanodeuuid) {
  if (datanodeuuid != NULL) {
    set_has_datanodeuuid();
  } else {
    clear_has_datanodeuuid();
  }
  datanodeuuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), datanodeuuid);
  // @@protoc_insertion_point(field_set_allocated:DatanodeIDProto.datanodeUuid)
}

// required uint32 xferPort = 4;
bool DatanodeIDProto::has_xferport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DatanodeIDProto::set_has_xferport() {
  _has_bits_[0] |= 0x00000008u;
}
void DatanodeIDProto::clear_has_xferport() {
  _has_bits_[0] &= ~0x00000008u;
}
void DatanodeIDProto::clear_xferport() {
  xferport_ = 0u;
  clear_has_xferport();
}
 ::google::protobuf::uint32 DatanodeIDProto::xferport() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.xferPort)
  return xferport_;
}
 void DatanodeIDProto::set_xferport(::google::protobuf::uint32 value) {
  set_has_xferport();
  xferport_ = value;
  // @@protoc_insertion_point(field_set:DatanodeIDProto.xferPort)
}

// required uint32 infoPort = 5;
bool DatanodeIDProto::has_infoport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void DatanodeIDProto::set_has_infoport() {
  _has_bits_[0] |= 0x00000010u;
}
void DatanodeIDProto::clear_has_infoport() {
  _has_bits_[0] &= ~0x00000010u;
}
void DatanodeIDProto::clear_infoport() {
  infoport_ = 0u;
  clear_has_infoport();
}
 ::google::protobuf::uint32 DatanodeIDProto::infoport() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.infoPort)
  return infoport_;
}
 void DatanodeIDProto::set_infoport(::google::protobuf::uint32 value) {
  set_has_infoport();
  infoport_ = value;
  // @@protoc_insertion_point(field_set:DatanodeIDProto.infoPort)
}

// required uint32 ipcPort = 6;
bool DatanodeIDProto::has_ipcport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void DatanodeIDProto::set_has_ipcport() {
  _has_bits_[0] |= 0x00000020u;
}
void DatanodeIDProto::clear_has_ipcport() {
  _has_bits_[0] &= ~0x00000020u;
}
void DatanodeIDProto::clear_ipcport() {
  ipcport_ = 0u;
  clear_has_ipcport();
}
 ::google::protobuf::uint32 DatanodeIDProto::ipcport() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.ipcPort)
  return ipcport_;
}
 void DatanodeIDProto::set_ipcport(::google::protobuf::uint32 value) {
  set_has_ipcport();
  ipcport_ = value;
  // @@protoc_insertion_point(field_set:DatanodeIDProto.ipcPort)
}

// optional uint32 infoSecurePort = 7 [default = 0];
bool DatanodeIDProto::has_infosecureport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void DatanodeIDProto::set_has_infosecureport() {
  _has_bits_[0] |= 0x00000040u;
}
void DatanodeIDProto::clear_has_infosecureport() {
  _has_bits_[0] &= ~0x00000040u;
}
void DatanodeIDProto::clear_infosecureport() {
  infosecureport_ = 0u;
  clear_has_infosecureport();
}
 ::google::protobuf::uint32 DatanodeIDProto::infosecureport() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.infoSecurePort)
  return infosecureport_;
}
 void DatanodeIDProto::set_infosecureport(::google::protobuf::uint32 value) {
  set_has_infosecureport();
  infosecureport_ = value;
  // @@protoc_insertion_point(field_set:DatanodeIDProto.infoSecurePort)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* DatanodeInfoProto_AdminState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DatanodeInfoProto_AdminState_descriptor_;
}
bool DatanodeInfoProto_AdminState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const DatanodeInfoProto_AdminState DatanodeInfoProto::NORMAL;
const DatanodeInfoProto_AdminState DatanodeInfoProto::DECOMMISSION_INPROGRESS;
const DatanodeInfoProto_AdminState DatanodeInfoProto::DECOMMISSIONED;
const DatanodeInfoProto_AdminState DatanodeInfoProto::AdminState_MIN;
const DatanodeInfoProto_AdminState DatanodeInfoProto::AdminState_MAX;
const int DatanodeInfoProto::AdminState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DatanodeInfoProto::kIdFieldNumber;
const int DatanodeInfoProto::kCapacityFieldNumber;
const int DatanodeInfoProto::kDfsUsedFieldNumber;
const int DatanodeInfoProto::kRemainingFieldNumber;
const int DatanodeInfoProto::kBlockPoolUsedFieldNumber;
const int DatanodeInfoProto::kLastUpdateFieldNumber;
const int DatanodeInfoProto::kXceiverCountFieldNumber;
const int DatanodeInfoProto::kLocationFieldNumber;
const int DatanodeInfoProto::kNonDfsUsedFieldNumber;
const int DatanodeInfoProto::kAdminStateFieldNumber;
const int DatanodeInfoProto::kCacheCapacityFieldNumber;
const int DatanodeInfoProto::kCacheUsedFieldNumber;
const int DatanodeInfoProto::kLastUpdateMonotonicFieldNumber;
const int DatanodeInfoProto::kUpgradeDomainFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DatanodeInfoProto::DatanodeInfoProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DatanodeInfoProto)
}

void DatanodeInfoProto::InitAsDefaultInstance() {
  id_ = const_cast< ::DatanodeIDProto*>(&::DatanodeIDProto::default_instance());
}

DatanodeInfoProto::DatanodeInfoProto(const DatanodeInfoProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DatanodeInfoProto)
}

void DatanodeInfoProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = NULL;
  capacity_ = GOOGLE_ULONGLONG(0);
  dfsused_ = GOOGLE_ULONGLONG(0);
  remaining_ = GOOGLE_ULONGLONG(0);
  blockpoolused_ = GOOGLE_ULONGLONG(0);
  lastupdate_ = GOOGLE_ULONGLONG(0);
  xceivercount_ = 0u;
  location_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nondfsused_ = GOOGLE_ULONGLONG(0);
  adminstate_ = 0;
  cachecapacity_ = GOOGLE_ULONGLONG(0);
  cacheused_ = GOOGLE_ULONGLONG(0);
  lastupdatemonotonic_ = GOOGLE_ULONGLONG(0);
  upgradedomain_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DatanodeInfoProto::~DatanodeInfoProto() {
  // @@protoc_insertion_point(destructor:DatanodeInfoProto)
  SharedDtor();
}

void DatanodeInfoProto::SharedDtor() {
  location_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  upgradedomain_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete id_;
  }
}

void DatanodeInfoProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DatanodeInfoProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DatanodeInfoProto_descriptor_;
}

const DatanodeInfoProto& DatanodeInfoProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

DatanodeInfoProto* DatanodeInfoProto::default_instance_ = NULL;

DatanodeInfoProto* DatanodeInfoProto::New(::google::protobuf::Arena* arena) const {
  DatanodeInfoProto* n = new DatanodeInfoProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DatanodeInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:DatanodeInfoProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(DatanodeInfoProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DatanodeInfoProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(capacity_, lastupdate_);
    if (has_id()) {
      if (id_ != NULL) id_->::DatanodeIDProto::Clear();
    }
    xceivercount_ = 0u;
    if (has_location()) {
      location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[8 / 32] & 16128u) {
    ZR_(adminstate_, lastupdatemonotonic_);
    if (has_upgradedomain()) {
      upgradedomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DatanodeInfoProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DatanodeInfoProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DatanodeIDProto id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_capacity;
        break;
      }

      // optional uint64 capacity = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &capacity_)));
          set_has_capacity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dfsUsed;
        break;
      }

      // optional uint64 dfsUsed = 3 [default = 0];
      case 3: {
        if (tag == 24) {
         parse_dfsUsed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dfsused_)));
          set_has_dfsused();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_remaining;
        break;
      }

      // optional uint64 remaining = 4 [default = 0];
      case 4: {
        if (tag == 32) {
         parse_remaining:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &remaining_)));
          set_has_remaining();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_blockPoolUsed;
        break;
      }

      // optional uint64 blockPoolUsed = 5 [default = 0];
      case 5: {
        if (tag == 40) {
         parse_blockPoolUsed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blockpoolused_)));
          set_has_blockpoolused();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_lastUpdate;
        break;
      }

      // optional uint64 lastUpdate = 6 [default = 0];
      case 6: {
        if (tag == 48) {
         parse_lastUpdate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &lastupdate_)));
          set_has_lastupdate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_xceiverCount;
        break;
      }

      // optional uint32 xceiverCount = 7 [default = 0];
      case 7: {
        if (tag == 56) {
         parse_xceiverCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &xceivercount_)));
          set_has_xceivercount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_location;
        break;
      }

      // optional string location = 8;
      case 8: {
        if (tag == 66) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_location()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->location().data(), this->location().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "DatanodeInfoProto.location");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_nonDfsUsed;
        break;
      }

      // optional uint64 nonDfsUsed = 9;
      case 9: {
        if (tag == 72) {
         parse_nonDfsUsed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &nondfsused_)));
          set_has_nondfsused();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_adminState;
        break;
      }

      // optional .DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
      case 10: {
        if (tag == 80) {
         parse_adminState:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::DatanodeInfoProto_AdminState_IsValid(value)) {
            set_adminstate(static_cast< ::DatanodeInfoProto_AdminState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(10, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_cacheCapacity;
        break;
      }

      // optional uint64 cacheCapacity = 11 [default = 0];
      case 11: {
        if (tag == 88) {
         parse_cacheCapacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cachecapacity_)));
          set_has_cachecapacity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_cacheUsed;
        break;
      }

      // optional uint64 cacheUsed = 12 [default = 0];
      case 12: {
        if (tag == 96) {
         parse_cacheUsed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cacheused_)));
          set_has_cacheused();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_lastUpdateMonotonic;
        break;
      }

      // optional uint64 lastUpdateMonotonic = 13 [default = 0];
      case 13: {
        if (tag == 104) {
         parse_lastUpdateMonotonic:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &lastupdatemonotonic_)));
          set_has_lastupdatemonotonic();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_upgradeDomain;
        break;
      }

      // optional string upgradeDomain = 14;
      case 14: {
        if (tag == 114) {
         parse_upgradeDomain:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_upgradedomain()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->upgradedomain().data(), this->upgradedomain().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "DatanodeInfoProto.upgradeDomain");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DatanodeInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DatanodeInfoProto)
  return false;
#undef DO_
}

void DatanodeInfoProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DatanodeInfoProto)
  // required .DatanodeIDProto id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->id_, output);
  }

  // optional uint64 capacity = 2 [default = 0];
  if (has_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->capacity(), output);
  }

  // optional uint64 dfsUsed = 3 [default = 0];
  if (has_dfsused()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->dfsused(), output);
  }

  // optional uint64 remaining = 4 [default = 0];
  if (has_remaining()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->remaining(), output);
  }

  // optional uint64 blockPoolUsed = 5 [default = 0];
  if (has_blockpoolused()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->blockpoolused(), output);
  }

  // optional uint64 lastUpdate = 6 [default = 0];
  if (has_lastupdate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->lastupdate(), output);
  }

  // optional uint32 xceiverCount = 7 [default = 0];
  if (has_xceivercount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->xceivercount(), output);
  }

  // optional string location = 8;
  if (has_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->location().data(), this->location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeInfoProto.location");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->location(), output);
  }

  // optional uint64 nonDfsUsed = 9;
  if (has_nondfsused()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->nondfsused(), output);
  }

  // optional .DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
  if (has_adminstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->adminstate(), output);
  }

  // optional uint64 cacheCapacity = 11 [default = 0];
  if (has_cachecapacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->cachecapacity(), output);
  }

  // optional uint64 cacheUsed = 12 [default = 0];
  if (has_cacheused()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(12, this->cacheused(), output);
  }

  // optional uint64 lastUpdateMonotonic = 13 [default = 0];
  if (has_lastupdatemonotonic()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(13, this->lastupdatemonotonic(), output);
  }

  // optional string upgradeDomain = 14;
  if (has_upgradedomain()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->upgradedomain().data(), this->upgradedomain().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeInfoProto.upgradeDomain");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      14, this->upgradedomain(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DatanodeInfoProto)
}

::google::protobuf::uint8* DatanodeInfoProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DatanodeInfoProto)
  // required .DatanodeIDProto id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->id_, false, target);
  }

  // optional uint64 capacity = 2 [default = 0];
  if (has_capacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->capacity(), target);
  }

  // optional uint64 dfsUsed = 3 [default = 0];
  if (has_dfsused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->dfsused(), target);
  }

  // optional uint64 remaining = 4 [default = 0];
  if (has_remaining()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->remaining(), target);
  }

  // optional uint64 blockPoolUsed = 5 [default = 0];
  if (has_blockpoolused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->blockpoolused(), target);
  }

  // optional uint64 lastUpdate = 6 [default = 0];
  if (has_lastupdate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->lastupdate(), target);
  }

  // optional uint32 xceiverCount = 7 [default = 0];
  if (has_xceivercount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->xceivercount(), target);
  }

  // optional string location = 8;
  if (has_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->location().data(), this->location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeInfoProto.location");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->location(), target);
  }

  // optional uint64 nonDfsUsed = 9;
  if (has_nondfsused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(9, this->nondfsused(), target);
  }

  // optional .DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
  if (has_adminstate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->adminstate(), target);
  }

  // optional uint64 cacheCapacity = 11 [default = 0];
  if (has_cachecapacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->cachecapacity(), target);
  }

  // optional uint64 cacheUsed = 12 [default = 0];
  if (has_cacheused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(12, this->cacheused(), target);
  }

  // optional uint64 lastUpdateMonotonic = 13 [default = 0];
  if (has_lastupdatemonotonic()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(13, this->lastupdatemonotonic(), target);
  }

  // optional string upgradeDomain = 14;
  if (has_upgradedomain()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->upgradedomain().data(), this->upgradedomain().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeInfoProto.upgradeDomain");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->upgradedomain(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DatanodeInfoProto)
  return target;
}

int DatanodeInfoProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DatanodeInfoProto)
  int total_size = 0;

  // required .DatanodeIDProto id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->id_);
  }
  if (_has_bits_[1 / 32] & 254u) {
    // optional uint64 capacity = 2 [default = 0];
    if (has_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->capacity());
    }

    // optional uint64 dfsUsed = 3 [default = 0];
    if (has_dfsused()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dfsused());
    }

    // optional uint64 remaining = 4 [default = 0];
    if (has_remaining()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->remaining());
    }

    // optional uint64 blockPoolUsed = 5 [default = 0];
    if (has_blockpoolused()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->blockpoolused());
    }

    // optional uint64 lastUpdate = 6 [default = 0];
    if (has_lastupdate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->lastupdate());
    }

    // optional uint32 xceiverCount = 7 [default = 0];
    if (has_xceivercount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->xceivercount());
    }

    // optional string location = 8;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->location());
    }

  }
  if (_has_bits_[8 / 32] & 16128u) {
    // optional uint64 nonDfsUsed = 9;
    if (has_nondfsused()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->nondfsused());
    }

    // optional .DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
    if (has_adminstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->adminstate());
    }

    // optional uint64 cacheCapacity = 11 [default = 0];
    if (has_cachecapacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cachecapacity());
    }

    // optional uint64 cacheUsed = 12 [default = 0];
    if (has_cacheused()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cacheused());
    }

    // optional uint64 lastUpdateMonotonic = 13 [default = 0];
    if (has_lastupdatemonotonic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->lastupdatemonotonic());
    }

    // optional string upgradeDomain = 14;
    if (has_upgradedomain()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->upgradedomain());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DatanodeInfoProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DatanodeInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const DatanodeInfoProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DatanodeInfoProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DatanodeInfoProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DatanodeInfoProto)
    MergeFrom(*source);
  }
}

void DatanodeInfoProto::MergeFrom(const DatanodeInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DatanodeInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::DatanodeIDProto::MergeFrom(from.id());
    }
    if (from.has_capacity()) {
      set_capacity(from.capacity());
    }
    if (from.has_dfsused()) {
      set_dfsused(from.dfsused());
    }
    if (from.has_remaining()) {
      set_remaining(from.remaining());
    }
    if (from.has_blockpoolused()) {
      set_blockpoolused(from.blockpoolused());
    }
    if (from.has_lastupdate()) {
      set_lastupdate(from.lastupdate());
    }
    if (from.has_xceivercount()) {
      set_xceivercount(from.xceivercount());
    }
    if (from.has_location()) {
      set_has_location();
      location_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.location_);
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_nondfsused()) {
      set_nondfsused(from.nondfsused());
    }
    if (from.has_adminstate()) {
      set_adminstate(from.adminstate());
    }
    if (from.has_cachecapacity()) {
      set_cachecapacity(from.cachecapacity());
    }
    if (from.has_cacheused()) {
      set_cacheused(from.cacheused());
    }
    if (from.has_lastupdatemonotonic()) {
      set_lastupdatemonotonic(from.lastupdatemonotonic());
    }
    if (from.has_upgradedomain()) {
      set_has_upgradedomain();
      upgradedomain_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.upgradedomain_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DatanodeInfoProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DatanodeInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DatanodeInfoProto::CopyFrom(const DatanodeInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DatanodeInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatanodeInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_id()) {
    if (!this->id_->IsInitialized()) return false;
  }
  return true;
}

void DatanodeInfoProto::Swap(DatanodeInfoProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DatanodeInfoProto::InternalSwap(DatanodeInfoProto* other) {
  std::swap(id_, other->id_);
  std::swap(capacity_, other->capacity_);
  std::swap(dfsused_, other->dfsused_);
  std::swap(remaining_, other->remaining_);
  std::swap(blockpoolused_, other->blockpoolused_);
  std::swap(lastupdate_, other->lastupdate_);
  std::swap(xceivercount_, other->xceivercount_);
  location_.Swap(&other->location_);
  std::swap(nondfsused_, other->nondfsused_);
  std::swap(adminstate_, other->adminstate_);
  std::swap(cachecapacity_, other->cachecapacity_);
  std::swap(cacheused_, other->cacheused_);
  std::swap(lastupdatemonotonic_, other->lastupdatemonotonic_);
  upgradedomain_.Swap(&other->upgradedomain_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DatanodeInfoProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DatanodeInfoProto_descriptor_;
  metadata.reflection = DatanodeInfoProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DatanodeInfoProto

// required .DatanodeIDProto id = 1;
bool DatanodeInfoProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DatanodeInfoProto::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void DatanodeInfoProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void DatanodeInfoProto::clear_id() {
  if (id_ != NULL) id_->::DatanodeIDProto::Clear();
  clear_has_id();
}
const ::DatanodeIDProto& DatanodeInfoProto::id() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
::DatanodeIDProto* DatanodeInfoProto::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::DatanodeIDProto;
  }
  // @@protoc_insertion_point(field_mutable:DatanodeInfoProto.id)
  return id_;
}
::DatanodeIDProto* DatanodeInfoProto::release_id() {
  // @@protoc_insertion_point(field_release:DatanodeInfoProto.id)
  clear_has_id();
  ::DatanodeIDProto* temp = id_;
  id_ = NULL;
  return temp;
}
void DatanodeInfoProto::set_allocated_id(::DatanodeIDProto* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:DatanodeInfoProto.id)
}

// optional uint64 capacity = 2 [default = 0];
bool DatanodeInfoProto::has_capacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DatanodeInfoProto::set_has_capacity() {
  _has_bits_[0] |= 0x00000002u;
}
void DatanodeInfoProto::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000002u;
}
void DatanodeInfoProto::clear_capacity() {
  capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_capacity();
}
 ::google::protobuf::uint64 DatanodeInfoProto::capacity() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.capacity)
  return capacity_;
}
 void DatanodeInfoProto::set_capacity(::google::protobuf::uint64 value) {
  set_has_capacity();
  capacity_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.capacity)
}

// optional uint64 dfsUsed = 3 [default = 0];
bool DatanodeInfoProto::has_dfsused() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DatanodeInfoProto::set_has_dfsused() {
  _has_bits_[0] |= 0x00000004u;
}
void DatanodeInfoProto::clear_has_dfsused() {
  _has_bits_[0] &= ~0x00000004u;
}
void DatanodeInfoProto::clear_dfsused() {
  dfsused_ = GOOGLE_ULONGLONG(0);
  clear_has_dfsused();
}
 ::google::protobuf::uint64 DatanodeInfoProto::dfsused() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.dfsUsed)
  return dfsused_;
}
 void DatanodeInfoProto::set_dfsused(::google::protobuf::uint64 value) {
  set_has_dfsused();
  dfsused_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.dfsUsed)
}

// optional uint64 remaining = 4 [default = 0];
bool DatanodeInfoProto::has_remaining() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DatanodeInfoProto::set_has_remaining() {
  _has_bits_[0] |= 0x00000008u;
}
void DatanodeInfoProto::clear_has_remaining() {
  _has_bits_[0] &= ~0x00000008u;
}
void DatanodeInfoProto::clear_remaining() {
  remaining_ = GOOGLE_ULONGLONG(0);
  clear_has_remaining();
}
 ::google::protobuf::uint64 DatanodeInfoProto::remaining() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.remaining)
  return remaining_;
}
 void DatanodeInfoProto::set_remaining(::google::protobuf::uint64 value) {
  set_has_remaining();
  remaining_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.remaining)
}

// optional uint64 blockPoolUsed = 5 [default = 0];
bool DatanodeInfoProto::has_blockpoolused() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void DatanodeInfoProto::set_has_blockpoolused() {
  _has_bits_[0] |= 0x00000010u;
}
void DatanodeInfoProto::clear_has_blockpoolused() {
  _has_bits_[0] &= ~0x00000010u;
}
void DatanodeInfoProto::clear_blockpoolused() {
  blockpoolused_ = GOOGLE_ULONGLONG(0);
  clear_has_blockpoolused();
}
 ::google::protobuf::uint64 DatanodeInfoProto::blockpoolused() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.blockPoolUsed)
  return blockpoolused_;
}
 void DatanodeInfoProto::set_blockpoolused(::google::protobuf::uint64 value) {
  set_has_blockpoolused();
  blockpoolused_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.blockPoolUsed)
}

// optional uint64 lastUpdate = 6 [default = 0];
bool DatanodeInfoProto::has_lastupdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void DatanodeInfoProto::set_has_lastupdate() {
  _has_bits_[0] |= 0x00000020u;
}
void DatanodeInfoProto::clear_has_lastupdate() {
  _has_bits_[0] &= ~0x00000020u;
}
void DatanodeInfoProto::clear_lastupdate() {
  lastupdate_ = GOOGLE_ULONGLONG(0);
  clear_has_lastupdate();
}
 ::google::protobuf::uint64 DatanodeInfoProto::lastupdate() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.lastUpdate)
  return lastupdate_;
}
 void DatanodeInfoProto::set_lastupdate(::google::protobuf::uint64 value) {
  set_has_lastupdate();
  lastupdate_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.lastUpdate)
}

// optional uint32 xceiverCount = 7 [default = 0];
bool DatanodeInfoProto::has_xceivercount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void DatanodeInfoProto::set_has_xceivercount() {
  _has_bits_[0] |= 0x00000040u;
}
void DatanodeInfoProto::clear_has_xceivercount() {
  _has_bits_[0] &= ~0x00000040u;
}
void DatanodeInfoProto::clear_xceivercount() {
  xceivercount_ = 0u;
  clear_has_xceivercount();
}
 ::google::protobuf::uint32 DatanodeInfoProto::xceivercount() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.xceiverCount)
  return xceivercount_;
}
 void DatanodeInfoProto::set_xceivercount(::google::protobuf::uint32 value) {
  set_has_xceivercount();
  xceivercount_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.xceiverCount)
}

// optional string location = 8;
bool DatanodeInfoProto::has_location() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void DatanodeInfoProto::set_has_location() {
  _has_bits_[0] |= 0x00000080u;
}
void DatanodeInfoProto::clear_has_location() {
  _has_bits_[0] &= ~0x00000080u;
}
void DatanodeInfoProto::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_location();
}
 const ::std::string& DatanodeInfoProto::location() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.location)
  return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeInfoProto::set_location(const ::std::string& value) {
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.location)
}
 void DatanodeInfoProto::set_location(const char* value) {
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeInfoProto.location)
}
 void DatanodeInfoProto::set_location(const char* value, size_t size) {
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeInfoProto.location)
}
 ::std::string* DatanodeInfoProto::mutable_location() {
  set_has_location();
  // @@protoc_insertion_point(field_mutable:DatanodeInfoProto.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DatanodeInfoProto::release_location() {
  // @@protoc_insertion_point(field_release:DatanodeInfoProto.location)
  clear_has_location();
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeInfoProto::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    set_has_location();
  } else {
    clear_has_location();
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:DatanodeInfoProto.location)
}

// optional uint64 nonDfsUsed = 9;
bool DatanodeInfoProto::has_nondfsused() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void DatanodeInfoProto::set_has_nondfsused() {
  _has_bits_[0] |= 0x00000100u;
}
void DatanodeInfoProto::clear_has_nondfsused() {
  _has_bits_[0] &= ~0x00000100u;
}
void DatanodeInfoProto::clear_nondfsused() {
  nondfsused_ = GOOGLE_ULONGLONG(0);
  clear_has_nondfsused();
}
 ::google::protobuf::uint64 DatanodeInfoProto::nondfsused() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.nonDfsUsed)
  return nondfsused_;
}
 void DatanodeInfoProto::set_nondfsused(::google::protobuf::uint64 value) {
  set_has_nondfsused();
  nondfsused_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.nonDfsUsed)
}

// optional .DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
bool DatanodeInfoProto::has_adminstate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void DatanodeInfoProto::set_has_adminstate() {
  _has_bits_[0] |= 0x00000200u;
}
void DatanodeInfoProto::clear_has_adminstate() {
  _has_bits_[0] &= ~0x00000200u;
}
void DatanodeInfoProto::clear_adminstate() {
  adminstate_ = 0;
  clear_has_adminstate();
}
 ::DatanodeInfoProto_AdminState DatanodeInfoProto::adminstate() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.adminState)
  return static_cast< ::DatanodeInfoProto_AdminState >(adminstate_);
}
 void DatanodeInfoProto::set_adminstate(::DatanodeInfoProto_AdminState value) {
  assert(::DatanodeInfoProto_AdminState_IsValid(value));
  set_has_adminstate();
  adminstate_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.adminState)
}

// optional uint64 cacheCapacity = 11 [default = 0];
bool DatanodeInfoProto::has_cachecapacity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void DatanodeInfoProto::set_has_cachecapacity() {
  _has_bits_[0] |= 0x00000400u;
}
void DatanodeInfoProto::clear_has_cachecapacity() {
  _has_bits_[0] &= ~0x00000400u;
}
void DatanodeInfoProto::clear_cachecapacity() {
  cachecapacity_ = GOOGLE_ULONGLONG(0);
  clear_has_cachecapacity();
}
 ::google::protobuf::uint64 DatanodeInfoProto::cachecapacity() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.cacheCapacity)
  return cachecapacity_;
}
 void DatanodeInfoProto::set_cachecapacity(::google::protobuf::uint64 value) {
  set_has_cachecapacity();
  cachecapacity_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.cacheCapacity)
}

// optional uint64 cacheUsed = 12 [default = 0];
bool DatanodeInfoProto::has_cacheused() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void DatanodeInfoProto::set_has_cacheused() {
  _has_bits_[0] |= 0x00000800u;
}
void DatanodeInfoProto::clear_has_cacheused() {
  _has_bits_[0] &= ~0x00000800u;
}
void DatanodeInfoProto::clear_cacheused() {
  cacheused_ = GOOGLE_ULONGLONG(0);
  clear_has_cacheused();
}
 ::google::protobuf::uint64 DatanodeInfoProto::cacheused() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.cacheUsed)
  return cacheused_;
}
 void DatanodeInfoProto::set_cacheused(::google::protobuf::uint64 value) {
  set_has_cacheused();
  cacheused_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.cacheUsed)
}

// optional uint64 lastUpdateMonotonic = 13 [default = 0];
bool DatanodeInfoProto::has_lastupdatemonotonic() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void DatanodeInfoProto::set_has_lastupdatemonotonic() {
  _has_bits_[0] |= 0x00001000u;
}
void DatanodeInfoProto::clear_has_lastupdatemonotonic() {
  _has_bits_[0] &= ~0x00001000u;
}
void DatanodeInfoProto::clear_lastupdatemonotonic() {
  lastupdatemonotonic_ = GOOGLE_ULONGLONG(0);
  clear_has_lastupdatemonotonic();
}
 ::google::protobuf::uint64 DatanodeInfoProto::lastupdatemonotonic() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.lastUpdateMonotonic)
  return lastupdatemonotonic_;
}
 void DatanodeInfoProto::set_lastupdatemonotonic(::google::protobuf::uint64 value) {
  set_has_lastupdatemonotonic();
  lastupdatemonotonic_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.lastUpdateMonotonic)
}

// optional string upgradeDomain = 14;
bool DatanodeInfoProto::has_upgradedomain() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void DatanodeInfoProto::set_has_upgradedomain() {
  _has_bits_[0] |= 0x00002000u;
}
void DatanodeInfoProto::clear_has_upgradedomain() {
  _has_bits_[0] &= ~0x00002000u;
}
void DatanodeInfoProto::clear_upgradedomain() {
  upgradedomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_upgradedomain();
}
 const ::std::string& DatanodeInfoProto::upgradedomain() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.upgradeDomain)
  return upgradedomain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeInfoProto::set_upgradedomain(const ::std::string& value) {
  set_has_upgradedomain();
  upgradedomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.upgradeDomain)
}
 void DatanodeInfoProto::set_upgradedomain(const char* value) {
  set_has_upgradedomain();
  upgradedomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeInfoProto.upgradeDomain)
}
 void DatanodeInfoProto::set_upgradedomain(const char* value, size_t size) {
  set_has_upgradedomain();
  upgradedomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeInfoProto.upgradeDomain)
}
 ::std::string* DatanodeInfoProto::mutable_upgradedomain() {
  set_has_upgradedomain();
  // @@protoc_insertion_point(field_mutable:DatanodeInfoProto.upgradeDomain)
  return upgradedomain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DatanodeInfoProto::release_upgradedomain() {
  // @@protoc_insertion_point(field_release:DatanodeInfoProto.upgradeDomain)
  clear_has_upgradedomain();
  return upgradedomain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeInfoProto::set_allocated_upgradedomain(::std::string* upgradedomain) {
  if (upgradedomain != NULL) {
    set_has_upgradedomain();
  } else {
    clear_has_upgradedomain();
  }
  upgradedomain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), upgradedomain);
  // @@protoc_insertion_point(field_set_allocated:DatanodeInfoProto.upgradeDomain)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TokenProto::kIdentifierFieldNumber;
const int TokenProto::kPasswordFieldNumber;
const int TokenProto::kKindFieldNumber;
const int TokenProto::kServiceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TokenProto::TokenProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:TokenProto)
}

void TokenProto::InitAsDefaultInstance() {
}

TokenProto::TokenProto(const TokenProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:TokenProto)
}

void TokenProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  identifier_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  kind_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  service_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TokenProto::~TokenProto() {
  // @@protoc_insertion_point(destructor:TokenProto)
  SharedDtor();
}

void TokenProto::SharedDtor() {
  identifier_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  kind_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  service_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void TokenProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TokenProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TokenProto_descriptor_;
}

const TokenProto& TokenProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

TokenProto* TokenProto::default_instance_ = NULL;

TokenProto* TokenProto::New(::google::protobuf::Arena* arena) const {
  TokenProto* n = new TokenProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TokenProto::Clear() {
// @@protoc_insertion_point(message_clear_start:TokenProto)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_identifier()) {
      identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_password()) {
      password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_kind()) {
      kind_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_service()) {
      service_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TokenProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TokenProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes identifier = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_identifier()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }

      // required bytes password = 2;
      case 2: {
        if (tag == 18) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_password()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_kind;
        break;
      }

      // required string kind = 3;
      case 3: {
        if (tag == 26) {
         parse_kind:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_kind()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->kind().data(), this->kind().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TokenProto.kind");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_service;
        break;
      }

      // required string service = 4;
      case 4: {
        if (tag == 34) {
         parse_service:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->service().data(), this->service().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TokenProto.service");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TokenProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TokenProto)
  return false;
#undef DO_
}

void TokenProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TokenProto)
  // required bytes identifier = 1;
  if (has_identifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->identifier(), output);
  }

  // required bytes password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->password(), output);
  }

  // required string kind = 3;
  if (has_kind()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->kind().data(), this->kind().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TokenProto.kind");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->kind(), output);
  }

  // required string service = 4;
  if (has_service()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service().data(), this->service().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TokenProto.service");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->service(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TokenProto)
}

::google::protobuf::uint8* TokenProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TokenProto)
  // required bytes identifier = 1;
  if (has_identifier()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->identifier(), target);
  }

  // required bytes password = 2;
  if (has_password()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->password(), target);
  }

  // required string kind = 3;
  if (has_kind()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->kind().data(), this->kind().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TokenProto.kind");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->kind(), target);
  }

  // required string service = 4;
  if (has_service()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->service().data(), this->service().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TokenProto.service");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->service(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TokenProto)
  return target;
}

int TokenProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TokenProto)
  int total_size = 0;

  if (has_identifier()) {
    // required bytes identifier = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->identifier());
  }

  if (has_password()) {
    // required bytes password = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->password());
  }

  if (has_kind()) {
    // required string kind = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->kind());
  }

  if (has_service()) {
    // required string service = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->service());
  }

  return total_size;
}
int TokenProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:TokenProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bytes identifier = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->identifier());

    // required bytes password = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->password());

    // required string kind = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->kind());

    // required string service = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->service());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TokenProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TokenProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TokenProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TokenProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TokenProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TokenProto)
    MergeFrom(*source);
  }
}

void TokenProto::MergeFrom(const TokenProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TokenProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_identifier()) {
      set_has_identifier();
      identifier_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.identifier_);
    }
    if (from.has_password()) {
      set_has_password();
      password_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.password_);
    }
    if (from.has_kind()) {
      set_has_kind();
      kind_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.kind_);
    }
    if (from.has_service()) {
      set_has_service();
      service_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.service_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TokenProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TokenProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TokenProto::CopyFrom(const TokenProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TokenProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void TokenProto::Swap(TokenProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TokenProto::InternalSwap(TokenProto* other) {
  identifier_.Swap(&other->identifier_);
  password_.Swap(&other->password_);
  kind_.Swap(&other->kind_);
  service_.Swap(&other->service_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TokenProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TokenProto_descriptor_;
  metadata.reflection = TokenProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TokenProto

// required bytes identifier = 1;
bool TokenProto::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TokenProto::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
void TokenProto::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
void TokenProto::clear_identifier() {
  identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_identifier();
}
 const ::std::string& TokenProto::identifier() const {
  // @@protoc_insertion_point(field_get:TokenProto.identifier)
  return identifier_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TokenProto::set_identifier(const ::std::string& value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TokenProto.identifier)
}
 void TokenProto::set_identifier(const char* value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TokenProto.identifier)
}
 void TokenProto::set_identifier(const void* value, size_t size) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TokenProto.identifier)
}
 ::std::string* TokenProto::mutable_identifier() {
  set_has_identifier();
  // @@protoc_insertion_point(field_mutable:TokenProto.identifier)
  return identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TokenProto::release_identifier() {
  // @@protoc_insertion_point(field_release:TokenProto.identifier)
  clear_has_identifier();
  return identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TokenProto::set_allocated_identifier(::std::string* identifier) {
  if (identifier != NULL) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identifier);
  // @@protoc_insertion_point(field_set_allocated:TokenProto.identifier)
}

// required bytes password = 2;
bool TokenProto::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TokenProto::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
void TokenProto::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
void TokenProto::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
 const ::std::string& TokenProto::password() const {
  // @@protoc_insertion_point(field_get:TokenProto.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TokenProto::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TokenProto.password)
}
 void TokenProto::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TokenProto.password)
}
 void TokenProto::set_password(const void* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TokenProto.password)
}
 ::std::string* TokenProto::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:TokenProto.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TokenProto::release_password() {
  // @@protoc_insertion_point(field_release:TokenProto.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TokenProto::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:TokenProto.password)
}

// required string kind = 3;
bool TokenProto::has_kind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TokenProto::set_has_kind() {
  _has_bits_[0] |= 0x00000004u;
}
void TokenProto::clear_has_kind() {
  _has_bits_[0] &= ~0x00000004u;
}
void TokenProto::clear_kind() {
  kind_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_kind();
}
 const ::std::string& TokenProto::kind() const {
  // @@protoc_insertion_point(field_get:TokenProto.kind)
  return kind_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TokenProto::set_kind(const ::std::string& value) {
  set_has_kind();
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TokenProto.kind)
}
 void TokenProto::set_kind(const char* value) {
  set_has_kind();
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TokenProto.kind)
}
 void TokenProto::set_kind(const char* value, size_t size) {
  set_has_kind();
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TokenProto.kind)
}
 ::std::string* TokenProto::mutable_kind() {
  set_has_kind();
  // @@protoc_insertion_point(field_mutable:TokenProto.kind)
  return kind_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TokenProto::release_kind() {
  // @@protoc_insertion_point(field_release:TokenProto.kind)
  clear_has_kind();
  return kind_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TokenProto::set_allocated_kind(::std::string* kind) {
  if (kind != NULL) {
    set_has_kind();
  } else {
    clear_has_kind();
  }
  kind_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), kind);
  // @@protoc_insertion_point(field_set_allocated:TokenProto.kind)
}

// required string service = 4;
bool TokenProto::has_service() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TokenProto::set_has_service() {
  _has_bits_[0] |= 0x00000008u;
}
void TokenProto::clear_has_service() {
  _has_bits_[0] &= ~0x00000008u;
}
void TokenProto::clear_service() {
  service_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service();
}
 const ::std::string& TokenProto::service() const {
  // @@protoc_insertion_point(field_get:TokenProto.service)
  return service_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TokenProto::set_service(const ::std::string& value) {
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TokenProto.service)
}
 void TokenProto::set_service(const char* value) {
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TokenProto.service)
}
 void TokenProto::set_service(const char* value, size_t size) {
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TokenProto.service)
}
 ::std::string* TokenProto::mutable_service() {
  set_has_service();
  // @@protoc_insertion_point(field_mutable:TokenProto.service)
  return service_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TokenProto::release_service() {
  // @@protoc_insertion_point(field_release:TokenProto.service)
  clear_has_service();
  return service_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TokenProto::set_allocated_service(::std::string* service) {
  if (service != NULL) {
    set_has_service();
  } else {
    clear_has_service();
  }
  service_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service);
  // @@protoc_insertion_point(field_set_allocated:TokenProto.service)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FileEncryptionInfoProto::kSuiteFieldNumber;
const int FileEncryptionInfoProto::kCryptoProtocolVersionFieldNumber;
const int FileEncryptionInfoProto::kKeyFieldNumber;
const int FileEncryptionInfoProto::kIvFieldNumber;
const int FileEncryptionInfoProto::kKeyNameFieldNumber;
const int FileEncryptionInfoProto::kEzKeyVersionNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FileEncryptionInfoProto::FileEncryptionInfoProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FileEncryptionInfoProto)
}

void FileEncryptionInfoProto::InitAsDefaultInstance() {
}

FileEncryptionInfoProto::FileEncryptionInfoProto(const FileEncryptionInfoProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FileEncryptionInfoProto)
}

void FileEncryptionInfoProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  suite_ = 1;
  cryptoprotocolversion_ = 1;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  keyname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ezkeyversionname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileEncryptionInfoProto::~FileEncryptionInfoProto() {
  // @@protoc_insertion_point(destructor:FileEncryptionInfoProto)
  SharedDtor();
}

void FileEncryptionInfoProto::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  keyname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ezkeyversionname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void FileEncryptionInfoProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileEncryptionInfoProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileEncryptionInfoProto_descriptor_;
}

const FileEncryptionInfoProto& FileEncryptionInfoProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

FileEncryptionInfoProto* FileEncryptionInfoProto::default_instance_ = NULL;

FileEncryptionInfoProto* FileEncryptionInfoProto::New(::google::protobuf::Arena* arena) const {
  FileEncryptionInfoProto* n = new FileEncryptionInfoProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FileEncryptionInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:FileEncryptionInfoProto)
  if (_has_bits_[0 / 32] & 63u) {
    suite_ = 1;
    cryptoprotocolversion_ = 1;
    if (has_key()) {
      key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_iv()) {
      iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_keyname()) {
      keyname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_ezkeyversionname()) {
      ezkeyversionname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool FileEncryptionInfoProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:FileEncryptionInfoProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .CipherSuiteProto suite = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CipherSuiteProto_IsValid(value)) {
            set_suite(static_cast< ::CipherSuiteProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_cryptoProtocolVersion;
        break;
      }

      // required .CryptoProtocolVersionProto cryptoProtocolVersion = 2;
      case 2: {
        if (tag == 16) {
         parse_cryptoProtocolVersion:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CryptoProtocolVersionProto_IsValid(value)) {
            set_cryptoprotocolversion(static_cast< ::CryptoProtocolVersionProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_key;
        break;
      }

      // required bytes key = 3;
      case 3: {
        if (tag == 26) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_iv;
        break;
      }

      // required bytes iv = 4;
      case 4: {
        if (tag == 34) {
         parse_iv:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_keyName;
        break;
      }

      // required string keyName = 5;
      case 5: {
        if (tag == 42) {
         parse_keyName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_keyname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->keyname().data(), this->keyname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "FileEncryptionInfoProto.keyName");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_ezKeyVersionName;
        break;
      }

      // required string ezKeyVersionName = 6;
      case 6: {
        if (tag == 50) {
         parse_ezKeyVersionName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ezkeyversionname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ezkeyversionname().data(), this->ezkeyversionname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "FileEncryptionInfoProto.ezKeyVersionName");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:FileEncryptionInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FileEncryptionInfoProto)
  return false;
#undef DO_
}

void FileEncryptionInfoProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FileEncryptionInfoProto)
  // required .CipherSuiteProto suite = 1;
  if (has_suite()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->suite(), output);
  }

  // required .CryptoProtocolVersionProto cryptoProtocolVersion = 2;
  if (has_cryptoprotocolversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->cryptoprotocolversion(), output);
  }

  // required bytes key = 3;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->key(), output);
  }

  // required bytes iv = 4;
  if (has_iv()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->iv(), output);
  }

  // required string keyName = 5;
  if (has_keyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->keyname().data(), this->keyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "FileEncryptionInfoProto.keyName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->keyname(), output);
  }

  // required string ezKeyVersionName = 6;
  if (has_ezkeyversionname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ezkeyversionname().data(), this->ezkeyversionname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "FileEncryptionInfoProto.ezKeyVersionName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->ezkeyversionname(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:FileEncryptionInfoProto)
}

::google::protobuf::uint8* FileEncryptionInfoProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:FileEncryptionInfoProto)
  // required .CipherSuiteProto suite = 1;
  if (has_suite()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->suite(), target);
  }

  // required .CryptoProtocolVersionProto cryptoProtocolVersion = 2;
  if (has_cryptoprotocolversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->cryptoprotocolversion(), target);
  }

  // required bytes key = 3;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->key(), target);
  }

  // required bytes iv = 4;
  if (has_iv()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->iv(), target);
  }

  // required string keyName = 5;
  if (has_keyname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->keyname().data(), this->keyname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "FileEncryptionInfoProto.keyName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->keyname(), target);
  }

  // required string ezKeyVersionName = 6;
  if (has_ezkeyversionname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ezkeyversionname().data(), this->ezkeyversionname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "FileEncryptionInfoProto.ezKeyVersionName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->ezkeyversionname(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:FileEncryptionInfoProto)
  return target;
}

int FileEncryptionInfoProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:FileEncryptionInfoProto)
  int total_size = 0;

  if (has_suite()) {
    // required .CipherSuiteProto suite = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->suite());
  }

  if (has_cryptoprotocolversion()) {
    // required .CryptoProtocolVersionProto cryptoProtocolVersion = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->cryptoprotocolversion());
  }

  if (has_key()) {
    // required bytes key = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->key());
  }

  if (has_iv()) {
    // required bytes iv = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->iv());
  }

  if (has_keyname()) {
    // required string keyName = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->keyname());
  }

  if (has_ezkeyversionname()) {
    // required string ezKeyVersionName = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ezkeyversionname());
  }

  return total_size;
}
int FileEncryptionInfoProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:FileEncryptionInfoProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required .CipherSuiteProto suite = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->suite());

    // required .CryptoProtocolVersionProto cryptoProtocolVersion = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->cryptoprotocolversion());

    // required bytes key = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->key());

    // required bytes iv = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->iv());

    // required string keyName = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->keyname());

    // required string ezKeyVersionName = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ezkeyversionname());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileEncryptionInfoProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:FileEncryptionInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const FileEncryptionInfoProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const FileEncryptionInfoProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:FileEncryptionInfoProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:FileEncryptionInfoProto)
    MergeFrom(*source);
  }
}

void FileEncryptionInfoProto::MergeFrom(const FileEncryptionInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:FileEncryptionInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_suite()) {
      set_suite(from.suite());
    }
    if (from.has_cryptoprotocolversion()) {
      set_cryptoprotocolversion(from.cryptoprotocolversion());
    }
    if (from.has_key()) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (from.has_iv()) {
      set_has_iv();
      iv_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.iv_);
    }
    if (from.has_keyname()) {
      set_has_keyname();
      keyname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.keyname_);
    }
    if (from.has_ezkeyversionname()) {
      set_has_ezkeyversionname();
      ezkeyversionname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ezkeyversionname_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void FileEncryptionInfoProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:FileEncryptionInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileEncryptionInfoProto::CopyFrom(const FileEncryptionInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:FileEncryptionInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileEncryptionInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void FileEncryptionInfoProto::Swap(FileEncryptionInfoProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FileEncryptionInfoProto::InternalSwap(FileEncryptionInfoProto* other) {
  std::swap(suite_, other->suite_);
  std::swap(cryptoprotocolversion_, other->cryptoprotocolversion_);
  key_.Swap(&other->key_);
  iv_.Swap(&other->iv_);
  keyname_.Swap(&other->keyname_);
  ezkeyversionname_.Swap(&other->ezkeyversionname_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FileEncryptionInfoProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileEncryptionInfoProto_descriptor_;
  metadata.reflection = FileEncryptionInfoProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FileEncryptionInfoProto

// required .CipherSuiteProto suite = 1;
bool FileEncryptionInfoProto::has_suite() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FileEncryptionInfoProto::set_has_suite() {
  _has_bits_[0] |= 0x00000001u;
}
void FileEncryptionInfoProto::clear_has_suite() {
  _has_bits_[0] &= ~0x00000001u;
}
void FileEncryptionInfoProto::clear_suite() {
  suite_ = 1;
  clear_has_suite();
}
 ::CipherSuiteProto FileEncryptionInfoProto::suite() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.suite)
  return static_cast< ::CipherSuiteProto >(suite_);
}
 void FileEncryptionInfoProto::set_suite(::CipherSuiteProto value) {
  assert(::CipherSuiteProto_IsValid(value));
  set_has_suite();
  suite_ = value;
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.suite)
}

// required .CryptoProtocolVersionProto cryptoProtocolVersion = 2;
bool FileEncryptionInfoProto::has_cryptoprotocolversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FileEncryptionInfoProto::set_has_cryptoprotocolversion() {
  _has_bits_[0] |= 0x00000002u;
}
void FileEncryptionInfoProto::clear_has_cryptoprotocolversion() {
  _has_bits_[0] &= ~0x00000002u;
}
void FileEncryptionInfoProto::clear_cryptoprotocolversion() {
  cryptoprotocolversion_ = 1;
  clear_has_cryptoprotocolversion();
}
 ::CryptoProtocolVersionProto FileEncryptionInfoProto::cryptoprotocolversion() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.cryptoProtocolVersion)
  return static_cast< ::CryptoProtocolVersionProto >(cryptoprotocolversion_);
}
 void FileEncryptionInfoProto::set_cryptoprotocolversion(::CryptoProtocolVersionProto value) {
  assert(::CryptoProtocolVersionProto_IsValid(value));
  set_has_cryptoprotocolversion();
  cryptoprotocolversion_ = value;
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.cryptoProtocolVersion)
}

// required bytes key = 3;
bool FileEncryptionInfoProto::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void FileEncryptionInfoProto::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
void FileEncryptionInfoProto::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
void FileEncryptionInfoProto::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
 const ::std::string& FileEncryptionInfoProto::key() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileEncryptionInfoProto::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.key)
}
 void FileEncryptionInfoProto::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileEncryptionInfoProto.key)
}
 void FileEncryptionInfoProto::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileEncryptionInfoProto.key)
}
 ::std::string* FileEncryptionInfoProto::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:FileEncryptionInfoProto.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FileEncryptionInfoProto::release_key() {
  // @@protoc_insertion_point(field_release:FileEncryptionInfoProto.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileEncryptionInfoProto::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:FileEncryptionInfoProto.key)
}

// required bytes iv = 4;
bool FileEncryptionInfoProto::has_iv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void FileEncryptionInfoProto::set_has_iv() {
  _has_bits_[0] |= 0x00000008u;
}
void FileEncryptionInfoProto::clear_has_iv() {
  _has_bits_[0] &= ~0x00000008u;
}
void FileEncryptionInfoProto::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iv();
}
 const ::std::string& FileEncryptionInfoProto::iv() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.iv)
  return iv_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileEncryptionInfoProto::set_iv(const ::std::string& value) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.iv)
}
 void FileEncryptionInfoProto::set_iv(const char* value) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileEncryptionInfoProto.iv)
}
 void FileEncryptionInfoProto::set_iv(const void* value, size_t size) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileEncryptionInfoProto.iv)
}
 ::std::string* FileEncryptionInfoProto::mutable_iv() {
  set_has_iv();
  // @@protoc_insertion_point(field_mutable:FileEncryptionInfoProto.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FileEncryptionInfoProto::release_iv() {
  // @@protoc_insertion_point(field_release:FileEncryptionInfoProto.iv)
  clear_has_iv();
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileEncryptionInfoProto::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    set_has_iv();
  } else {
    clear_has_iv();
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:FileEncryptionInfoProto.iv)
}

// required string keyName = 5;
bool FileEncryptionInfoProto::has_keyname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void FileEncryptionInfoProto::set_has_keyname() {
  _has_bits_[0] |= 0x00000010u;
}
void FileEncryptionInfoProto::clear_has_keyname() {
  _has_bits_[0] &= ~0x00000010u;
}
void FileEncryptionInfoProto::clear_keyname() {
  keyname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keyname();
}
 const ::std::string& FileEncryptionInfoProto::keyname() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.keyName)
  return keyname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileEncryptionInfoProto::set_keyname(const ::std::string& value) {
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.keyName)
}
 void FileEncryptionInfoProto::set_keyname(const char* value) {
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileEncryptionInfoProto.keyName)
}
 void FileEncryptionInfoProto::set_keyname(const char* value, size_t size) {
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileEncryptionInfoProto.keyName)
}
 ::std::string* FileEncryptionInfoProto::mutable_keyname() {
  set_has_keyname();
  // @@protoc_insertion_point(field_mutable:FileEncryptionInfoProto.keyName)
  return keyname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FileEncryptionInfoProto::release_keyname() {
  // @@protoc_insertion_point(field_release:FileEncryptionInfoProto.keyName)
  clear_has_keyname();
  return keyname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileEncryptionInfoProto::set_allocated_keyname(::std::string* keyname) {
  if (keyname != NULL) {
    set_has_keyname();
  } else {
    clear_has_keyname();
  }
  keyname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keyname);
  // @@protoc_insertion_point(field_set_allocated:FileEncryptionInfoProto.keyName)
}

// required string ezKeyVersionName = 6;
bool FileEncryptionInfoProto::has_ezkeyversionname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void FileEncryptionInfoProto::set_has_ezkeyversionname() {
  _has_bits_[0] |= 0x00000020u;
}
void FileEncryptionInfoProto::clear_has_ezkeyversionname() {
  _has_bits_[0] &= ~0x00000020u;
}
void FileEncryptionInfoProto::clear_ezkeyversionname() {
  ezkeyversionname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ezkeyversionname();
}
 const ::std::string& FileEncryptionInfoProto::ezkeyversionname() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.ezKeyVersionName)
  return ezkeyversionname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileEncryptionInfoProto::set_ezkeyversionname(const ::std::string& value) {
  set_has_ezkeyversionname();
  ezkeyversionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.ezKeyVersionName)
}
 void FileEncryptionInfoProto::set_ezkeyversionname(const char* value) {
  set_has_ezkeyversionname();
  ezkeyversionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileEncryptionInfoProto.ezKeyVersionName)
}
 void FileEncryptionInfoProto::set_ezkeyversionname(const char* value, size_t size) {
  set_has_ezkeyversionname();
  ezkeyversionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileEncryptionInfoProto.ezKeyVersionName)
}
 ::std::string* FileEncryptionInfoProto::mutable_ezkeyversionname() {
  set_has_ezkeyversionname();
  // @@protoc_insertion_point(field_mutable:FileEncryptionInfoProto.ezKeyVersionName)
  return ezkeyversionname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FileEncryptionInfoProto::release_ezkeyversionname() {
  // @@protoc_insertion_point(field_release:FileEncryptionInfoProto.ezKeyVersionName)
  clear_has_ezkeyversionname();
  return ezkeyversionname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileEncryptionInfoProto::set_allocated_ezkeyversionname(::std::string* ezkeyversionname) {
  if (ezkeyversionname != NULL) {
    set_has_ezkeyversionname();
  } else {
    clear_has_ezkeyversionname();
  }
  ezkeyversionname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ezkeyversionname);
  // @@protoc_insertion_point(field_set_allocated:FileEncryptionInfoProto.ezKeyVersionName)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LocatedBlockProto::kBFieldNumber;
const int LocatedBlockProto::kOffsetFieldNumber;
const int LocatedBlockProto::kLocsFieldNumber;
const int LocatedBlockProto::kCorruptFieldNumber;
const int LocatedBlockProto::kBlockTokenFieldNumber;
const int LocatedBlockProto::kIsCachedFieldNumber;
const int LocatedBlockProto::kStorageTypesFieldNumber;
const int LocatedBlockProto::kStorageIDsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LocatedBlockProto::LocatedBlockProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:LocatedBlockProto)
}

void LocatedBlockProto::InitAsDefaultInstance() {
  b_ = const_cast< ::ExtendedBlockProto*>(&::ExtendedBlockProto::default_instance());
  blocktoken_ = const_cast< ::TokenProto*>(&::TokenProto::default_instance());
}

LocatedBlockProto::LocatedBlockProto(const LocatedBlockProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:LocatedBlockProto)
}

void LocatedBlockProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  b_ = NULL;
  offset_ = GOOGLE_ULONGLONG(0);
  corrupt_ = false;
  blocktoken_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LocatedBlockProto::~LocatedBlockProto() {
  // @@protoc_insertion_point(destructor:LocatedBlockProto)
  SharedDtor();
}

void LocatedBlockProto::SharedDtor() {
  if (this != default_instance_) {
    delete b_;
    delete blocktoken_;
  }
}

void LocatedBlockProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LocatedBlockProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LocatedBlockProto_descriptor_;
}

const LocatedBlockProto& LocatedBlockProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

LocatedBlockProto* LocatedBlockProto::default_instance_ = NULL;

LocatedBlockProto* LocatedBlockProto::New(::google::protobuf::Arena* arena) const {
  LocatedBlockProto* n = new LocatedBlockProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LocatedBlockProto::Clear() {
// @@protoc_insertion_point(message_clear_start:LocatedBlockProto)
  if (_has_bits_[0 / 32] & 27u) {
    if (has_b()) {
      if (b_ != NULL) b_->::ExtendedBlockProto::Clear();
    }
    offset_ = GOOGLE_ULONGLONG(0);
    corrupt_ = false;
    if (has_blocktoken()) {
      if (blocktoken_ != NULL) blocktoken_->::TokenProto::Clear();
    }
  }
  locs_.Clear();
  iscached_.Clear();
  storagetypes_.Clear();
  storageids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LocatedBlockProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:LocatedBlockProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ExtendedBlockProto b = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_b()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_offset;
        break;
      }

      // required uint64 offset = 2;
      case 2: {
        if (tag == 16) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_locs;
        break;
      }

      // repeated .DatanodeInfoProto locs = 3;
      case 3: {
        if (tag == 26) {
         parse_locs:
          DO_(input->IncrementRecursionDepth());
         parse_loop_locs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_locs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_locs;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(32)) goto parse_corrupt;
        break;
      }

      // required bool corrupt = 4;
      case 4: {
        if (tag == 32) {
         parse_corrupt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &corrupt_)));
          set_has_corrupt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_blockToken;
        break;
      }

      // required .TokenProto blockToken = 5;
      case 5: {
        if (tag == 42) {
         parse_blockToken:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_blocktoken()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_isCached;
        break;
      }

      // repeated bool isCached = 6 [packed = true];
      case 6: {
        if (tag == 50) {
         parse_isCached:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_iscached())));
        } else if (tag == 48) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 50, input, this->mutable_iscached())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_storageTypes;
        break;
      }

      // repeated .StorageTypeProto storageTypes = 7;
      case 7: {
        if (tag == 56) {
         parse_storageTypes:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::StorageTypeProto_IsValid(value)) {
            add_storagetypes(static_cast< ::StorageTypeProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else if (tag == 58) {
          DO_((::google::protobuf::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 7,
                 ::StorageTypeProto_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_storagetypes())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_storageTypes;
        if (input->ExpectTag(66)) goto parse_storageIDs;
        break;
      }

      // repeated string storageIDs = 8;
      case 8: {
        if (tag == 66) {
         parse_storageIDs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_storageids()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->storageids(this->storageids_size() - 1).data(),
            this->storageids(this->storageids_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "LocatedBlockProto.storageIDs");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_storageIDs;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:LocatedBlockProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:LocatedBlockProto)
  return false;
#undef DO_
}

void LocatedBlockProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:LocatedBlockProto)
  // required .ExtendedBlockProto b = 1;
  if (has_b()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->b_, output);
  }

  // required uint64 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->offset(), output);
  }

  // repeated .DatanodeInfoProto locs = 3;
  for (unsigned int i = 0, n = this->locs_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->locs(i), output);
  }

  // required bool corrupt = 4;
  if (has_corrupt()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->corrupt(), output);
  }

  // required .TokenProto blockToken = 5;
  if (has_blocktoken()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->blocktoken_, output);
  }

  // repeated bool isCached = 6 [packed = true];
  if (this->iscached_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(6, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_iscached_cached_byte_size_);
  }
  for (int i = 0; i < this->iscached_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBoolNoTag(
      this->iscached(i), output);
  }

  // repeated .StorageTypeProto storageTypes = 7;
  for (int i = 0; i < this->storagetypes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->storagetypes(i), output);
  }

  // repeated string storageIDs = 8;
  for (int i = 0; i < this->storageids_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->storageids(i).data(), this->storageids(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "LocatedBlockProto.storageIDs");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->storageids(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:LocatedBlockProto)
}

::google::protobuf::uint8* LocatedBlockProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:LocatedBlockProto)
  // required .ExtendedBlockProto b = 1;
  if (has_b()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->b_, false, target);
  }

  // required uint64 offset = 2;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->offset(), target);
  }

  // repeated .DatanodeInfoProto locs = 3;
  for (unsigned int i = 0, n = this->locs_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->locs(i), false, target);
  }

  // required bool corrupt = 4;
  if (has_corrupt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->corrupt(), target);
  }

  // required .TokenProto blockToken = 5;
  if (has_blocktoken()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->blocktoken_, false, target);
  }

  // repeated bool isCached = 6 [packed = true];
  if (this->iscached_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      6,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _iscached_cached_byte_size_, target);
  }
  for (int i = 0; i < this->iscached_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolNoTagToArray(this->iscached(i), target);
  }

  // repeated .StorageTypeProto storageTypes = 7;
  for (int i = 0; i < this->storagetypes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->storagetypes(i), target);
  }

  // repeated string storageIDs = 8;
  for (int i = 0; i < this->storageids_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->storageids(i).data(), this->storageids(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "LocatedBlockProto.storageIDs");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(8, this->storageids(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LocatedBlockProto)
  return target;
}

int LocatedBlockProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:LocatedBlockProto)
  int total_size = 0;

  if (has_b()) {
    // required .ExtendedBlockProto b = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->b_);
  }

  if (has_offset()) {
    // required uint64 offset = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->offset());
  }

  if (has_corrupt()) {
    // required bool corrupt = 4;
    total_size += 1 + 1;
  }

  if (has_blocktoken()) {
    // required .TokenProto blockToken = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->blocktoken_);
  }

  return total_size;
}
int LocatedBlockProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:LocatedBlockProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000001b) ^ 0x0000001b) == 0) {  // All required fields are present.
    // required .ExtendedBlockProto b = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->b_);

    // required uint64 offset = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->offset());

    // required bool corrupt = 4;
    total_size += 1 + 1;

    // required .TokenProto blockToken = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->blocktoken_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated .DatanodeInfoProto locs = 3;
  total_size += 1 * this->locs_size();
  for (int i = 0; i < this->locs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->locs(i));
  }

  // repeated bool isCached = 6 [packed = true];
  {
    int data_size = 0;
    data_size = 1 * this->iscached_size();
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _iscached_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated .StorageTypeProto storageTypes = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->storagetypes_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->storagetypes(i));
    }
    total_size += 1 * this->storagetypes_size() + data_size;
  }

  // repeated string storageIDs = 8;
  total_size += 1 * this->storageids_size();
  for (int i = 0; i < this->storageids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->storageids(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LocatedBlockProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:LocatedBlockProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LocatedBlockProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LocatedBlockProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:LocatedBlockProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:LocatedBlockProto)
    MergeFrom(*source);
  }
}

void LocatedBlockProto::MergeFrom(const LocatedBlockProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:LocatedBlockProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  locs_.MergeFrom(from.locs_);
  iscached_.MergeFrom(from.iscached_);
  storagetypes_.MergeFrom(from.storagetypes_);
  storageids_.MergeFrom(from.storageids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_b()) {
      mutable_b()->::ExtendedBlockProto::MergeFrom(from.b());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_corrupt()) {
      set_corrupt(from.corrupt());
    }
    if (from.has_blocktoken()) {
      mutable_blocktoken()->::TokenProto::MergeFrom(from.blocktoken());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LocatedBlockProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:LocatedBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LocatedBlockProto::CopyFrom(const LocatedBlockProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LocatedBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocatedBlockProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001b) != 0x0000001b) return false;

  if (has_b()) {
    if (!this->b_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->locs())) return false;
  if (has_blocktoken()) {
    if (!this->blocktoken_->IsInitialized()) return false;
  }
  return true;
}

void LocatedBlockProto::Swap(LocatedBlockProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LocatedBlockProto::InternalSwap(LocatedBlockProto* other) {
  std::swap(b_, other->b_);
  std::swap(offset_, other->offset_);
  locs_.UnsafeArenaSwap(&other->locs_);
  std::swap(corrupt_, other->corrupt_);
  std::swap(blocktoken_, other->blocktoken_);
  iscached_.UnsafeArenaSwap(&other->iscached_);
  storagetypes_.UnsafeArenaSwap(&other->storagetypes_);
  storageids_.UnsafeArenaSwap(&other->storageids_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LocatedBlockProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LocatedBlockProto_descriptor_;
  metadata.reflection = LocatedBlockProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LocatedBlockProto

// required .ExtendedBlockProto b = 1;
bool LocatedBlockProto::has_b() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LocatedBlockProto::set_has_b() {
  _has_bits_[0] |= 0x00000001u;
}
void LocatedBlockProto::clear_has_b() {
  _has_bits_[0] &= ~0x00000001u;
}
void LocatedBlockProto::clear_b() {
  if (b_ != NULL) b_->::ExtendedBlockProto::Clear();
  clear_has_b();
}
const ::ExtendedBlockProto& LocatedBlockProto::b() const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.b)
  return b_ != NULL ? *b_ : *default_instance_->b_;
}
::ExtendedBlockProto* LocatedBlockProto::mutable_b() {
  set_has_b();
  if (b_ == NULL) {
    b_ = new ::ExtendedBlockProto;
  }
  // @@protoc_insertion_point(field_mutable:LocatedBlockProto.b)
  return b_;
}
::ExtendedBlockProto* LocatedBlockProto::release_b() {
  // @@protoc_insertion_point(field_release:LocatedBlockProto.b)
  clear_has_b();
  ::ExtendedBlockProto* temp = b_;
  b_ = NULL;
  return temp;
}
void LocatedBlockProto::set_allocated_b(::ExtendedBlockProto* b) {
  delete b_;
  b_ = b;
  if (b) {
    set_has_b();
  } else {
    clear_has_b();
  }
  // @@protoc_insertion_point(field_set_allocated:LocatedBlockProto.b)
}

// required uint64 offset = 2;
bool LocatedBlockProto::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LocatedBlockProto::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
void LocatedBlockProto::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
void LocatedBlockProto::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
 ::google::protobuf::uint64 LocatedBlockProto::offset() const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.offset)
  return offset_;
}
 void LocatedBlockProto::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:LocatedBlockProto.offset)
}

// repeated .DatanodeInfoProto locs = 3;
int LocatedBlockProto::locs_size() const {
  return locs_.size();
}
void LocatedBlockProto::clear_locs() {
  locs_.Clear();
}
const ::DatanodeInfoProto& LocatedBlockProto::locs(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.locs)
  return locs_.Get(index);
}
::DatanodeInfoProto* LocatedBlockProto::mutable_locs(int index) {
  // @@protoc_insertion_point(field_mutable:LocatedBlockProto.locs)
  return locs_.Mutable(index);
}
::DatanodeInfoProto* LocatedBlockProto::add_locs() {
  // @@protoc_insertion_point(field_add:LocatedBlockProto.locs)
  return locs_.Add();
}
::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >*
LocatedBlockProto::mutable_locs() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlockProto.locs)
  return &locs_;
}
const ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >&
LocatedBlockProto::locs() const {
  // @@protoc_insertion_point(field_list:LocatedBlockProto.locs)
  return locs_;
}

// required bool corrupt = 4;
bool LocatedBlockProto::has_corrupt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void LocatedBlockProto::set_has_corrupt() {
  _has_bits_[0] |= 0x00000008u;
}
void LocatedBlockProto::clear_has_corrupt() {
  _has_bits_[0] &= ~0x00000008u;
}
void LocatedBlockProto::clear_corrupt() {
  corrupt_ = false;
  clear_has_corrupt();
}
 bool LocatedBlockProto::corrupt() const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.corrupt)
  return corrupt_;
}
 void LocatedBlockProto::set_corrupt(bool value) {
  set_has_corrupt();
  corrupt_ = value;
  // @@protoc_insertion_point(field_set:LocatedBlockProto.corrupt)
}

// required .TokenProto blockToken = 5;
bool LocatedBlockProto::has_blocktoken() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void LocatedBlockProto::set_has_blocktoken() {
  _has_bits_[0] |= 0x00000010u;
}
void LocatedBlockProto::clear_has_blocktoken() {
  _has_bits_[0] &= ~0x00000010u;
}
void LocatedBlockProto::clear_blocktoken() {
  if (blocktoken_ != NULL) blocktoken_->::TokenProto::Clear();
  clear_has_blocktoken();
}
const ::TokenProto& LocatedBlockProto::blocktoken() const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.blockToken)
  return blocktoken_ != NULL ? *blocktoken_ : *default_instance_->blocktoken_;
}
::TokenProto* LocatedBlockProto::mutable_blocktoken() {
  set_has_blocktoken();
  if (blocktoken_ == NULL) {
    blocktoken_ = new ::TokenProto;
  }
  // @@protoc_insertion_point(field_mutable:LocatedBlockProto.blockToken)
  return blocktoken_;
}
::TokenProto* LocatedBlockProto::release_blocktoken() {
  // @@protoc_insertion_point(field_release:LocatedBlockProto.blockToken)
  clear_has_blocktoken();
  ::TokenProto* temp = blocktoken_;
  blocktoken_ = NULL;
  return temp;
}
void LocatedBlockProto::set_allocated_blocktoken(::TokenProto* blocktoken) {
  delete blocktoken_;
  blocktoken_ = blocktoken;
  if (blocktoken) {
    set_has_blocktoken();
  } else {
    clear_has_blocktoken();
  }
  // @@protoc_insertion_point(field_set_allocated:LocatedBlockProto.blockToken)
}

// repeated bool isCached = 6 [packed = true];
int LocatedBlockProto::iscached_size() const {
  return iscached_.size();
}
void LocatedBlockProto::clear_iscached() {
  iscached_.Clear();
}
 bool LocatedBlockProto::iscached(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.isCached)
  return iscached_.Get(index);
}
 void LocatedBlockProto::set_iscached(int index, bool value) {
  iscached_.Set(index, value);
  // @@protoc_insertion_point(field_set:LocatedBlockProto.isCached)
}
 void LocatedBlockProto::add_iscached(bool value) {
  iscached_.Add(value);
  // @@protoc_insertion_point(field_add:LocatedBlockProto.isCached)
}
 const ::google::protobuf::RepeatedField< bool >&
LocatedBlockProto::iscached() const {
  // @@protoc_insertion_point(field_list:LocatedBlockProto.isCached)
  return iscached_;
}
 ::google::protobuf::RepeatedField< bool >*
LocatedBlockProto::mutable_iscached() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlockProto.isCached)
  return &iscached_;
}

// repeated .StorageTypeProto storageTypes = 7;
int LocatedBlockProto::storagetypes_size() const {
  return storagetypes_.size();
}
void LocatedBlockProto::clear_storagetypes() {
  storagetypes_.Clear();
}
 ::StorageTypeProto LocatedBlockProto::storagetypes(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.storageTypes)
  return static_cast< ::StorageTypeProto >(storagetypes_.Get(index));
}
 void LocatedBlockProto::set_storagetypes(int index, ::StorageTypeProto value) {
  assert(::StorageTypeProto_IsValid(value));
  storagetypes_.Set(index, value);
  // @@protoc_insertion_point(field_set:LocatedBlockProto.storageTypes)
}
 void LocatedBlockProto::add_storagetypes(::StorageTypeProto value) {
  assert(::StorageTypeProto_IsValid(value));
  storagetypes_.Add(value);
  // @@protoc_insertion_point(field_add:LocatedBlockProto.storageTypes)
}
 const ::google::protobuf::RepeatedField<int>&
LocatedBlockProto::storagetypes() const {
  // @@protoc_insertion_point(field_list:LocatedBlockProto.storageTypes)
  return storagetypes_;
}
 ::google::protobuf::RepeatedField<int>*
LocatedBlockProto::mutable_storagetypes() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlockProto.storageTypes)
  return &storagetypes_;
}

// repeated string storageIDs = 8;
int LocatedBlockProto::storageids_size() const {
  return storageids_.size();
}
void LocatedBlockProto::clear_storageids() {
  storageids_.Clear();
}
 const ::std::string& LocatedBlockProto::storageids(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.storageIDs)
  return storageids_.Get(index);
}
 ::std::string* LocatedBlockProto::mutable_storageids(int index) {
  // @@protoc_insertion_point(field_mutable:LocatedBlockProto.storageIDs)
  return storageids_.Mutable(index);
}
 void LocatedBlockProto::set_storageids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:LocatedBlockProto.storageIDs)
  storageids_.Mutable(index)->assign(value);
}
 void LocatedBlockProto::set_storageids(int index, const char* value) {
  storageids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:LocatedBlockProto.storageIDs)
}
 void LocatedBlockProto::set_storageids(int index, const char* value, size_t size) {
  storageids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LocatedBlockProto.storageIDs)
}
 ::std::string* LocatedBlockProto::add_storageids() {
  // @@protoc_insertion_point(field_add_mutable:LocatedBlockProto.storageIDs)
  return storageids_.Add();
}
 void LocatedBlockProto::add_storageids(const ::std::string& value) {
  storageids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:LocatedBlockProto.storageIDs)
}
 void LocatedBlockProto::add_storageids(const char* value) {
  storageids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:LocatedBlockProto.storageIDs)
}
 void LocatedBlockProto::add_storageids(const char* value, size_t size) {
  storageids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:LocatedBlockProto.storageIDs)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
LocatedBlockProto::storageids() const {
  // @@protoc_insertion_point(field_list:LocatedBlockProto.storageIDs)
  return storageids_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
LocatedBlockProto::mutable_storageids() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlockProto.storageIDs)
  return &storageids_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LocatedBlocksProto::kFileLengthFieldNumber;
const int LocatedBlocksProto::kBlocksFieldNumber;
const int LocatedBlocksProto::kUnderConstructionFieldNumber;
const int LocatedBlocksProto::kLastBlockFieldNumber;
const int LocatedBlocksProto::kIsLastBlockCompleteFieldNumber;
const int LocatedBlocksProto::kFileEncryptionInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LocatedBlocksProto::LocatedBlocksProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:LocatedBlocksProto)
}

void LocatedBlocksProto::InitAsDefaultInstance() {
  lastblock_ = const_cast< ::LocatedBlockProto*>(&::LocatedBlockProto::default_instance());
  fileencryptioninfo_ = const_cast< ::FileEncryptionInfoProto*>(&::FileEncryptionInfoProto::default_instance());
}

LocatedBlocksProto::LocatedBlocksProto(const LocatedBlocksProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:LocatedBlocksProto)
}

void LocatedBlocksProto::SharedCtor() {
  _cached_size_ = 0;
  filelength_ = GOOGLE_ULONGLONG(0);
  underconstruction_ = false;
  lastblock_ = NULL;
  islastblockcomplete_ = false;
  fileencryptioninfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LocatedBlocksProto::~LocatedBlocksProto() {
  // @@protoc_insertion_point(destructor:LocatedBlocksProto)
  SharedDtor();
}

void LocatedBlocksProto::SharedDtor() {
  if (this != default_instance_) {
    delete lastblock_;
    delete fileencryptioninfo_;
  }
}

void LocatedBlocksProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LocatedBlocksProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LocatedBlocksProto_descriptor_;
}

const LocatedBlocksProto& LocatedBlocksProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

LocatedBlocksProto* LocatedBlocksProto::default_instance_ = NULL;

LocatedBlocksProto* LocatedBlocksProto::New(::google::protobuf::Arena* arena) const {
  LocatedBlocksProto* n = new LocatedBlocksProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LocatedBlocksProto::Clear() {
// @@protoc_insertion_point(message_clear_start:LocatedBlocksProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(LocatedBlocksProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<LocatedBlocksProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 61u) {
    ZR_(underconstruction_, islastblockcomplete_);
    filelength_ = GOOGLE_ULONGLONG(0);
    if (has_lastblock()) {
      if (lastblock_ != NULL) lastblock_->::LocatedBlockProto::Clear();
    }
    if (has_fileencryptioninfo()) {
      if (fileencryptioninfo_ != NULL) fileencryptioninfo_->::FileEncryptionInfoProto::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  blocks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LocatedBlocksProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:LocatedBlocksProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 fileLength = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &filelength_)));
          set_has_filelength();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_blocks;
        break;
      }

      // repeated .LocatedBlockProto blocks = 2;
      case 2: {
        if (tag == 18) {
         parse_blocks:
          DO_(input->IncrementRecursionDepth());
         parse_loop_blocks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_blocks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_blocks;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(24)) goto parse_underConstruction;
        break;
      }

      // required bool underConstruction = 3;
      case 3: {
        if (tag == 24) {
         parse_underConstruction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &underconstruction_)));
          set_has_underconstruction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_lastBlock;
        break;
      }

      // optional .LocatedBlockProto lastBlock = 4;
      case 4: {
        if (tag == 34) {
         parse_lastBlock:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lastblock()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_isLastBlockComplete;
        break;
      }

      // required bool isLastBlockComplete = 5;
      case 5: {
        if (tag == 40) {
         parse_isLastBlockComplete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &islastblockcomplete_)));
          set_has_islastblockcomplete();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_fileEncryptionInfo;
        break;
      }

      // optional .FileEncryptionInfoProto fileEncryptionInfo = 6;
      case 6: {
        if (tag == 50) {
         parse_fileEncryptionInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fileencryptioninfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:LocatedBlocksProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:LocatedBlocksProto)
  return false;
#undef DO_
}

void LocatedBlocksProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:LocatedBlocksProto)
  // required uint64 fileLength = 1;
  if (has_filelength()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->filelength(), output);
  }

  // repeated .LocatedBlockProto blocks = 2;
  for (unsigned int i = 0, n = this->blocks_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->blocks(i), output);
  }

  // required bool underConstruction = 3;
  if (has_underconstruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->underconstruction(), output);
  }

  // optional .LocatedBlockProto lastBlock = 4;
  if (has_lastblock()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->lastblock_, output);
  }

  // required bool isLastBlockComplete = 5;
  if (has_islastblockcomplete()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->islastblockcomplete(), output);
  }

  // optional .FileEncryptionInfoProto fileEncryptionInfo = 6;
  if (has_fileencryptioninfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->fileencryptioninfo_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:LocatedBlocksProto)
}

::google::protobuf::uint8* LocatedBlocksProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:LocatedBlocksProto)
  // required uint64 fileLength = 1;
  if (has_filelength()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->filelength(), target);
  }

  // repeated .LocatedBlockProto blocks = 2;
  for (unsigned int i = 0, n = this->blocks_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->blocks(i), false, target);
  }

  // required bool underConstruction = 3;
  if (has_underconstruction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->underconstruction(), target);
  }

  // optional .LocatedBlockProto lastBlock = 4;
  if (has_lastblock()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->lastblock_, false, target);
  }

  // required bool isLastBlockComplete = 5;
  if (has_islastblockcomplete()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->islastblockcomplete(), target);
  }

  // optional .FileEncryptionInfoProto fileEncryptionInfo = 6;
  if (has_fileencryptioninfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->fileencryptioninfo_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LocatedBlocksProto)
  return target;
}

int LocatedBlocksProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:LocatedBlocksProto)
  int total_size = 0;

  if (has_filelength()) {
    // required uint64 fileLength = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->filelength());
  }

  if (has_underconstruction()) {
    // required bool underConstruction = 3;
    total_size += 1 + 1;
  }

  if (has_islastblockcomplete()) {
    // required bool isLastBlockComplete = 5;
    total_size += 1 + 1;
  }

  return total_size;
}
int LocatedBlocksProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:LocatedBlocksProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000015) ^ 0x00000015) == 0) {  // All required fields are present.
    // required uint64 fileLength = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->filelength());

    // required bool underConstruction = 3;
    total_size += 1 + 1;

    // required bool isLastBlockComplete = 5;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[3 / 32] & 40u) {
    // optional .LocatedBlockProto lastBlock = 4;
    if (has_lastblock()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->lastblock_);
    }

    // optional .FileEncryptionInfoProto fileEncryptionInfo = 6;
    if (has_fileencryptioninfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->fileencryptioninfo_);
    }

  }
  // repeated .LocatedBlockProto blocks = 2;
  total_size += 1 * this->blocks_size();
  for (int i = 0; i < this->blocks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->blocks(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LocatedBlocksProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:LocatedBlocksProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LocatedBlocksProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LocatedBlocksProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:LocatedBlocksProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:LocatedBlocksProto)
    MergeFrom(*source);
  }
}

void LocatedBlocksProto::MergeFrom(const LocatedBlocksProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:LocatedBlocksProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  blocks_.MergeFrom(from.blocks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filelength()) {
      set_filelength(from.filelength());
    }
    if (from.has_underconstruction()) {
      set_underconstruction(from.underconstruction());
    }
    if (from.has_lastblock()) {
      mutable_lastblock()->::LocatedBlockProto::MergeFrom(from.lastblock());
    }
    if (from.has_islastblockcomplete()) {
      set_islastblockcomplete(from.islastblockcomplete());
    }
    if (from.has_fileencryptioninfo()) {
      mutable_fileencryptioninfo()->::FileEncryptionInfoProto::MergeFrom(from.fileencryptioninfo());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LocatedBlocksProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:LocatedBlocksProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LocatedBlocksProto::CopyFrom(const LocatedBlocksProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LocatedBlocksProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocatedBlocksProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000015) != 0x00000015) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->blocks())) return false;
  if (has_lastblock()) {
    if (!this->lastblock_->IsInitialized()) return false;
  }
  if (has_fileencryptioninfo()) {
    if (!this->fileencryptioninfo_->IsInitialized()) return false;
  }
  return true;
}

void LocatedBlocksProto::Swap(LocatedBlocksProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LocatedBlocksProto::InternalSwap(LocatedBlocksProto* other) {
  std::swap(filelength_, other->filelength_);
  blocks_.UnsafeArenaSwap(&other->blocks_);
  std::swap(underconstruction_, other->underconstruction_);
  std::swap(lastblock_, other->lastblock_);
  std::swap(islastblockcomplete_, other->islastblockcomplete_);
  std::swap(fileencryptioninfo_, other->fileencryptioninfo_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LocatedBlocksProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LocatedBlocksProto_descriptor_;
  metadata.reflection = LocatedBlocksProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LocatedBlocksProto

// required uint64 fileLength = 1;
bool LocatedBlocksProto::has_filelength() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LocatedBlocksProto::set_has_filelength() {
  _has_bits_[0] |= 0x00000001u;
}
void LocatedBlocksProto::clear_has_filelength() {
  _has_bits_[0] &= ~0x00000001u;
}
void LocatedBlocksProto::clear_filelength() {
  filelength_ = GOOGLE_ULONGLONG(0);
  clear_has_filelength();
}
 ::google::protobuf::uint64 LocatedBlocksProto::filelength() const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.fileLength)
  return filelength_;
}
 void LocatedBlocksProto::set_filelength(::google::protobuf::uint64 value) {
  set_has_filelength();
  filelength_ = value;
  // @@protoc_insertion_point(field_set:LocatedBlocksProto.fileLength)
}

// repeated .LocatedBlockProto blocks = 2;
int LocatedBlocksProto::blocks_size() const {
  return blocks_.size();
}
void LocatedBlocksProto::clear_blocks() {
  blocks_.Clear();
}
const ::LocatedBlockProto& LocatedBlocksProto::blocks(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.blocks)
  return blocks_.Get(index);
}
::LocatedBlockProto* LocatedBlocksProto::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:LocatedBlocksProto.blocks)
  return blocks_.Mutable(index);
}
::LocatedBlockProto* LocatedBlocksProto::add_blocks() {
  // @@protoc_insertion_point(field_add:LocatedBlocksProto.blocks)
  return blocks_.Add();
}
::google::protobuf::RepeatedPtrField< ::LocatedBlockProto >*
LocatedBlocksProto::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlocksProto.blocks)
  return &blocks_;
}
const ::google::protobuf::RepeatedPtrField< ::LocatedBlockProto >&
LocatedBlocksProto::blocks() const {
  // @@protoc_insertion_point(field_list:LocatedBlocksProto.blocks)
  return blocks_;
}

// required bool underConstruction = 3;
bool LocatedBlocksProto::has_underconstruction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LocatedBlocksProto::set_has_underconstruction() {
  _has_bits_[0] |= 0x00000004u;
}
void LocatedBlocksProto::clear_has_underconstruction() {
  _has_bits_[0] &= ~0x00000004u;
}
void LocatedBlocksProto::clear_underconstruction() {
  underconstruction_ = false;
  clear_has_underconstruction();
}
 bool LocatedBlocksProto::underconstruction() const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.underConstruction)
  return underconstruction_;
}
 void LocatedBlocksProto::set_underconstruction(bool value) {
  set_has_underconstruction();
  underconstruction_ = value;
  // @@protoc_insertion_point(field_set:LocatedBlocksProto.underConstruction)
}

// optional .LocatedBlockProto lastBlock = 4;
bool LocatedBlocksProto::has_lastblock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void LocatedBlocksProto::set_has_lastblock() {
  _has_bits_[0] |= 0x00000008u;
}
void LocatedBlocksProto::clear_has_lastblock() {
  _has_bits_[0] &= ~0x00000008u;
}
void LocatedBlocksProto::clear_lastblock() {
  if (lastblock_ != NULL) lastblock_->::LocatedBlockProto::Clear();
  clear_has_lastblock();
}
const ::LocatedBlockProto& LocatedBlocksProto::lastblock() const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.lastBlock)
  return lastblock_ != NULL ? *lastblock_ : *default_instance_->lastblock_;
}
::LocatedBlockProto* LocatedBlocksProto::mutable_lastblock() {
  set_has_lastblock();
  if (lastblock_ == NULL) {
    lastblock_ = new ::LocatedBlockProto;
  }
  // @@protoc_insertion_point(field_mutable:LocatedBlocksProto.lastBlock)
  return lastblock_;
}
::LocatedBlockProto* LocatedBlocksProto::release_lastblock() {
  // @@protoc_insertion_point(field_release:LocatedBlocksProto.lastBlock)
  clear_has_lastblock();
  ::LocatedBlockProto* temp = lastblock_;
  lastblock_ = NULL;
  return temp;
}
void LocatedBlocksProto::set_allocated_lastblock(::LocatedBlockProto* lastblock) {
  delete lastblock_;
  lastblock_ = lastblock;
  if (lastblock) {
    set_has_lastblock();
  } else {
    clear_has_lastblock();
  }
  // @@protoc_insertion_point(field_set_allocated:LocatedBlocksProto.lastBlock)
}

// required bool isLastBlockComplete = 5;
bool LocatedBlocksProto::has_islastblockcomplete() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void LocatedBlocksProto::set_has_islastblockcomplete() {
  _has_bits_[0] |= 0x00000010u;
}
void LocatedBlocksProto::clear_has_islastblockcomplete() {
  _has_bits_[0] &= ~0x00000010u;
}
void LocatedBlocksProto::clear_islastblockcomplete() {
  islastblockcomplete_ = false;
  clear_has_islastblockcomplete();
}
 bool LocatedBlocksProto::islastblockcomplete() const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.isLastBlockComplete)
  return islastblockcomplete_;
}
 void LocatedBlocksProto::set_islastblockcomplete(bool value) {
  set_has_islastblockcomplete();
  islastblockcomplete_ = value;
  // @@protoc_insertion_point(field_set:LocatedBlocksProto.isLastBlockComplete)
}

// optional .FileEncryptionInfoProto fileEncryptionInfo = 6;
bool LocatedBlocksProto::has_fileencryptioninfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void LocatedBlocksProto::set_has_fileencryptioninfo() {
  _has_bits_[0] |= 0x00000020u;
}
void LocatedBlocksProto::clear_has_fileencryptioninfo() {
  _has_bits_[0] &= ~0x00000020u;
}
void LocatedBlocksProto::clear_fileencryptioninfo() {
  if (fileencryptioninfo_ != NULL) fileencryptioninfo_->::FileEncryptionInfoProto::Clear();
  clear_has_fileencryptioninfo();
}
const ::FileEncryptionInfoProto& LocatedBlocksProto::fileencryptioninfo() const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.fileEncryptionInfo)
  return fileencryptioninfo_ != NULL ? *fileencryptioninfo_ : *default_instance_->fileencryptioninfo_;
}
::FileEncryptionInfoProto* LocatedBlocksProto::mutable_fileencryptioninfo() {
  set_has_fileencryptioninfo();
  if (fileencryptioninfo_ == NULL) {
    fileencryptioninfo_ = new ::FileEncryptionInfoProto;
  }
  // @@protoc_insertion_point(field_mutable:LocatedBlocksProto.fileEncryptionInfo)
  return fileencryptioninfo_;
}
::FileEncryptionInfoProto* LocatedBlocksProto::release_fileencryptioninfo() {
  // @@protoc_insertion_point(field_release:LocatedBlocksProto.fileEncryptionInfo)
  clear_has_fileencryptioninfo();
  ::FileEncryptionInfoProto* temp = fileencryptioninfo_;
  fileencryptioninfo_ = NULL;
  return temp;
}
void LocatedBlocksProto::set_allocated_fileencryptioninfo(::FileEncryptionInfoProto* fileencryptioninfo) {
  delete fileencryptioninfo_;
  fileencryptioninfo_ = fileencryptioninfo;
  if (fileencryptioninfo) {
    set_has_fileencryptioninfo();
  } else {
    clear_has_fileencryptioninfo();
  }
  // @@protoc_insertion_point(field_set_allocated:LocatedBlocksProto.fileEncryptionInfo)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RequestHeaderProto::kMethodNameFieldNumber;
const int RequestHeaderProto::kDeclaringClassProtocolNameFieldNumber;
const int RequestHeaderProto::kClientProtocolVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RequestHeaderProto::RequestHeaderProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RequestHeaderProto)
}

void RequestHeaderProto::InitAsDefaultInstance() {
}

RequestHeaderProto::RequestHeaderProto(const RequestHeaderProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RequestHeaderProto)
}

void RequestHeaderProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  methodname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  declaringclassprotocolname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clientprotocolversion_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestHeaderProto::~RequestHeaderProto() {
  // @@protoc_insertion_point(destructor:RequestHeaderProto)
  SharedDtor();
}

void RequestHeaderProto::SharedDtor() {
  methodname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  declaringclassprotocolname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RequestHeaderProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestHeaderProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestHeaderProto_descriptor_;
}

const RequestHeaderProto& RequestHeaderProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

RequestHeaderProto* RequestHeaderProto::default_instance_ = NULL;

RequestHeaderProto* RequestHeaderProto::New(::google::protobuf::Arena* arena) const {
  RequestHeaderProto* n = new RequestHeaderProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestHeaderProto::Clear() {
// @@protoc_insertion_point(message_clear_start:RequestHeaderProto)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_methodname()) {
      methodname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_declaringclassprotocolname()) {
      declaringclassprotocolname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    clientprotocolversion_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestHeaderProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RequestHeaderProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string methodName = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_methodname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->methodname().data(), this->methodname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "RequestHeaderProto.methodName");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_declaringClassProtocolName;
        break;
      }

      // required string declaringClassProtocolName = 2;
      case 2: {
        if (tag == 18) {
         parse_declaringClassProtocolName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_declaringclassprotocolname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->declaringclassprotocolname().data(), this->declaringclassprotocolname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "RequestHeaderProto.declaringClassProtocolName");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_clientProtocolVersion;
        break;
      }

      // required uint64 clientProtocolVersion = 3;
      case 3: {
        if (tag == 24) {
         parse_clientProtocolVersion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &clientprotocolversion_)));
          set_has_clientprotocolversion();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RequestHeaderProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RequestHeaderProto)
  return false;
#undef DO_
}

void RequestHeaderProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RequestHeaderProto)
  // required string methodName = 1;
  if (has_methodname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->methodname().data(), this->methodname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RequestHeaderProto.methodName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->methodname(), output);
  }

  // required string declaringClassProtocolName = 2;
  if (has_declaringclassprotocolname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->declaringclassprotocolname().data(), this->declaringclassprotocolname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RequestHeaderProto.declaringClassProtocolName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->declaringclassprotocolname(), output);
  }

  // required uint64 clientProtocolVersion = 3;
  if (has_clientprotocolversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->clientprotocolversion(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RequestHeaderProto)
}

::google::protobuf::uint8* RequestHeaderProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RequestHeaderProto)
  // required string methodName = 1;
  if (has_methodname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->methodname().data(), this->methodname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RequestHeaderProto.methodName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->methodname(), target);
  }

  // required string declaringClassProtocolName = 2;
  if (has_declaringclassprotocolname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->declaringclassprotocolname().data(), this->declaringclassprotocolname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RequestHeaderProto.declaringClassProtocolName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->declaringclassprotocolname(), target);
  }

  // required uint64 clientProtocolVersion = 3;
  if (has_clientprotocolversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->clientprotocolversion(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RequestHeaderProto)
  return target;
}

int RequestHeaderProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RequestHeaderProto)
  int total_size = 0;

  if (has_methodname()) {
    // required string methodName = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->methodname());
  }

  if (has_declaringclassprotocolname()) {
    // required string declaringClassProtocolName = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->declaringclassprotocolname());
  }

  if (has_clientprotocolversion()) {
    // required uint64 clientProtocolVersion = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->clientprotocolversion());
  }

  return total_size;
}
int RequestHeaderProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RequestHeaderProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string methodName = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->methodname());

    // required string declaringClassProtocolName = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->declaringclassprotocolname());

    // required uint64 clientProtocolVersion = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->clientprotocolversion());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestHeaderProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RequestHeaderProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RequestHeaderProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestHeaderProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RequestHeaderProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RequestHeaderProto)
    MergeFrom(*source);
  }
}

void RequestHeaderProto::MergeFrom(const RequestHeaderProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RequestHeaderProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_methodname()) {
      set_has_methodname();
      methodname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.methodname_);
    }
    if (from.has_declaringclassprotocolname()) {
      set_has_declaringclassprotocolname();
      declaringclassprotocolname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.declaringclassprotocolname_);
    }
    if (from.has_clientprotocolversion()) {
      set_clientprotocolversion(from.clientprotocolversion());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestHeaderProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RequestHeaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestHeaderProto::CopyFrom(const RequestHeaderProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RequestHeaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestHeaderProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RequestHeaderProto::Swap(RequestHeaderProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestHeaderProto::InternalSwap(RequestHeaderProto* other) {
  methodname_.Swap(&other->methodname_);
  declaringclassprotocolname_.Swap(&other->declaringclassprotocolname_);
  std::swap(clientprotocolversion_, other->clientprotocolversion_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestHeaderProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestHeaderProto_descriptor_;
  metadata.reflection = RequestHeaderProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestHeaderProto

// required string methodName = 1;
bool RequestHeaderProto::has_methodname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestHeaderProto::set_has_methodname() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestHeaderProto::clear_has_methodname() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestHeaderProto::clear_methodname() {
  methodname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_methodname();
}
 const ::std::string& RequestHeaderProto::methodname() const {
  // @@protoc_insertion_point(field_get:RequestHeaderProto.methodName)
  return methodname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestHeaderProto::set_methodname(const ::std::string& value) {
  set_has_methodname();
  methodname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RequestHeaderProto.methodName)
}
 void RequestHeaderProto::set_methodname(const char* value) {
  set_has_methodname();
  methodname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RequestHeaderProto.methodName)
}
 void RequestHeaderProto::set_methodname(const char* value, size_t size) {
  set_has_methodname();
  methodname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RequestHeaderProto.methodName)
}
 ::std::string* RequestHeaderProto::mutable_methodname() {
  set_has_methodname();
  // @@protoc_insertion_point(field_mutable:RequestHeaderProto.methodName)
  return methodname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestHeaderProto::release_methodname() {
  // @@protoc_insertion_point(field_release:RequestHeaderProto.methodName)
  clear_has_methodname();
  return methodname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestHeaderProto::set_allocated_methodname(::std::string* methodname) {
  if (methodname != NULL) {
    set_has_methodname();
  } else {
    clear_has_methodname();
  }
  methodname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), methodname);
  // @@protoc_insertion_point(field_set_allocated:RequestHeaderProto.methodName)
}

// required string declaringClassProtocolName = 2;
bool RequestHeaderProto::has_declaringclassprotocolname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RequestHeaderProto::set_has_declaringclassprotocolname() {
  _has_bits_[0] |= 0x00000002u;
}
void RequestHeaderProto::clear_has_declaringclassprotocolname() {
  _has_bits_[0] &= ~0x00000002u;
}
void RequestHeaderProto::clear_declaringclassprotocolname() {
  declaringclassprotocolname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_declaringclassprotocolname();
}
 const ::std::string& RequestHeaderProto::declaringclassprotocolname() const {
  // @@protoc_insertion_point(field_get:RequestHeaderProto.declaringClassProtocolName)
  return declaringclassprotocolname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestHeaderProto::set_declaringclassprotocolname(const ::std::string& value) {
  set_has_declaringclassprotocolname();
  declaringclassprotocolname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RequestHeaderProto.declaringClassProtocolName)
}
 void RequestHeaderProto::set_declaringclassprotocolname(const char* value) {
  set_has_declaringclassprotocolname();
  declaringclassprotocolname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RequestHeaderProto.declaringClassProtocolName)
}
 void RequestHeaderProto::set_declaringclassprotocolname(const char* value, size_t size) {
  set_has_declaringclassprotocolname();
  declaringclassprotocolname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RequestHeaderProto.declaringClassProtocolName)
}
 ::std::string* RequestHeaderProto::mutable_declaringclassprotocolname() {
  set_has_declaringclassprotocolname();
  // @@protoc_insertion_point(field_mutable:RequestHeaderProto.declaringClassProtocolName)
  return declaringclassprotocolname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestHeaderProto::release_declaringclassprotocolname() {
  // @@protoc_insertion_point(field_release:RequestHeaderProto.declaringClassProtocolName)
  clear_has_declaringclassprotocolname();
  return declaringclassprotocolname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestHeaderProto::set_allocated_declaringclassprotocolname(::std::string* declaringclassprotocolname) {
  if (declaringclassprotocolname != NULL) {
    set_has_declaringclassprotocolname();
  } else {
    clear_has_declaringclassprotocolname();
  }
  declaringclassprotocolname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), declaringclassprotocolname);
  // @@protoc_insertion_point(field_set_allocated:RequestHeaderProto.declaringClassProtocolName)
}

// required uint64 clientProtocolVersion = 3;
bool RequestHeaderProto::has_clientprotocolversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RequestHeaderProto::set_has_clientprotocolversion() {
  _has_bits_[0] |= 0x00000004u;
}
void RequestHeaderProto::clear_has_clientprotocolversion() {
  _has_bits_[0] &= ~0x00000004u;
}
void RequestHeaderProto::clear_clientprotocolversion() {
  clientprotocolversion_ = GOOGLE_ULONGLONG(0);
  clear_has_clientprotocolversion();
}
 ::google::protobuf::uint64 RequestHeaderProto::clientprotocolversion() const {
  // @@protoc_insertion_point(field_get:RequestHeaderProto.clientProtocolVersion)
  return clientprotocolversion_;
}
 void RequestHeaderProto::set_clientprotocolversion(::google::protobuf::uint64 value) {
  set_has_clientprotocolversion();
  clientprotocolversion_ = value;
  // @@protoc_insertion_point(field_set:RequestHeaderProto.clientProtocolVersion)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StorageInfoProto::kLayoutVersionFieldNumber;
const int StorageInfoProto::kNamespceIDFieldNumber;
const int StorageInfoProto::kClusterIDFieldNumber;
const int StorageInfoProto::kCTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StorageInfoProto::StorageInfoProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:StorageInfoProto)
}

void StorageInfoProto::InitAsDefaultInstance() {
}

StorageInfoProto::StorageInfoProto(const StorageInfoProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:StorageInfoProto)
}

void StorageInfoProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  layoutversion_ = 0u;
  namespceid_ = 0u;
  clusterid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ctime_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StorageInfoProto::~StorageInfoProto() {
  // @@protoc_insertion_point(destructor:StorageInfoProto)
  SharedDtor();
}

void StorageInfoProto::SharedDtor() {
  clusterid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void StorageInfoProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StorageInfoProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StorageInfoProto_descriptor_;
}

const StorageInfoProto& StorageInfoProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

StorageInfoProto* StorageInfoProto::default_instance_ = NULL;

StorageInfoProto* StorageInfoProto::New(::google::protobuf::Arena* arena) const {
  StorageInfoProto* n = new StorageInfoProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StorageInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:StorageInfoProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(StorageInfoProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<StorageInfoProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(layoutversion_, namespceid_);
    if (has_clusterid()) {
      clusterid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ctime_ = GOOGLE_ULONGLONG(0);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool StorageInfoProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:StorageInfoProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 layoutVersion = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &layoutversion_)));
          set_has_layoutversion();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_namespceID;
        break;
      }

      // required uint32 namespceID = 2;
      case 2: {
        if (tag == 16) {
         parse_namespceID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &namespceid_)));
          set_has_namespceid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_clusterID;
        break;
      }

      // required string clusterID = 3;
      case 3: {
        if (tag == 26) {
         parse_clusterID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clusterid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->clusterid().data(), this->clusterid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "StorageInfoProto.clusterID");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cTime;
        break;
      }

      // required uint64 cTime = 4;
      case 4: {
        if (tag == 32) {
         parse_cTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ctime_)));
          set_has_ctime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:StorageInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:StorageInfoProto)
  return false;
#undef DO_
}

void StorageInfoProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:StorageInfoProto)
  // required uint32 layoutVersion = 1;
  if (has_layoutversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->layoutversion(), output);
  }

  // required uint32 namespceID = 2;
  if (has_namespceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->namespceid(), output);
  }

  // required string clusterID = 3;
  if (has_clusterid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->clusterid().data(), this->clusterid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "StorageInfoProto.clusterID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->clusterid(), output);
  }

  // required uint64 cTime = 4;
  if (has_ctime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->ctime(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:StorageInfoProto)
}

::google::protobuf::uint8* StorageInfoProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:StorageInfoProto)
  // required uint32 layoutVersion = 1;
  if (has_layoutversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->layoutversion(), target);
  }

  // required uint32 namespceID = 2;
  if (has_namespceid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->namespceid(), target);
  }

  // required string clusterID = 3;
  if (has_clusterid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->clusterid().data(), this->clusterid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "StorageInfoProto.clusterID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->clusterid(), target);
  }

  // required uint64 cTime = 4;
  if (has_ctime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->ctime(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StorageInfoProto)
  return target;
}

int StorageInfoProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:StorageInfoProto)
  int total_size = 0;

  if (has_layoutversion()) {
    // required uint32 layoutVersion = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->layoutversion());
  }

  if (has_namespceid()) {
    // required uint32 namespceID = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->namespceid());
  }

  if (has_clusterid()) {
    // required string clusterID = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->clusterid());
  }

  if (has_ctime()) {
    // required uint64 cTime = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->ctime());
  }

  return total_size;
}
int StorageInfoProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:StorageInfoProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required uint32 layoutVersion = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->layoutversion());

    // required uint32 namespceID = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->namespceid());

    // required string clusterID = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->clusterid());

    // required uint64 cTime = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->ctime());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StorageInfoProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:StorageInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const StorageInfoProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const StorageInfoProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:StorageInfoProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:StorageInfoProto)
    MergeFrom(*source);
  }
}

void StorageInfoProto::MergeFrom(const StorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:StorageInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_layoutversion()) {
      set_layoutversion(from.layoutversion());
    }
    if (from.has_namespceid()) {
      set_namespceid(from.namespceid());
    }
    if (from.has_clusterid()) {
      set_has_clusterid();
      clusterid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.clusterid_);
    }
    if (from.has_ctime()) {
      set_ctime(from.ctime());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void StorageInfoProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:StorageInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StorageInfoProto::CopyFrom(const StorageInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StorageInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void StorageInfoProto::Swap(StorageInfoProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StorageInfoProto::InternalSwap(StorageInfoProto* other) {
  std::swap(layoutversion_, other->layoutversion_);
  std::swap(namespceid_, other->namespceid_);
  clusterid_.Swap(&other->clusterid_);
  std::swap(ctime_, other->ctime_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata StorageInfoProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StorageInfoProto_descriptor_;
  metadata.reflection = StorageInfoProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StorageInfoProto

// required uint32 layoutVersion = 1;
bool StorageInfoProto::has_layoutversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StorageInfoProto::set_has_layoutversion() {
  _has_bits_[0] |= 0x00000001u;
}
void StorageInfoProto::clear_has_layoutversion() {
  _has_bits_[0] &= ~0x00000001u;
}
void StorageInfoProto::clear_layoutversion() {
  layoutversion_ = 0u;
  clear_has_layoutversion();
}
 ::google::protobuf::uint32 StorageInfoProto::layoutversion() const {
  // @@protoc_insertion_point(field_get:StorageInfoProto.layoutVersion)
  return layoutversion_;
}
 void StorageInfoProto::set_layoutversion(::google::protobuf::uint32 value) {
  set_has_layoutversion();
  layoutversion_ = value;
  // @@protoc_insertion_point(field_set:StorageInfoProto.layoutVersion)
}

// required uint32 namespceID = 2;
bool StorageInfoProto::has_namespceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void StorageInfoProto::set_has_namespceid() {
  _has_bits_[0] |= 0x00000002u;
}
void StorageInfoProto::clear_has_namespceid() {
  _has_bits_[0] &= ~0x00000002u;
}
void StorageInfoProto::clear_namespceid() {
  namespceid_ = 0u;
  clear_has_namespceid();
}
 ::google::protobuf::uint32 StorageInfoProto::namespceid() const {
  // @@protoc_insertion_point(field_get:StorageInfoProto.namespceID)
  return namespceid_;
}
 void StorageInfoProto::set_namespceid(::google::protobuf::uint32 value) {
  set_has_namespceid();
  namespceid_ = value;
  // @@protoc_insertion_point(field_set:StorageInfoProto.namespceID)
}

// required string clusterID = 3;
bool StorageInfoProto::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void StorageInfoProto::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
void StorageInfoProto::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
void StorageInfoProto::clear_clusterid() {
  clusterid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clusterid();
}
 const ::std::string& StorageInfoProto::clusterid() const {
  // @@protoc_insertion_point(field_get:StorageInfoProto.clusterID)
  return clusterid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StorageInfoProto::set_clusterid(const ::std::string& value) {
  set_has_clusterid();
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:StorageInfoProto.clusterID)
}
 void StorageInfoProto::set_clusterid(const char* value) {
  set_has_clusterid();
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:StorageInfoProto.clusterID)
}
 void StorageInfoProto::set_clusterid(const char* value, size_t size) {
  set_has_clusterid();
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:StorageInfoProto.clusterID)
}
 ::std::string* StorageInfoProto::mutable_clusterid() {
  set_has_clusterid();
  // @@protoc_insertion_point(field_mutable:StorageInfoProto.clusterID)
  return clusterid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* StorageInfoProto::release_clusterid() {
  // @@protoc_insertion_point(field_release:StorageInfoProto.clusterID)
  clear_has_clusterid();
  return clusterid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void StorageInfoProto::set_allocated_clusterid(::std::string* clusterid) {
  if (clusterid != NULL) {
    set_has_clusterid();
  } else {
    clear_has_clusterid();
  }
  clusterid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clusterid);
  // @@protoc_insertion_point(field_set_allocated:StorageInfoProto.clusterID)
}

// required uint64 cTime = 4;
bool StorageInfoProto::has_ctime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void StorageInfoProto::set_has_ctime() {
  _has_bits_[0] |= 0x00000008u;
}
void StorageInfoProto::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000008u;
}
void StorageInfoProto::clear_ctime() {
  ctime_ = GOOGLE_ULONGLONG(0);
  clear_has_ctime();
}
 ::google::protobuf::uint64 StorageInfoProto::ctime() const {
  // @@protoc_insertion_point(field_get:StorageInfoProto.cTime)
  return ctime_;
}
 void StorageInfoProto::set_ctime(::google::protobuf::uint64 value) {
  set_has_ctime();
  ctime_ = value;
  // @@protoc_insertion_point(field_set:StorageInfoProto.cTime)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BlockKeyProto::kKeyIdFieldNumber;
const int BlockKeyProto::kExpiryDateFieldNumber;
const int BlockKeyProto::kKeyBytesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BlockKeyProto::BlockKeyProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:BlockKeyProto)
}

void BlockKeyProto::InitAsDefaultInstance() {
}

BlockKeyProto::BlockKeyProto(const BlockKeyProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:BlockKeyProto)
}

void BlockKeyProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  keyid_ = 0u;
  expirydate_ = GOOGLE_ULONGLONG(0);
  keybytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlockKeyProto::~BlockKeyProto() {
  // @@protoc_insertion_point(destructor:BlockKeyProto)
  SharedDtor();
}

void BlockKeyProto::SharedDtor() {
  keybytes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void BlockKeyProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlockKeyProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlockKeyProto_descriptor_;
}

const BlockKeyProto& BlockKeyProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

BlockKeyProto* BlockKeyProto::default_instance_ = NULL;

BlockKeyProto* BlockKeyProto::New(::google::protobuf::Arena* arena) const {
  BlockKeyProto* n = new BlockKeyProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BlockKeyProto::Clear() {
// @@protoc_insertion_point(message_clear_start:BlockKeyProto)
  if (_has_bits_[0 / 32] & 7u) {
    keyid_ = 0u;
    expirydate_ = GOOGLE_ULONGLONG(0);
    if (has_keybytes()) {
      keybytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BlockKeyProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:BlockKeyProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 keyId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &keyid_)));
          set_has_keyid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_expiryDate;
        break;
      }

      // required uint64 expiryDate = 2;
      case 2: {
        if (tag == 16) {
         parse_expiryDate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &expirydate_)));
          set_has_expirydate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_keyBytes;
        break;
      }

      // optional bytes keyBytes = 3;
      case 3: {
        if (tag == 26) {
         parse_keyBytes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_keybytes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:BlockKeyProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:BlockKeyProto)
  return false;
#undef DO_
}

void BlockKeyProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:BlockKeyProto)
  // required uint32 keyId = 1;
  if (has_keyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->keyid(), output);
  }

  // required uint64 expiryDate = 2;
  if (has_expirydate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->expirydate(), output);
  }

  // optional bytes keyBytes = 3;
  if (has_keybytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->keybytes(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:BlockKeyProto)
}

::google::protobuf::uint8* BlockKeyProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:BlockKeyProto)
  // required uint32 keyId = 1;
  if (has_keyid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->keyid(), target);
  }

  // required uint64 expiryDate = 2;
  if (has_expirydate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->expirydate(), target);
  }

  // optional bytes keyBytes = 3;
  if (has_keybytes()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->keybytes(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BlockKeyProto)
  return target;
}

int BlockKeyProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:BlockKeyProto)
  int total_size = 0;

  if (has_keyid()) {
    // required uint32 keyId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->keyid());
  }

  if (has_expirydate()) {
    // required uint64 expiryDate = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->expirydate());
  }

  return total_size;
}
int BlockKeyProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:BlockKeyProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 keyId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->keyid());

    // required uint64 expiryDate = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->expirydate());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional bytes keyBytes = 3;
  if (has_keybytes()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->keybytes());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlockKeyProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:BlockKeyProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const BlockKeyProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BlockKeyProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:BlockKeyProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:BlockKeyProto)
    MergeFrom(*source);
  }
}

void BlockKeyProto::MergeFrom(const BlockKeyProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:BlockKeyProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keyid()) {
      set_keyid(from.keyid());
    }
    if (from.has_expirydate()) {
      set_expirydate(from.expirydate());
    }
    if (from.has_keybytes()) {
      set_has_keybytes();
      keybytes_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.keybytes_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BlockKeyProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:BlockKeyProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlockKeyProto::CopyFrom(const BlockKeyProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BlockKeyProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockKeyProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BlockKeyProto::Swap(BlockKeyProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BlockKeyProto::InternalSwap(BlockKeyProto* other) {
  std::swap(keyid_, other->keyid_);
  std::swap(expirydate_, other->expirydate_);
  keybytes_.Swap(&other->keybytes_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BlockKeyProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlockKeyProto_descriptor_;
  metadata.reflection = BlockKeyProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BlockKeyProto

// required uint32 keyId = 1;
bool BlockKeyProto::has_keyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BlockKeyProto::set_has_keyid() {
  _has_bits_[0] |= 0x00000001u;
}
void BlockKeyProto::clear_has_keyid() {
  _has_bits_[0] &= ~0x00000001u;
}
void BlockKeyProto::clear_keyid() {
  keyid_ = 0u;
  clear_has_keyid();
}
 ::google::protobuf::uint32 BlockKeyProto::keyid() const {
  // @@protoc_insertion_point(field_get:BlockKeyProto.keyId)
  return keyid_;
}
 void BlockKeyProto::set_keyid(::google::protobuf::uint32 value) {
  set_has_keyid();
  keyid_ = value;
  // @@protoc_insertion_point(field_set:BlockKeyProto.keyId)
}

// required uint64 expiryDate = 2;
bool BlockKeyProto::has_expirydate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void BlockKeyProto::set_has_expirydate() {
  _has_bits_[0] |= 0x00000002u;
}
void BlockKeyProto::clear_has_expirydate() {
  _has_bits_[0] &= ~0x00000002u;
}
void BlockKeyProto::clear_expirydate() {
  expirydate_ = GOOGLE_ULONGLONG(0);
  clear_has_expirydate();
}
 ::google::protobuf::uint64 BlockKeyProto::expirydate() const {
  // @@protoc_insertion_point(field_get:BlockKeyProto.expiryDate)
  return expirydate_;
}
 void BlockKeyProto::set_expirydate(::google::protobuf::uint64 value) {
  set_has_expirydate();
  expirydate_ = value;
  // @@protoc_insertion_point(field_set:BlockKeyProto.expiryDate)
}

// optional bytes keyBytes = 3;
bool BlockKeyProto::has_keybytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void BlockKeyProto::set_has_keybytes() {
  _has_bits_[0] |= 0x00000004u;
}
void BlockKeyProto::clear_has_keybytes() {
  _has_bits_[0] &= ~0x00000004u;
}
void BlockKeyProto::clear_keybytes() {
  keybytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keybytes();
}
 const ::std::string& BlockKeyProto::keybytes() const {
  // @@protoc_insertion_point(field_get:BlockKeyProto.keyBytes)
  return keybytes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void BlockKeyProto::set_keybytes(const ::std::string& value) {
  set_has_keybytes();
  keybytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BlockKeyProto.keyBytes)
}
 void BlockKeyProto::set_keybytes(const char* value) {
  set_has_keybytes();
  keybytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BlockKeyProto.keyBytes)
}
 void BlockKeyProto::set_keybytes(const void* value, size_t size) {
  set_has_keybytes();
  keybytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BlockKeyProto.keyBytes)
}
 ::std::string* BlockKeyProto::mutable_keybytes() {
  set_has_keybytes();
  // @@protoc_insertion_point(field_mutable:BlockKeyProto.keyBytes)
  return keybytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* BlockKeyProto::release_keybytes() {
  // @@protoc_insertion_point(field_release:BlockKeyProto.keyBytes)
  clear_has_keybytes();
  return keybytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void BlockKeyProto::set_allocated_keybytes(::std::string* keybytes) {
  if (keybytes != NULL) {
    set_has_keybytes();
  } else {
    clear_has_keybytes();
  }
  keybytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keybytes);
  // @@protoc_insertion_point(field_set_allocated:BlockKeyProto.keyBytes)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ExportedBlockKeysProto::kIsBlockTokenEnabledFieldNumber;
const int ExportedBlockKeysProto::kKeyUpdateIntervalFieldNumber;
const int ExportedBlockKeysProto::kTokenLifeTimeFieldNumber;
const int ExportedBlockKeysProto::kCurrentKeyFieldNumber;
const int ExportedBlockKeysProto::kAllKeysFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ExportedBlockKeysProto::ExportedBlockKeysProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ExportedBlockKeysProto)
}

void ExportedBlockKeysProto::InitAsDefaultInstance() {
  currentkey_ = const_cast< ::BlockKeyProto*>(&::BlockKeyProto::default_instance());
}

ExportedBlockKeysProto::ExportedBlockKeysProto(const ExportedBlockKeysProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ExportedBlockKeysProto)
}

void ExportedBlockKeysProto::SharedCtor() {
  _cached_size_ = 0;
  isblocktokenenabled_ = false;
  keyupdateinterval_ = GOOGLE_ULONGLONG(0);
  tokenlifetime_ = GOOGLE_ULONGLONG(0);
  currentkey_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExportedBlockKeysProto::~ExportedBlockKeysProto() {
  // @@protoc_insertion_point(destructor:ExportedBlockKeysProto)
  SharedDtor();
}

void ExportedBlockKeysProto::SharedDtor() {
  if (this != default_instance_) {
    delete currentkey_;
  }
}

void ExportedBlockKeysProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExportedBlockKeysProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExportedBlockKeysProto_descriptor_;
}

const ExportedBlockKeysProto& ExportedBlockKeysProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

ExportedBlockKeysProto* ExportedBlockKeysProto::default_instance_ = NULL;

ExportedBlockKeysProto* ExportedBlockKeysProto::New(::google::protobuf::Arena* arena) const {
  ExportedBlockKeysProto* n = new ExportedBlockKeysProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ExportedBlockKeysProto::Clear() {
// @@protoc_insertion_point(message_clear_start:ExportedBlockKeysProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ExportedBlockKeysProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ExportedBlockKeysProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(keyupdateinterval_, tokenlifetime_);
    isblocktokenenabled_ = false;
    if (has_currentkey()) {
      if (currentkey_ != NULL) currentkey_->::BlockKeyProto::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  allkeys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ExportedBlockKeysProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ExportedBlockKeysProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool isBlockTokenEnabled = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isblocktokenenabled_)));
          set_has_isblocktokenenabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_keyUpdateInterval;
        break;
      }

      // required uint64 keyUpdateInterval = 2;
      case 2: {
        if (tag == 16) {
         parse_keyUpdateInterval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &keyupdateinterval_)));
          set_has_keyupdateinterval();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_tokenLifeTime;
        break;
      }

      // required uint64 tokenLifeTime = 3;
      case 3: {
        if (tag == 24) {
         parse_tokenLifeTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tokenlifetime_)));
          set_has_tokenlifetime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_currentKey;
        break;
      }

      // required .BlockKeyProto currentKey = 4;
      case 4: {
        if (tag == 34) {
         parse_currentKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_currentkey()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_allKeys;
        break;
      }

      // repeated .BlockKeyProto allKeys = 5;
      case 5: {
        if (tag == 42) {
         parse_allKeys:
          DO_(input->IncrementRecursionDepth());
         parse_loop_allKeys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_allkeys()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_allKeys;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ExportedBlockKeysProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ExportedBlockKeysProto)
  return false;
#undef DO_
}

void ExportedBlockKeysProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ExportedBlockKeysProto)
  // required bool isBlockTokenEnabled = 1;
  if (has_isblocktokenenabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->isblocktokenenabled(), output);
  }

  // required uint64 keyUpdateInterval = 2;
  if (has_keyupdateinterval()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->keyupdateinterval(), output);
  }

  // required uint64 tokenLifeTime = 3;
  if (has_tokenlifetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->tokenlifetime(), output);
  }

  // required .BlockKeyProto currentKey = 4;
  if (has_currentkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->currentkey_, output);
  }

  // repeated .BlockKeyProto allKeys = 5;
  for (unsigned int i = 0, n = this->allkeys_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->allkeys(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ExportedBlockKeysProto)
}

::google::protobuf::uint8* ExportedBlockKeysProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ExportedBlockKeysProto)
  // required bool isBlockTokenEnabled = 1;
  if (has_isblocktokenenabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->isblocktokenenabled(), target);
  }

  // required uint64 keyUpdateInterval = 2;
  if (has_keyupdateinterval()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->keyupdateinterval(), target);
  }

  // required uint64 tokenLifeTime = 3;
  if (has_tokenlifetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->tokenlifetime(), target);
  }

  // required .BlockKeyProto currentKey = 4;
  if (has_currentkey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->currentkey_, false, target);
  }

  // repeated .BlockKeyProto allKeys = 5;
  for (unsigned int i = 0, n = this->allkeys_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->allkeys(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ExportedBlockKeysProto)
  return target;
}

int ExportedBlockKeysProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ExportedBlockKeysProto)
  int total_size = 0;

  if (has_isblocktokenenabled()) {
    // required bool isBlockTokenEnabled = 1;
    total_size += 1 + 1;
  }

  if (has_keyupdateinterval()) {
    // required uint64 keyUpdateInterval = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->keyupdateinterval());
  }

  if (has_tokenlifetime()) {
    // required uint64 tokenLifeTime = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->tokenlifetime());
  }

  if (has_currentkey()) {
    // required .BlockKeyProto currentKey = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->currentkey_);
  }

  return total_size;
}
int ExportedBlockKeysProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:ExportedBlockKeysProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bool isBlockTokenEnabled = 1;
    total_size += 1 + 1;

    // required uint64 keyUpdateInterval = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->keyupdateinterval());

    // required uint64 tokenLifeTime = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->tokenlifetime());

    // required .BlockKeyProto currentKey = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->currentkey_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated .BlockKeyProto allKeys = 5;
  total_size += 1 * this->allkeys_size();
  for (int i = 0; i < this->allkeys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->allkeys(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExportedBlockKeysProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ExportedBlockKeysProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ExportedBlockKeysProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ExportedBlockKeysProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ExportedBlockKeysProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ExportedBlockKeysProto)
    MergeFrom(*source);
  }
}

void ExportedBlockKeysProto::MergeFrom(const ExportedBlockKeysProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ExportedBlockKeysProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  allkeys_.MergeFrom(from.allkeys_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_isblocktokenenabled()) {
      set_isblocktokenenabled(from.isblocktokenenabled());
    }
    if (from.has_keyupdateinterval()) {
      set_keyupdateinterval(from.keyupdateinterval());
    }
    if (from.has_tokenlifetime()) {
      set_tokenlifetime(from.tokenlifetime());
    }
    if (from.has_currentkey()) {
      mutable_currentkey()->::BlockKeyProto::MergeFrom(from.currentkey());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ExportedBlockKeysProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ExportedBlockKeysProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExportedBlockKeysProto::CopyFrom(const ExportedBlockKeysProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ExportedBlockKeysProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExportedBlockKeysProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_currentkey()) {
    if (!this->currentkey_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->allkeys())) return false;
  return true;
}

void ExportedBlockKeysProto::Swap(ExportedBlockKeysProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ExportedBlockKeysProto::InternalSwap(ExportedBlockKeysProto* other) {
  std::swap(isblocktokenenabled_, other->isblocktokenenabled_);
  std::swap(keyupdateinterval_, other->keyupdateinterval_);
  std::swap(tokenlifetime_, other->tokenlifetime_);
  std::swap(currentkey_, other->currentkey_);
  allkeys_.UnsafeArenaSwap(&other->allkeys_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ExportedBlockKeysProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExportedBlockKeysProto_descriptor_;
  metadata.reflection = ExportedBlockKeysProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ExportedBlockKeysProto

// required bool isBlockTokenEnabled = 1;
bool ExportedBlockKeysProto::has_isblocktokenenabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ExportedBlockKeysProto::set_has_isblocktokenenabled() {
  _has_bits_[0] |= 0x00000001u;
}
void ExportedBlockKeysProto::clear_has_isblocktokenenabled() {
  _has_bits_[0] &= ~0x00000001u;
}
void ExportedBlockKeysProto::clear_isblocktokenenabled() {
  isblocktokenenabled_ = false;
  clear_has_isblocktokenenabled();
}
 bool ExportedBlockKeysProto::isblocktokenenabled() const {
  // @@protoc_insertion_point(field_get:ExportedBlockKeysProto.isBlockTokenEnabled)
  return isblocktokenenabled_;
}
 void ExportedBlockKeysProto::set_isblocktokenenabled(bool value) {
  set_has_isblocktokenenabled();
  isblocktokenenabled_ = value;
  // @@protoc_insertion_point(field_set:ExportedBlockKeysProto.isBlockTokenEnabled)
}

// required uint64 keyUpdateInterval = 2;
bool ExportedBlockKeysProto::has_keyupdateinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ExportedBlockKeysProto::set_has_keyupdateinterval() {
  _has_bits_[0] |= 0x00000002u;
}
void ExportedBlockKeysProto::clear_has_keyupdateinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
void ExportedBlockKeysProto::clear_keyupdateinterval() {
  keyupdateinterval_ = GOOGLE_ULONGLONG(0);
  clear_has_keyupdateinterval();
}
 ::google::protobuf::uint64 ExportedBlockKeysProto::keyupdateinterval() const {
  // @@protoc_insertion_point(field_get:ExportedBlockKeysProto.keyUpdateInterval)
  return keyupdateinterval_;
}
 void ExportedBlockKeysProto::set_keyupdateinterval(::google::protobuf::uint64 value) {
  set_has_keyupdateinterval();
  keyupdateinterval_ = value;
  // @@protoc_insertion_point(field_set:ExportedBlockKeysProto.keyUpdateInterval)
}

// required uint64 tokenLifeTime = 3;
bool ExportedBlockKeysProto::has_tokenlifetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ExportedBlockKeysProto::set_has_tokenlifetime() {
  _has_bits_[0] |= 0x00000004u;
}
void ExportedBlockKeysProto::clear_has_tokenlifetime() {
  _has_bits_[0] &= ~0x00000004u;
}
void ExportedBlockKeysProto::clear_tokenlifetime() {
  tokenlifetime_ = GOOGLE_ULONGLONG(0);
  clear_has_tokenlifetime();
}
 ::google::protobuf::uint64 ExportedBlockKeysProto::tokenlifetime() const {
  // @@protoc_insertion_point(field_get:ExportedBlockKeysProto.tokenLifeTime)
  return tokenlifetime_;
}
 void ExportedBlockKeysProto::set_tokenlifetime(::google::protobuf::uint64 value) {
  set_has_tokenlifetime();
  tokenlifetime_ = value;
  // @@protoc_insertion_point(field_set:ExportedBlockKeysProto.tokenLifeTime)
}

// required .BlockKeyProto currentKey = 4;
bool ExportedBlockKeysProto::has_currentkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ExportedBlockKeysProto::set_has_currentkey() {
  _has_bits_[0] |= 0x00000008u;
}
void ExportedBlockKeysProto::clear_has_currentkey() {
  _has_bits_[0] &= ~0x00000008u;
}
void ExportedBlockKeysProto::clear_currentkey() {
  if (currentkey_ != NULL) currentkey_->::BlockKeyProto::Clear();
  clear_has_currentkey();
}
const ::BlockKeyProto& ExportedBlockKeysProto::currentkey() const {
  // @@protoc_insertion_point(field_get:ExportedBlockKeysProto.currentKey)
  return currentkey_ != NULL ? *currentkey_ : *default_instance_->currentkey_;
}
::BlockKeyProto* ExportedBlockKeysProto::mutable_currentkey() {
  set_has_currentkey();
  if (currentkey_ == NULL) {
    currentkey_ = new ::BlockKeyProto;
  }
  // @@protoc_insertion_point(field_mutable:ExportedBlockKeysProto.currentKey)
  return currentkey_;
}
::BlockKeyProto* ExportedBlockKeysProto::release_currentkey() {
  // @@protoc_insertion_point(field_release:ExportedBlockKeysProto.currentKey)
  clear_has_currentkey();
  ::BlockKeyProto* temp = currentkey_;
  currentkey_ = NULL;
  return temp;
}
void ExportedBlockKeysProto::set_allocated_currentkey(::BlockKeyProto* currentkey) {
  delete currentkey_;
  currentkey_ = currentkey;
  if (currentkey) {
    set_has_currentkey();
  } else {
    clear_has_currentkey();
  }
  // @@protoc_insertion_point(field_set_allocated:ExportedBlockKeysProto.currentKey)
}

// repeated .BlockKeyProto allKeys = 5;
int ExportedBlockKeysProto::allkeys_size() const {
  return allkeys_.size();
}
void ExportedBlockKeysProto::clear_allkeys() {
  allkeys_.Clear();
}
const ::BlockKeyProto& ExportedBlockKeysProto::allkeys(int index) const {
  // @@protoc_insertion_point(field_get:ExportedBlockKeysProto.allKeys)
  return allkeys_.Get(index);
}
::BlockKeyProto* ExportedBlockKeysProto::mutable_allkeys(int index) {
  // @@protoc_insertion_point(field_mutable:ExportedBlockKeysProto.allKeys)
  return allkeys_.Mutable(index);
}
::BlockKeyProto* ExportedBlockKeysProto::add_allkeys() {
  // @@protoc_insertion_point(field_add:ExportedBlockKeysProto.allKeys)
  return allkeys_.Add();
}
::google::protobuf::RepeatedPtrField< ::BlockKeyProto >*
ExportedBlockKeysProto::mutable_allkeys() {
  // @@protoc_insertion_point(field_mutable_list:ExportedBlockKeysProto.allKeys)
  return &allkeys_;
}
const ::google::protobuf::RepeatedPtrField< ::BlockKeyProto >&
ExportedBlockKeysProto::allkeys() const {
  // @@protoc_insertion_point(field_list:ExportedBlockKeysProto.allKeys)
  return allkeys_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DatanodeRegistrationProto::kDatanodeIDFieldNumber;
const int DatanodeRegistrationProto::kStorageInfoFieldNumber;
const int DatanodeRegistrationProto::kKeysFieldNumber;
const int DatanodeRegistrationProto::kSoftwareVersionFieldNumber;
const int DatanodeRegistrationProto::kMasterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DatanodeRegistrationProto::DatanodeRegistrationProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DatanodeRegistrationProto)
}

void DatanodeRegistrationProto::InitAsDefaultInstance() {
  datanodeid_ = const_cast< ::DatanodeIDProto*>(&::DatanodeIDProto::default_instance());
  storageinfo_ = const_cast< ::StorageInfoProto*>(&::StorageInfoProto::default_instance());
  keys_ = const_cast< ::ExportedBlockKeysProto*>(&::ExportedBlockKeysProto::default_instance());
}

DatanodeRegistrationProto::DatanodeRegistrationProto(const DatanodeRegistrationProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DatanodeRegistrationProto)
}

void DatanodeRegistrationProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  datanodeid_ = NULL;
  storageinfo_ = NULL;
  keys_ = NULL;
  softwareversion_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  master_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DatanodeRegistrationProto::~DatanodeRegistrationProto() {
  // @@protoc_insertion_point(destructor:DatanodeRegistrationProto)
  SharedDtor();
}

void DatanodeRegistrationProto::SharedDtor() {
  softwareversion_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete datanodeid_;
    delete storageinfo_;
    delete keys_;
  }
}

void DatanodeRegistrationProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DatanodeRegistrationProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DatanodeRegistrationProto_descriptor_;
}

const DatanodeRegistrationProto& DatanodeRegistrationProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

DatanodeRegistrationProto* DatanodeRegistrationProto::default_instance_ = NULL;

DatanodeRegistrationProto* DatanodeRegistrationProto::New(::google::protobuf::Arena* arena) const {
  DatanodeRegistrationProto* n = new DatanodeRegistrationProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DatanodeRegistrationProto::Clear() {
// @@protoc_insertion_point(message_clear_start:DatanodeRegistrationProto)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_datanodeid()) {
      if (datanodeid_ != NULL) datanodeid_->::DatanodeIDProto::Clear();
    }
    if (has_storageinfo()) {
      if (storageinfo_ != NULL) storageinfo_->::StorageInfoProto::Clear();
    }
    if (has_keys()) {
      if (keys_ != NULL) keys_->::ExportedBlockKeysProto::Clear();
    }
    if (has_softwareversion()) {
      softwareversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    master_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DatanodeRegistrationProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DatanodeRegistrationProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DatanodeIDProto datanodeID = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_datanodeid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_storageInfo;
        break;
      }

      // optional .StorageInfoProto storageInfo = 2;
      case 2: {
        if (tag == 18) {
         parse_storageInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_storageinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_keys;
        break;
      }

      // optional .ExportedBlockKeysProto keys = 3;
      case 3: {
        if (tag == 26) {
         parse_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_keys()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_softwareVersion;
        break;
      }

      // optional string softwareVersion = 4;
      case 4: {
        if (tag == 34) {
         parse_softwareVersion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_softwareversion()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->softwareversion().data(), this->softwareversion().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "DatanodeRegistrationProto.softwareVersion");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_master;
        break;
      }

      // optional bool master = 5;
      case 5: {
        if (tag == 40) {
         parse_master:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &master_)));
          set_has_master();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DatanodeRegistrationProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DatanodeRegistrationProto)
  return false;
#undef DO_
}

void DatanodeRegistrationProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DatanodeRegistrationProto)
  // required .DatanodeIDProto datanodeID = 1;
  if (has_datanodeid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->datanodeid_, output);
  }

  // optional .StorageInfoProto storageInfo = 2;
  if (has_storageinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->storageinfo_, output);
  }

  // optional .ExportedBlockKeysProto keys = 3;
  if (has_keys()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->keys_, output);
  }

  // optional string softwareVersion = 4;
  if (has_softwareversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->softwareversion().data(), this->softwareversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeRegistrationProto.softwareVersion");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->softwareversion(), output);
  }

  // optional bool master = 5;
  if (has_master()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->master(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DatanodeRegistrationProto)
}

::google::protobuf::uint8* DatanodeRegistrationProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DatanodeRegistrationProto)
  // required .DatanodeIDProto datanodeID = 1;
  if (has_datanodeid()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->datanodeid_, false, target);
  }

  // optional .StorageInfoProto storageInfo = 2;
  if (has_storageinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->storageinfo_, false, target);
  }

  // optional .ExportedBlockKeysProto keys = 3;
  if (has_keys()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->keys_, false, target);
  }

  // optional string softwareVersion = 4;
  if (has_softwareversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->softwareversion().data(), this->softwareversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "DatanodeRegistrationProto.softwareVersion");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->softwareversion(), target);
  }

  // optional bool master = 5;
  if (has_master()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->master(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DatanodeRegistrationProto)
  return target;
}

int DatanodeRegistrationProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DatanodeRegistrationProto)
  int total_size = 0;

  // required .DatanodeIDProto datanodeID = 1;
  if (has_datanodeid()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->datanodeid_);
  }
  if (_has_bits_[1 / 32] & 30u) {
    // optional .StorageInfoProto storageInfo = 2;
    if (has_storageinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->storageinfo_);
    }

    // optional .ExportedBlockKeysProto keys = 3;
    if (has_keys()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->keys_);
    }

    // optional string softwareVersion = 4;
    if (has_softwareversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->softwareversion());
    }

    // optional bool master = 5;
    if (has_master()) {
      total_size += 1 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DatanodeRegistrationProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DatanodeRegistrationProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const DatanodeRegistrationProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DatanodeRegistrationProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DatanodeRegistrationProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DatanodeRegistrationProto)
    MergeFrom(*source);
  }
}

void DatanodeRegistrationProto::MergeFrom(const DatanodeRegistrationProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DatanodeRegistrationProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_datanodeid()) {
      mutable_datanodeid()->::DatanodeIDProto::MergeFrom(from.datanodeid());
    }
    if (from.has_storageinfo()) {
      mutable_storageinfo()->::StorageInfoProto::MergeFrom(from.storageinfo());
    }
    if (from.has_keys()) {
      mutable_keys()->::ExportedBlockKeysProto::MergeFrom(from.keys());
    }
    if (from.has_softwareversion()) {
      set_has_softwareversion();
      softwareversion_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.softwareversion_);
    }
    if (from.has_master()) {
      set_master(from.master());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DatanodeRegistrationProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DatanodeRegistrationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DatanodeRegistrationProto::CopyFrom(const DatanodeRegistrationProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DatanodeRegistrationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatanodeRegistrationProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_datanodeid()) {
    if (!this->datanodeid_->IsInitialized()) return false;
  }
  if (has_storageinfo()) {
    if (!this->storageinfo_->IsInitialized()) return false;
  }
  if (has_keys()) {
    if (!this->keys_->IsInitialized()) return false;
  }
  return true;
}

void DatanodeRegistrationProto::Swap(DatanodeRegistrationProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DatanodeRegistrationProto::InternalSwap(DatanodeRegistrationProto* other) {
  std::swap(datanodeid_, other->datanodeid_);
  std::swap(storageinfo_, other->storageinfo_);
  std::swap(keys_, other->keys_);
  softwareversion_.Swap(&other->softwareversion_);
  std::swap(master_, other->master_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DatanodeRegistrationProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DatanodeRegistrationProto_descriptor_;
  metadata.reflection = DatanodeRegistrationProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DatanodeRegistrationProto

// required .DatanodeIDProto datanodeID = 1;
bool DatanodeRegistrationProto::has_datanodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DatanodeRegistrationProto::set_has_datanodeid() {
  _has_bits_[0] |= 0x00000001u;
}
void DatanodeRegistrationProto::clear_has_datanodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
void DatanodeRegistrationProto::clear_datanodeid() {
  if (datanodeid_ != NULL) datanodeid_->::DatanodeIDProto::Clear();
  clear_has_datanodeid();
}
const ::DatanodeIDProto& DatanodeRegistrationProto::datanodeid() const {
  // @@protoc_insertion_point(field_get:DatanodeRegistrationProto.datanodeID)
  return datanodeid_ != NULL ? *datanodeid_ : *default_instance_->datanodeid_;
}
::DatanodeIDProto* DatanodeRegistrationProto::mutable_datanodeid() {
  set_has_datanodeid();
  if (datanodeid_ == NULL) {
    datanodeid_ = new ::DatanodeIDProto;
  }
  // @@protoc_insertion_point(field_mutable:DatanodeRegistrationProto.datanodeID)
  return datanodeid_;
}
::DatanodeIDProto* DatanodeRegistrationProto::release_datanodeid() {
  // @@protoc_insertion_point(field_release:DatanodeRegistrationProto.datanodeID)
  clear_has_datanodeid();
  ::DatanodeIDProto* temp = datanodeid_;
  datanodeid_ = NULL;
  return temp;
}
void DatanodeRegistrationProto::set_allocated_datanodeid(::DatanodeIDProto* datanodeid) {
  delete datanodeid_;
  datanodeid_ = datanodeid;
  if (datanodeid) {
    set_has_datanodeid();
  } else {
    clear_has_datanodeid();
  }
  // @@protoc_insertion_point(field_set_allocated:DatanodeRegistrationProto.datanodeID)
}

// optional .StorageInfoProto storageInfo = 2;
bool DatanodeRegistrationProto::has_storageinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DatanodeRegistrationProto::set_has_storageinfo() {
  _has_bits_[0] |= 0x00000002u;
}
void DatanodeRegistrationProto::clear_has_storageinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
void DatanodeRegistrationProto::clear_storageinfo() {
  if (storageinfo_ != NULL) storageinfo_->::StorageInfoProto::Clear();
  clear_has_storageinfo();
}
const ::StorageInfoProto& DatanodeRegistrationProto::storageinfo() const {
  // @@protoc_insertion_point(field_get:DatanodeRegistrationProto.storageInfo)
  return storageinfo_ != NULL ? *storageinfo_ : *default_instance_->storageinfo_;
}
::StorageInfoProto* DatanodeRegistrationProto::mutable_storageinfo() {
  set_has_storageinfo();
  if (storageinfo_ == NULL) {
    storageinfo_ = new ::StorageInfoProto;
  }
  // @@protoc_insertion_point(field_mutable:DatanodeRegistrationProto.storageInfo)
  return storageinfo_;
}
::StorageInfoProto* DatanodeRegistrationProto::release_storageinfo() {
  // @@protoc_insertion_point(field_release:DatanodeRegistrationProto.storageInfo)
  clear_has_storageinfo();
  ::StorageInfoProto* temp = storageinfo_;
  storageinfo_ = NULL;
  return temp;
}
void DatanodeRegistrationProto::set_allocated_storageinfo(::StorageInfoProto* storageinfo) {
  delete storageinfo_;
  storageinfo_ = storageinfo;
  if (storageinfo) {
    set_has_storageinfo();
  } else {
    clear_has_storageinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:DatanodeRegistrationProto.storageInfo)
}

// optional .ExportedBlockKeysProto keys = 3;
bool DatanodeRegistrationProto::has_keys() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DatanodeRegistrationProto::set_has_keys() {
  _has_bits_[0] |= 0x00000004u;
}
void DatanodeRegistrationProto::clear_has_keys() {
  _has_bits_[0] &= ~0x00000004u;
}
void DatanodeRegistrationProto::clear_keys() {
  if (keys_ != NULL) keys_->::ExportedBlockKeysProto::Clear();
  clear_has_keys();
}
const ::ExportedBlockKeysProto& DatanodeRegistrationProto::keys() const {
  // @@protoc_insertion_point(field_get:DatanodeRegistrationProto.keys)
  return keys_ != NULL ? *keys_ : *default_instance_->keys_;
}
::ExportedBlockKeysProto* DatanodeRegistrationProto::mutable_keys() {
  set_has_keys();
  if (keys_ == NULL) {
    keys_ = new ::ExportedBlockKeysProto;
  }
  // @@protoc_insertion_point(field_mutable:DatanodeRegistrationProto.keys)
  return keys_;
}
::ExportedBlockKeysProto* DatanodeRegistrationProto::release_keys() {
  // @@protoc_insertion_point(field_release:DatanodeRegistrationProto.keys)
  clear_has_keys();
  ::ExportedBlockKeysProto* temp = keys_;
  keys_ = NULL;
  return temp;
}
void DatanodeRegistrationProto::set_allocated_keys(::ExportedBlockKeysProto* keys) {
  delete keys_;
  keys_ = keys;
  if (keys) {
    set_has_keys();
  } else {
    clear_has_keys();
  }
  // @@protoc_insertion_point(field_set_allocated:DatanodeRegistrationProto.keys)
}

// optional string softwareVersion = 4;
bool DatanodeRegistrationProto::has_softwareversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DatanodeRegistrationProto::set_has_softwareversion() {
  _has_bits_[0] |= 0x00000008u;
}
void DatanodeRegistrationProto::clear_has_softwareversion() {
  _has_bits_[0] &= ~0x00000008u;
}
void DatanodeRegistrationProto::clear_softwareversion() {
  softwareversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_softwareversion();
}
 const ::std::string& DatanodeRegistrationProto::softwareversion() const {
  // @@protoc_insertion_point(field_get:DatanodeRegistrationProto.softwareVersion)
  return softwareversion_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeRegistrationProto::set_softwareversion(const ::std::string& value) {
  set_has_softwareversion();
  softwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeRegistrationProto.softwareVersion)
}
 void DatanodeRegistrationProto::set_softwareversion(const char* value) {
  set_has_softwareversion();
  softwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeRegistrationProto.softwareVersion)
}
 void DatanodeRegistrationProto::set_softwareversion(const char* value, size_t size) {
  set_has_softwareversion();
  softwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeRegistrationProto.softwareVersion)
}
 ::std::string* DatanodeRegistrationProto::mutable_softwareversion() {
  set_has_softwareversion();
  // @@protoc_insertion_point(field_mutable:DatanodeRegistrationProto.softwareVersion)
  return softwareversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DatanodeRegistrationProto::release_softwareversion() {
  // @@protoc_insertion_point(field_release:DatanodeRegistrationProto.softwareVersion)
  clear_has_softwareversion();
  return softwareversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DatanodeRegistrationProto::set_allocated_softwareversion(::std::string* softwareversion) {
  if (softwareversion != NULL) {
    set_has_softwareversion();
  } else {
    clear_has_softwareversion();
  }
  softwareversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), softwareversion);
  // @@protoc_insertion_point(field_set_allocated:DatanodeRegistrationProto.softwareVersion)
}

// optional bool master = 5;
bool DatanodeRegistrationProto::has_master() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void DatanodeRegistrationProto::set_has_master() {
  _has_bits_[0] |= 0x00000010u;
}
void DatanodeRegistrationProto::clear_has_master() {
  _has_bits_[0] &= ~0x00000010u;
}
void DatanodeRegistrationProto::clear_master() {
  master_ = false;
  clear_has_master();
}
 bool DatanodeRegistrationProto::master() const {
  // @@protoc_insertion_point(field_get:DatanodeRegistrationProto.master)
  return master_;
}
 void DatanodeRegistrationProto::set_master(bool value) {
  set_has_master();
  master_ = value;
  // @@protoc_insertion_point(field_set:DatanodeRegistrationProto.master)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegisterDatanodeRequestProto::kRegistrationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegisterDatanodeRequestProto::RegisterDatanodeRequestProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RegisterDatanodeRequestProto)
}

void RegisterDatanodeRequestProto::InitAsDefaultInstance() {
  registration_ = const_cast< ::DatanodeRegistrationProto*>(&::DatanodeRegistrationProto::default_instance());
}

RegisterDatanodeRequestProto::RegisterDatanodeRequestProto(const RegisterDatanodeRequestProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RegisterDatanodeRequestProto)
}

void RegisterDatanodeRequestProto::SharedCtor() {
  _cached_size_ = 0;
  registration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterDatanodeRequestProto::~RegisterDatanodeRequestProto() {
  // @@protoc_insertion_point(destructor:RegisterDatanodeRequestProto)
  SharedDtor();
}

void RegisterDatanodeRequestProto::SharedDtor() {
  if (this != default_instance_) {
    delete registration_;
  }
}

void RegisterDatanodeRequestProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterDatanodeRequestProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterDatanodeRequestProto_descriptor_;
}

const RegisterDatanodeRequestProto& RegisterDatanodeRequestProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

RegisterDatanodeRequestProto* RegisterDatanodeRequestProto::default_instance_ = NULL;

RegisterDatanodeRequestProto* RegisterDatanodeRequestProto::New(::google::protobuf::Arena* arena) const {
  RegisterDatanodeRequestProto* n = new RegisterDatanodeRequestProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegisterDatanodeRequestProto::Clear() {
// @@protoc_insertion_point(message_clear_start:RegisterDatanodeRequestProto)
  if (has_registration()) {
    if (registration_ != NULL) registration_->::DatanodeRegistrationProto::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RegisterDatanodeRequestProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RegisterDatanodeRequestProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DatanodeRegistrationProto registration = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_registration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RegisterDatanodeRequestProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RegisterDatanodeRequestProto)
  return false;
#undef DO_
}

void RegisterDatanodeRequestProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RegisterDatanodeRequestProto)
  // required .DatanodeRegistrationProto registration = 1;
  if (has_registration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->registration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RegisterDatanodeRequestProto)
}

::google::protobuf::uint8* RegisterDatanodeRequestProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RegisterDatanodeRequestProto)
  // required .DatanodeRegistrationProto registration = 1;
  if (has_registration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->registration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RegisterDatanodeRequestProto)
  return target;
}

int RegisterDatanodeRequestProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RegisterDatanodeRequestProto)
  int total_size = 0;

  // required .DatanodeRegistrationProto registration = 1;
  if (has_registration()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->registration_);
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterDatanodeRequestProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RegisterDatanodeRequestProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RegisterDatanodeRequestProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RegisterDatanodeRequestProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RegisterDatanodeRequestProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RegisterDatanodeRequestProto)
    MergeFrom(*source);
  }
}

void RegisterDatanodeRequestProto::MergeFrom(const RegisterDatanodeRequestProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RegisterDatanodeRequestProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_registration()) {
      mutable_registration()->::DatanodeRegistrationProto::MergeFrom(from.registration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RegisterDatanodeRequestProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RegisterDatanodeRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterDatanodeRequestProto::CopyFrom(const RegisterDatanodeRequestProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RegisterDatanodeRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterDatanodeRequestProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_registration()) {
    if (!this->registration_->IsInitialized()) return false;
  }
  return true;
}

void RegisterDatanodeRequestProto::Swap(RegisterDatanodeRequestProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegisterDatanodeRequestProto::InternalSwap(RegisterDatanodeRequestProto* other) {
  std::swap(registration_, other->registration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RegisterDatanodeRequestProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterDatanodeRequestProto_descriptor_;
  metadata.reflection = RegisterDatanodeRequestProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterDatanodeRequestProto

// required .DatanodeRegistrationProto registration = 1;
bool RegisterDatanodeRequestProto::has_registration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RegisterDatanodeRequestProto::set_has_registration() {
  _has_bits_[0] |= 0x00000001u;
}
void RegisterDatanodeRequestProto::clear_has_registration() {
  _has_bits_[0] &= ~0x00000001u;
}
void RegisterDatanodeRequestProto::clear_registration() {
  if (registration_ != NULL) registration_->::DatanodeRegistrationProto::Clear();
  clear_has_registration();
}
const ::DatanodeRegistrationProto& RegisterDatanodeRequestProto::registration() const {
  // @@protoc_insertion_point(field_get:RegisterDatanodeRequestProto.registration)
  return registration_ != NULL ? *registration_ : *default_instance_->registration_;
}
::DatanodeRegistrationProto* RegisterDatanodeRequestProto::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) {
    registration_ = new ::DatanodeRegistrationProto;
  }
  // @@protoc_insertion_point(field_mutable:RegisterDatanodeRequestProto.registration)
  return registration_;
}
::DatanodeRegistrationProto* RegisterDatanodeRequestProto::release_registration() {
  // @@protoc_insertion_point(field_release:RegisterDatanodeRequestProto.registration)
  clear_has_registration();
  ::DatanodeRegistrationProto* temp = registration_;
  registration_ = NULL;
  return temp;
}
void RegisterDatanodeRequestProto::set_allocated_registration(::DatanodeRegistrationProto* registration) {
  delete registration_;
  registration_ = registration;
  if (registration) {
    set_has_registration();
  } else {
    clear_has_registration();
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterDatanodeRequestProto.registration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegisterDatanodeResponseProto::kRegistrationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegisterDatanodeResponseProto::RegisterDatanodeResponseProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RegisterDatanodeResponseProto)
}

void RegisterDatanodeResponseProto::InitAsDefaultInstance() {
  registration_ = const_cast< ::DatanodeRegistrationProto*>(&::DatanodeRegistrationProto::default_instance());
}

RegisterDatanodeResponseProto::RegisterDatanodeResponseProto(const RegisterDatanodeResponseProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RegisterDatanodeResponseProto)
}

void RegisterDatanodeResponseProto::SharedCtor() {
  _cached_size_ = 0;
  registration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterDatanodeResponseProto::~RegisterDatanodeResponseProto() {
  // @@protoc_insertion_point(destructor:RegisterDatanodeResponseProto)
  SharedDtor();
}

void RegisterDatanodeResponseProto::SharedDtor() {
  if (this != default_instance_) {
    delete registration_;
  }
}

void RegisterDatanodeResponseProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterDatanodeResponseProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterDatanodeResponseProto_descriptor_;
}

const RegisterDatanodeResponseProto& RegisterDatanodeResponseProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

RegisterDatanodeResponseProto* RegisterDatanodeResponseProto::default_instance_ = NULL;

RegisterDatanodeResponseProto* RegisterDatanodeResponseProto::New(::google::protobuf::Arena* arena) const {
  RegisterDatanodeResponseProto* n = new RegisterDatanodeResponseProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegisterDatanodeResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:RegisterDatanodeResponseProto)
  if (has_registration()) {
    if (registration_ != NULL) registration_->::DatanodeRegistrationProto::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RegisterDatanodeResponseProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RegisterDatanodeResponseProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DatanodeRegistrationProto registration = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_registration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RegisterDatanodeResponseProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RegisterDatanodeResponseProto)
  return false;
#undef DO_
}

void RegisterDatanodeResponseProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RegisterDatanodeResponseProto)
  // required .DatanodeRegistrationProto registration = 1;
  if (has_registration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->registration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RegisterDatanodeResponseProto)
}

::google::protobuf::uint8* RegisterDatanodeResponseProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RegisterDatanodeResponseProto)
  // required .DatanodeRegistrationProto registration = 1;
  if (has_registration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->registration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RegisterDatanodeResponseProto)
  return target;
}

int RegisterDatanodeResponseProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RegisterDatanodeResponseProto)
  int total_size = 0;

  // required .DatanodeRegistrationProto registration = 1;
  if (has_registration()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->registration_);
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterDatanodeResponseProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RegisterDatanodeResponseProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RegisterDatanodeResponseProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RegisterDatanodeResponseProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RegisterDatanodeResponseProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RegisterDatanodeResponseProto)
    MergeFrom(*source);
  }
}

void RegisterDatanodeResponseProto::MergeFrom(const RegisterDatanodeResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RegisterDatanodeResponseProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_registration()) {
      mutable_registration()->::DatanodeRegistrationProto::MergeFrom(from.registration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RegisterDatanodeResponseProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RegisterDatanodeResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterDatanodeResponseProto::CopyFrom(const RegisterDatanodeResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RegisterDatanodeResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterDatanodeResponseProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_registration()) {
    if (!this->registration_->IsInitialized()) return false;
  }
  return true;
}

void RegisterDatanodeResponseProto::Swap(RegisterDatanodeResponseProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegisterDatanodeResponseProto::InternalSwap(RegisterDatanodeResponseProto* other) {
  std::swap(registration_, other->registration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RegisterDatanodeResponseProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterDatanodeResponseProto_descriptor_;
  metadata.reflection = RegisterDatanodeResponseProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterDatanodeResponseProto

// required .DatanodeRegistrationProto registration = 1;
bool RegisterDatanodeResponseProto::has_registration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RegisterDatanodeResponseProto::set_has_registration() {
  _has_bits_[0] |= 0x00000001u;
}
void RegisterDatanodeResponseProto::clear_has_registration() {
  _has_bits_[0] &= ~0x00000001u;
}
void RegisterDatanodeResponseProto::clear_registration() {
  if (registration_ != NULL) registration_->::DatanodeRegistrationProto::Clear();
  clear_has_registration();
}
const ::DatanodeRegistrationProto& RegisterDatanodeResponseProto::registration() const {
  // @@protoc_insertion_point(field_get:RegisterDatanodeResponseProto.registration)
  return registration_ != NULL ? *registration_ : *default_instance_->registration_;
}
::DatanodeRegistrationProto* RegisterDatanodeResponseProto::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) {
    registration_ = new ::DatanodeRegistrationProto;
  }
  // @@protoc_insertion_point(field_mutable:RegisterDatanodeResponseProto.registration)
  return registration_;
}
::DatanodeRegistrationProto* RegisterDatanodeResponseProto::release_registration() {
  // @@protoc_insertion_point(field_release:RegisterDatanodeResponseProto.registration)
  clear_has_registration();
  ::DatanodeRegistrationProto* temp = registration_;
  registration_ = NULL;
  return temp;
}
void RegisterDatanodeResponseProto::set_allocated_registration(::DatanodeRegistrationProto* registration) {
  delete registration_;
  registration_ = registration;
  if (registration) {
    set_has_registration();
  } else {
    clear_has_registration();
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterDatanodeResponseProto.registration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DatanodeHeartbeatRequestProto::kIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DatanodeHeartbeatRequestProto::DatanodeHeartbeatRequestProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DatanodeHeartbeatRequestProto)
}

void DatanodeHeartbeatRequestProto::InitAsDefaultInstance() {
  id_ = const_cast< ::DatanodeIDProto*>(&::DatanodeIDProto::default_instance());
}

DatanodeHeartbeatRequestProto::DatanodeHeartbeatRequestProto(const DatanodeHeartbeatRequestProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DatanodeHeartbeatRequestProto)
}

void DatanodeHeartbeatRequestProto::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DatanodeHeartbeatRequestProto::~DatanodeHeartbeatRequestProto() {
  // @@protoc_insertion_point(destructor:DatanodeHeartbeatRequestProto)
  SharedDtor();
}

void DatanodeHeartbeatRequestProto::SharedDtor() {
  if (this != default_instance_) {
    delete id_;
  }
}

void DatanodeHeartbeatRequestProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DatanodeHeartbeatRequestProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DatanodeHeartbeatRequestProto_descriptor_;
}

const DatanodeHeartbeatRequestProto& DatanodeHeartbeatRequestProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

DatanodeHeartbeatRequestProto* DatanodeHeartbeatRequestProto::default_instance_ = NULL;

DatanodeHeartbeatRequestProto* DatanodeHeartbeatRequestProto::New(::google::protobuf::Arena* arena) const {
  DatanodeHeartbeatRequestProto* n = new DatanodeHeartbeatRequestProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DatanodeHeartbeatRequestProto::Clear() {
// @@protoc_insertion_point(message_clear_start:DatanodeHeartbeatRequestProto)
  if (has_id()) {
    if (id_ != NULL) id_->::DatanodeIDProto::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DatanodeHeartbeatRequestProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DatanodeHeartbeatRequestProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .DatanodeIDProto id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DatanodeHeartbeatRequestProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DatanodeHeartbeatRequestProto)
  return false;
#undef DO_
}

void DatanodeHeartbeatRequestProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DatanodeHeartbeatRequestProto)
  // required .DatanodeIDProto id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->id_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DatanodeHeartbeatRequestProto)
}

::google::protobuf::uint8* DatanodeHeartbeatRequestProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DatanodeHeartbeatRequestProto)
  // required .DatanodeIDProto id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->id_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DatanodeHeartbeatRequestProto)
  return target;
}

int DatanodeHeartbeatRequestProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DatanodeHeartbeatRequestProto)
  int total_size = 0;

  // required .DatanodeIDProto id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->id_);
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DatanodeHeartbeatRequestProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DatanodeHeartbeatRequestProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const DatanodeHeartbeatRequestProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DatanodeHeartbeatRequestProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DatanodeHeartbeatRequestProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DatanodeHeartbeatRequestProto)
    MergeFrom(*source);
  }
}

void DatanodeHeartbeatRequestProto::MergeFrom(const DatanodeHeartbeatRequestProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DatanodeHeartbeatRequestProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::DatanodeIDProto::MergeFrom(from.id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DatanodeHeartbeatRequestProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DatanodeHeartbeatRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DatanodeHeartbeatRequestProto::CopyFrom(const DatanodeHeartbeatRequestProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DatanodeHeartbeatRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatanodeHeartbeatRequestProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_id()) {
    if (!this->id_->IsInitialized()) return false;
  }
  return true;
}

void DatanodeHeartbeatRequestProto::Swap(DatanodeHeartbeatRequestProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DatanodeHeartbeatRequestProto::InternalSwap(DatanodeHeartbeatRequestProto* other) {
  std::swap(id_, other->id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DatanodeHeartbeatRequestProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DatanodeHeartbeatRequestProto_descriptor_;
  metadata.reflection = DatanodeHeartbeatRequestProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DatanodeHeartbeatRequestProto

// required .DatanodeIDProto id = 1;
bool DatanodeHeartbeatRequestProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DatanodeHeartbeatRequestProto::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void DatanodeHeartbeatRequestProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void DatanodeHeartbeatRequestProto::clear_id() {
  if (id_ != NULL) id_->::DatanodeIDProto::Clear();
  clear_has_id();
}
const ::DatanodeIDProto& DatanodeHeartbeatRequestProto::id() const {
  // @@protoc_insertion_point(field_get:DatanodeHeartbeatRequestProto.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
::DatanodeIDProto* DatanodeHeartbeatRequestProto::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::DatanodeIDProto;
  }
  // @@protoc_insertion_point(field_mutable:DatanodeHeartbeatRequestProto.id)
  return id_;
}
::DatanodeIDProto* DatanodeHeartbeatRequestProto::release_id() {
  // @@protoc_insertion_point(field_release:DatanodeHeartbeatRequestProto.id)
  clear_has_id();
  ::DatanodeIDProto* temp = id_;
  id_ = NULL;
  return temp;
}
void DatanodeHeartbeatRequestProto::set_allocated_id(::DatanodeIDProto* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:DatanodeHeartbeatRequestProto.id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DatanodeHeartbeatResponseProto::DatanodeHeartbeatResponseProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DatanodeHeartbeatResponseProto)
}

void DatanodeHeartbeatResponseProto::InitAsDefaultInstance() {
}

DatanodeHeartbeatResponseProto::DatanodeHeartbeatResponseProto(const DatanodeHeartbeatResponseProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DatanodeHeartbeatResponseProto)
}

void DatanodeHeartbeatResponseProto::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DatanodeHeartbeatResponseProto::~DatanodeHeartbeatResponseProto() {
  // @@protoc_insertion_point(destructor:DatanodeHeartbeatResponseProto)
  SharedDtor();
}

void DatanodeHeartbeatResponseProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DatanodeHeartbeatResponseProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DatanodeHeartbeatResponseProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DatanodeHeartbeatResponseProto_descriptor_;
}

const DatanodeHeartbeatResponseProto& DatanodeHeartbeatResponseProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

DatanodeHeartbeatResponseProto* DatanodeHeartbeatResponseProto::default_instance_ = NULL;

DatanodeHeartbeatResponseProto* DatanodeHeartbeatResponseProto::New(::google::protobuf::Arena* arena) const {
  DatanodeHeartbeatResponseProto* n = new DatanodeHeartbeatResponseProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DatanodeHeartbeatResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:DatanodeHeartbeatResponseProto)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DatanodeHeartbeatResponseProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DatanodeHeartbeatResponseProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:DatanodeHeartbeatResponseProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DatanodeHeartbeatResponseProto)
  return false;
#undef DO_
}

void DatanodeHeartbeatResponseProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DatanodeHeartbeatResponseProto)
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DatanodeHeartbeatResponseProto)
}

::google::protobuf::uint8* DatanodeHeartbeatResponseProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DatanodeHeartbeatResponseProto)
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DatanodeHeartbeatResponseProto)
  return target;
}

int DatanodeHeartbeatResponseProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DatanodeHeartbeatResponseProto)
  int total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DatanodeHeartbeatResponseProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DatanodeHeartbeatResponseProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const DatanodeHeartbeatResponseProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DatanodeHeartbeatResponseProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DatanodeHeartbeatResponseProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DatanodeHeartbeatResponseProto)
    MergeFrom(*source);
  }
}

void DatanodeHeartbeatResponseProto::MergeFrom(const DatanodeHeartbeatResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DatanodeHeartbeatResponseProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DatanodeHeartbeatResponseProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DatanodeHeartbeatResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DatanodeHeartbeatResponseProto::CopyFrom(const DatanodeHeartbeatResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DatanodeHeartbeatResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatanodeHeartbeatResponseProto::IsInitialized() const {

  return true;
}

void DatanodeHeartbeatResponseProto::Swap(DatanodeHeartbeatResponseProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DatanodeHeartbeatResponseProto::InternalSwap(DatanodeHeartbeatResponseProto* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DatanodeHeartbeatResponseProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DatanodeHeartbeatResponseProto_descriptor_;
  metadata.reflection = DatanodeHeartbeatResponseProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DatanodeHeartbeatResponseProto

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DataTransferTraceInfoProto::kTraceIdFieldNumber;
const int DataTransferTraceInfoProto::kParentIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DataTransferTraceInfoProto::DataTransferTraceInfoProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DataTransferTraceInfoProto)
}

void DataTransferTraceInfoProto::InitAsDefaultInstance() {
}

DataTransferTraceInfoProto::DataTransferTraceInfoProto(const DataTransferTraceInfoProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DataTransferTraceInfoProto)
}

void DataTransferTraceInfoProto::SharedCtor() {
  _cached_size_ = 0;
  traceid_ = GOOGLE_ULONGLONG(0);
  parentid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataTransferTraceInfoProto::~DataTransferTraceInfoProto() {
  // @@protoc_insertion_point(destructor:DataTransferTraceInfoProto)
  SharedDtor();
}

void DataTransferTraceInfoProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DataTransferTraceInfoProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DataTransferTraceInfoProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataTransferTraceInfoProto_descriptor_;
}

const DataTransferTraceInfoProto& DataTransferTraceInfoProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

DataTransferTraceInfoProto* DataTransferTraceInfoProto::default_instance_ = NULL;

DataTransferTraceInfoProto* DataTransferTraceInfoProto::New(::google::protobuf::Arena* arena) const {
  DataTransferTraceInfoProto* n = new DataTransferTraceInfoProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DataTransferTraceInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:DataTransferTraceInfoProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(DataTransferTraceInfoProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DataTransferTraceInfoProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(traceid_, parentid_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DataTransferTraceInfoProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DataTransferTraceInfoProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 traceId = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &traceid_)));
          set_has_traceid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_parentId;
        break;
      }

      // required uint64 parentId = 2;
      case 2: {
        if (tag == 16) {
         parse_parentId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &parentid_)));
          set_has_parentid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DataTransferTraceInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DataTransferTraceInfoProto)
  return false;
#undef DO_
}

void DataTransferTraceInfoProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DataTransferTraceInfoProto)
  // required uint64 traceId = 1;
  if (has_traceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->traceid(), output);
  }

  // required uint64 parentId = 2;
  if (has_parentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->parentid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DataTransferTraceInfoProto)
}

::google::protobuf::uint8* DataTransferTraceInfoProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DataTransferTraceInfoProto)
  // required uint64 traceId = 1;
  if (has_traceid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->traceid(), target);
  }

  // required uint64 parentId = 2;
  if (has_parentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->parentid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DataTransferTraceInfoProto)
  return target;
}

int DataTransferTraceInfoProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:DataTransferTraceInfoProto)
  int total_size = 0;

  if (has_traceid()) {
    // required uint64 traceId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->traceid());
  }

  if (has_parentid()) {
    // required uint64 parentId = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->parentid());
  }

  return total_size;
}
int DataTransferTraceInfoProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:DataTransferTraceInfoProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 traceId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->traceid());

    // required uint64 parentId = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->parentid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataTransferTraceInfoProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:DataTransferTraceInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const DataTransferTraceInfoProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DataTransferTraceInfoProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:DataTransferTraceInfoProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:DataTransferTraceInfoProto)
    MergeFrom(*source);
  }
}

void DataTransferTraceInfoProto::MergeFrom(const DataTransferTraceInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DataTransferTraceInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_traceid()) {
      set_traceid(from.traceid());
    }
    if (from.has_parentid()) {
      set_parentid(from.parentid());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DataTransferTraceInfoProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:DataTransferTraceInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataTransferTraceInfoProto::CopyFrom(const DataTransferTraceInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DataTransferTraceInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataTransferTraceInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DataTransferTraceInfoProto::Swap(DataTransferTraceInfoProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DataTransferTraceInfoProto::InternalSwap(DataTransferTraceInfoProto* other) {
  std::swap(traceid_, other->traceid_);
  std::swap(parentid_, other->parentid_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DataTransferTraceInfoProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DataTransferTraceInfoProto_descriptor_;
  metadata.reflection = DataTransferTraceInfoProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DataTransferTraceInfoProto

// required uint64 traceId = 1;
bool DataTransferTraceInfoProto::has_traceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DataTransferTraceInfoProto::set_has_traceid() {
  _has_bits_[0] |= 0x00000001u;
}
void DataTransferTraceInfoProto::clear_has_traceid() {
  _has_bits_[0] &= ~0x00000001u;
}
void DataTransferTraceInfoProto::clear_traceid() {
  traceid_ = GOOGLE_ULONGLONG(0);
  clear_has_traceid();
}
 ::google::protobuf::uint64 DataTransferTraceInfoProto::traceid() const {
  // @@protoc_insertion_point(field_get:DataTransferTraceInfoProto.traceId)
  return traceid_;
}
 void DataTransferTraceInfoProto::set_traceid(::google::protobuf::uint64 value) {
  set_has_traceid();
  traceid_ = value;
  // @@protoc_insertion_point(field_set:DataTransferTraceInfoProto.traceId)
}

// required uint64 parentId = 2;
bool DataTransferTraceInfoProto::has_parentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DataTransferTraceInfoProto::set_has_parentid() {
  _has_bits_[0] |= 0x00000002u;
}
void DataTransferTraceInfoProto::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000002u;
}
void DataTransferTraceInfoProto::clear_parentid() {
  parentid_ = GOOGLE_ULONGLONG(0);
  clear_has_parentid();
}
 ::google::protobuf::uint64 DataTransferTraceInfoProto::parentid() const {
  // @@protoc_insertion_point(field_get:DataTransferTraceInfoProto.parentId)
  return parentid_;
}
 void DataTransferTraceInfoProto::set_parentid(::google::protobuf::uint64 value) {
  set_has_parentid();
  parentid_ = value;
  // @@protoc_insertion_point(field_set:DataTransferTraceInfoProto.parentId)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BaseHeaderProto::kBlockFieldNumber;
const int BaseHeaderProto::kTokenFieldNumber;
const int BaseHeaderProto::kTraceInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BaseHeaderProto::BaseHeaderProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:BaseHeaderProto)
}

void BaseHeaderProto::InitAsDefaultInstance() {
  block_ = const_cast< ::ExtendedBlockProto*>(&::ExtendedBlockProto::default_instance());
  token_ = const_cast< ::TokenProto*>(&::TokenProto::default_instance());
  traceinfo_ = const_cast< ::DataTransferTraceInfoProto*>(&::DataTransferTraceInfoProto::default_instance());
}

BaseHeaderProto::BaseHeaderProto(const BaseHeaderProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:BaseHeaderProto)
}

void BaseHeaderProto::SharedCtor() {
  _cached_size_ = 0;
  block_ = NULL;
  token_ = NULL;
  traceinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BaseHeaderProto::~BaseHeaderProto() {
  // @@protoc_insertion_point(destructor:BaseHeaderProto)
  SharedDtor();
}

void BaseHeaderProto::SharedDtor() {
  if (this != default_instance_) {
    delete block_;
    delete token_;
    delete traceinfo_;
  }
}

void BaseHeaderProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BaseHeaderProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BaseHeaderProto_descriptor_;
}

const BaseHeaderProto& BaseHeaderProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

BaseHeaderProto* BaseHeaderProto::default_instance_ = NULL;

BaseHeaderProto* BaseHeaderProto::New(::google::protobuf::Arena* arena) const {
  BaseHeaderProto* n = new BaseHeaderProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BaseHeaderProto::Clear() {
// @@protoc_insertion_point(message_clear_start:BaseHeaderProto)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_block()) {
      if (block_ != NULL) block_->::ExtendedBlockProto::Clear();
    }
    if (has_token()) {
      if (token_ != NULL) token_->::TokenProto::Clear();
    }
    if (has_traceinfo()) {
      if (traceinfo_ != NULL) traceinfo_->::DataTransferTraceInfoProto::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BaseHeaderProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:BaseHeaderProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ExtendedBlockProto block = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_block()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_token;
        break;
      }

      // optional .TokenProto token = 2;
      case 2: {
        if (tag == 18) {
         parse_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_token()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_traceInfo;
        break;
      }

      // optional .DataTransferTraceInfoProto traceInfo = 3;
      case 3: {
        if (tag == 26) {
         parse_traceInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_traceinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:BaseHeaderProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:BaseHeaderProto)
  return false;
#undef DO_
}

void BaseHeaderProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:BaseHeaderProto)
  // required .ExtendedBlockProto block = 1;
  if (has_block()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->block_, output);
  }

  // optional .TokenProto token = 2;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->token_, output);
  }

  // optional .DataTransferTraceInfoProto traceInfo = 3;
  if (has_traceinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->traceinfo_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:BaseHeaderProto)
}

::google::protobuf::uint8* BaseHeaderProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:BaseHeaderProto)
  // required .ExtendedBlockProto block = 1;
  if (has_block()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->block_, false, target);
  }

  // optional .TokenProto token = 2;
  if (has_token()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->token_, false, target);
  }

  // optional .DataTransferTraceInfoProto traceInfo = 3;
  if (has_traceinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->traceinfo_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BaseHeaderProto)
  return target;
}

int BaseHeaderProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:BaseHeaderProto)
  int total_size = 0;

  // required .ExtendedBlockProto block = 1;
  if (has_block()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->block_);
  }
  if (_has_bits_[1 / 32] & 6u) {
    // optional .TokenProto token = 2;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->token_);
    }

    // optional .DataTransferTraceInfoProto traceInfo = 3;
    if (has_traceinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->traceinfo_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BaseHeaderProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:BaseHeaderProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const BaseHeaderProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BaseHeaderProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:BaseHeaderProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:BaseHeaderProto)
    MergeFrom(*source);
  }
}

void BaseHeaderProto::MergeFrom(const BaseHeaderProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:BaseHeaderProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_block()) {
      mutable_block()->::ExtendedBlockProto::MergeFrom(from.block());
    }
    if (from.has_token()) {
      mutable_token()->::TokenProto::MergeFrom(from.token());
    }
    if (from.has_traceinfo()) {
      mutable_traceinfo()->::DataTransferTraceInfoProto::MergeFrom(from.traceinfo());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BaseHeaderProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:BaseHeaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BaseHeaderProto::CopyFrom(const BaseHeaderProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BaseHeaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BaseHeaderProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_block()) {
    if (!this->block_->IsInitialized()) return false;
  }
  if (has_token()) {
    if (!this->token_->IsInitialized()) return false;
  }
  if (has_traceinfo()) {
    if (!this->traceinfo_->IsInitialized()) return false;
  }
  return true;
}

void BaseHeaderProto::Swap(BaseHeaderProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BaseHeaderProto::InternalSwap(BaseHeaderProto* other) {
  std::swap(block_, other->block_);
  std::swap(token_, other->token_);
  std::swap(traceinfo_, other->traceinfo_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BaseHeaderProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BaseHeaderProto_descriptor_;
  metadata.reflection = BaseHeaderProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BaseHeaderProto

// required .ExtendedBlockProto block = 1;
bool BaseHeaderProto::has_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BaseHeaderProto::set_has_block() {
  _has_bits_[0] |= 0x00000001u;
}
void BaseHeaderProto::clear_has_block() {
  _has_bits_[0] &= ~0x00000001u;
}
void BaseHeaderProto::clear_block() {
  if (block_ != NULL) block_->::ExtendedBlockProto::Clear();
  clear_has_block();
}
const ::ExtendedBlockProto& BaseHeaderProto::block() const {
  // @@protoc_insertion_point(field_get:BaseHeaderProto.block)
  return block_ != NULL ? *block_ : *default_instance_->block_;
}
::ExtendedBlockProto* BaseHeaderProto::mutable_block() {
  set_has_block();
  if (block_ == NULL) {
    block_ = new ::ExtendedBlockProto;
  }
  // @@protoc_insertion_point(field_mutable:BaseHeaderProto.block)
  return block_;
}
::ExtendedBlockProto* BaseHeaderProto::release_block() {
  // @@protoc_insertion_point(field_release:BaseHeaderProto.block)
  clear_has_block();
  ::ExtendedBlockProto* temp = block_;
  block_ = NULL;
  return temp;
}
void BaseHeaderProto::set_allocated_block(::ExtendedBlockProto* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
  // @@protoc_insertion_point(field_set_allocated:BaseHeaderProto.block)
}

// optional .TokenProto token = 2;
bool BaseHeaderProto::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void BaseHeaderProto::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
void BaseHeaderProto::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
void BaseHeaderProto::clear_token() {
  if (token_ != NULL) token_->::TokenProto::Clear();
  clear_has_token();
}
const ::TokenProto& BaseHeaderProto::token() const {
  // @@protoc_insertion_point(field_get:BaseHeaderProto.token)
  return token_ != NULL ? *token_ : *default_instance_->token_;
}
::TokenProto* BaseHeaderProto::mutable_token() {
  set_has_token();
  if (token_ == NULL) {
    token_ = new ::TokenProto;
  }
  // @@protoc_insertion_point(field_mutable:BaseHeaderProto.token)
  return token_;
}
::TokenProto* BaseHeaderProto::release_token() {
  // @@protoc_insertion_point(field_release:BaseHeaderProto.token)
  clear_has_token();
  ::TokenProto* temp = token_;
  token_ = NULL;
  return temp;
}
void BaseHeaderProto::set_allocated_token(::TokenProto* token) {
  delete token_;
  token_ = token;
  if (token) {
    set_has_token();
  } else {
    clear_has_token();
  }
  // @@protoc_insertion_point(field_set_allocated:BaseHeaderProto.token)
}

// optional .DataTransferTraceInfoProto traceInfo = 3;
bool BaseHeaderProto::has_traceinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void BaseHeaderProto::set_has_traceinfo() {
  _has_bits_[0] |= 0x00000004u;
}
void BaseHeaderProto::clear_has_traceinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
void BaseHeaderProto::clear_traceinfo() {
  if (traceinfo_ != NULL) traceinfo_->::DataTransferTraceInfoProto::Clear();
  clear_has_traceinfo();
}
const ::DataTransferTraceInfoProto& BaseHeaderProto::traceinfo() const {
  // @@protoc_insertion_point(field_get:BaseHeaderProto.traceInfo)
  return traceinfo_ != NULL ? *traceinfo_ : *default_instance_->traceinfo_;
}
::DataTransferTraceInfoProto* BaseHeaderProto::mutable_traceinfo() {
  set_has_traceinfo();
  if (traceinfo_ == NULL) {
    traceinfo_ = new ::DataTransferTraceInfoProto;
  }
  // @@protoc_insertion_point(field_mutable:BaseHeaderProto.traceInfo)
  return traceinfo_;
}
::DataTransferTraceInfoProto* BaseHeaderProto::release_traceinfo() {
  // @@protoc_insertion_point(field_release:BaseHeaderProto.traceInfo)
  clear_has_traceinfo();
  ::DataTransferTraceInfoProto* temp = traceinfo_;
  traceinfo_ = NULL;
  return temp;
}
void BaseHeaderProto::set_allocated_traceinfo(::DataTransferTraceInfoProto* traceinfo) {
  delete traceinfo_;
  traceinfo_ = traceinfo;
  if (traceinfo) {
    set_has_traceinfo();
  } else {
    clear_has_traceinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:BaseHeaderProto.traceInfo)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClientOperationHeaderProto::kBaseHeaderFieldNumber;
const int ClientOperationHeaderProto::kClientNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClientOperationHeaderProto::ClientOperationHeaderProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ClientOperationHeaderProto)
}

void ClientOperationHeaderProto::InitAsDefaultInstance() {
  baseheader_ = const_cast< ::BaseHeaderProto*>(&::BaseHeaderProto::default_instance());
}

ClientOperationHeaderProto::ClientOperationHeaderProto(const ClientOperationHeaderProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ClientOperationHeaderProto)
}

void ClientOperationHeaderProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  baseheader_ = NULL;
  clientname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientOperationHeaderProto::~ClientOperationHeaderProto() {
  // @@protoc_insertion_point(destructor:ClientOperationHeaderProto)
  SharedDtor();
}

void ClientOperationHeaderProto::SharedDtor() {
  clientname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete baseheader_;
  }
}

void ClientOperationHeaderProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientOperationHeaderProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientOperationHeaderProto_descriptor_;
}

const ClientOperationHeaderProto& ClientOperationHeaderProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

ClientOperationHeaderProto* ClientOperationHeaderProto::default_instance_ = NULL;

ClientOperationHeaderProto* ClientOperationHeaderProto::New(::google::protobuf::Arena* arena) const {
  ClientOperationHeaderProto* n = new ClientOperationHeaderProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClientOperationHeaderProto::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientOperationHeaderProto)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_baseheader()) {
      if (baseheader_ != NULL) baseheader_->::BaseHeaderProto::Clear();
    }
    if (has_clientname()) {
      clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ClientOperationHeaderProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ClientOperationHeaderProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .BaseHeaderProto baseHeader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baseheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_clientName;
        break;
      }

      // required string clientName = 2;
      case 2: {
        if (tag == 18) {
         parse_clientName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clientname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->clientname().data(), this->clientname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ClientOperationHeaderProto.clientName");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ClientOperationHeaderProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ClientOperationHeaderProto)
  return false;
#undef DO_
}

void ClientOperationHeaderProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ClientOperationHeaderProto)
  // required .BaseHeaderProto baseHeader = 1;
  if (has_baseheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->baseheader_, output);
  }

  // required string clientName = 2;
  if (has_clientname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->clientname().data(), this->clientname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ClientOperationHeaderProto.clientName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->clientname(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ClientOperationHeaderProto)
}

::google::protobuf::uint8* ClientOperationHeaderProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientOperationHeaderProto)
  // required .BaseHeaderProto baseHeader = 1;
  if (has_baseheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->baseheader_, false, target);
  }

  // required string clientName = 2;
  if (has_clientname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->clientname().data(), this->clientname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ClientOperationHeaderProto.clientName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->clientname(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientOperationHeaderProto)
  return target;
}

int ClientOperationHeaderProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ClientOperationHeaderProto)
  int total_size = 0;

  if (has_baseheader()) {
    // required .BaseHeaderProto baseHeader = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->baseheader_);
  }

  if (has_clientname()) {
    // required string clientName = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->clientname());
  }

  return total_size;
}
int ClientOperationHeaderProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:ClientOperationHeaderProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .BaseHeaderProto baseHeader = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->baseheader_);

    // required string clientName = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->clientname());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientOperationHeaderProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ClientOperationHeaderProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ClientOperationHeaderProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ClientOperationHeaderProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ClientOperationHeaderProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ClientOperationHeaderProto)
    MergeFrom(*source);
  }
}

void ClientOperationHeaderProto::MergeFrom(const ClientOperationHeaderProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ClientOperationHeaderProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_baseheader()) {
      mutable_baseheader()->::BaseHeaderProto::MergeFrom(from.baseheader());
    }
    if (from.has_clientname()) {
      set_has_clientname();
      clientname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.clientname_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ClientOperationHeaderProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ClientOperationHeaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientOperationHeaderProto::CopyFrom(const ClientOperationHeaderProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientOperationHeaderProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientOperationHeaderProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_baseheader()) {
    if (!this->baseheader_->IsInitialized()) return false;
  }
  return true;
}

void ClientOperationHeaderProto::Swap(ClientOperationHeaderProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClientOperationHeaderProto::InternalSwap(ClientOperationHeaderProto* other) {
  std::swap(baseheader_, other->baseheader_);
  clientname_.Swap(&other->clientname_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ClientOperationHeaderProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientOperationHeaderProto_descriptor_;
  metadata.reflection = ClientOperationHeaderProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientOperationHeaderProto

// required .BaseHeaderProto baseHeader = 1;
bool ClientOperationHeaderProto::has_baseheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ClientOperationHeaderProto::set_has_baseheader() {
  _has_bits_[0] |= 0x00000001u;
}
void ClientOperationHeaderProto::clear_has_baseheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void ClientOperationHeaderProto::clear_baseheader() {
  if (baseheader_ != NULL) baseheader_->::BaseHeaderProto::Clear();
  clear_has_baseheader();
}
const ::BaseHeaderProto& ClientOperationHeaderProto::baseheader() const {
  // @@protoc_insertion_point(field_get:ClientOperationHeaderProto.baseHeader)
  return baseheader_ != NULL ? *baseheader_ : *default_instance_->baseheader_;
}
::BaseHeaderProto* ClientOperationHeaderProto::mutable_baseheader() {
  set_has_baseheader();
  if (baseheader_ == NULL) {
    baseheader_ = new ::BaseHeaderProto;
  }
  // @@protoc_insertion_point(field_mutable:ClientOperationHeaderProto.baseHeader)
  return baseheader_;
}
::BaseHeaderProto* ClientOperationHeaderProto::release_baseheader() {
  // @@protoc_insertion_point(field_release:ClientOperationHeaderProto.baseHeader)
  clear_has_baseheader();
  ::BaseHeaderProto* temp = baseheader_;
  baseheader_ = NULL;
  return temp;
}
void ClientOperationHeaderProto::set_allocated_baseheader(::BaseHeaderProto* baseheader) {
  delete baseheader_;
  baseheader_ = baseheader;
  if (baseheader) {
    set_has_baseheader();
  } else {
    clear_has_baseheader();
  }
  // @@protoc_insertion_point(field_set_allocated:ClientOperationHeaderProto.baseHeader)
}

// required string clientName = 2;
bool ClientOperationHeaderProto::has_clientname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ClientOperationHeaderProto::set_has_clientname() {
  _has_bits_[0] |= 0x00000002u;
}
void ClientOperationHeaderProto::clear_has_clientname() {
  _has_bits_[0] &= ~0x00000002u;
}
void ClientOperationHeaderProto::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientname();
}
 const ::std::string& ClientOperationHeaderProto::clientname() const {
  // @@protoc_insertion_point(field_get:ClientOperationHeaderProto.clientName)
  return clientname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ClientOperationHeaderProto::set_clientname(const ::std::string& value) {
  set_has_clientname();
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ClientOperationHeaderProto.clientName)
}
 void ClientOperationHeaderProto::set_clientname(const char* value) {
  set_has_clientname();
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ClientOperationHeaderProto.clientName)
}
 void ClientOperationHeaderProto::set_clientname(const char* value, size_t size) {
  set_has_clientname();
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ClientOperationHeaderProto.clientName)
}
 ::std::string* ClientOperationHeaderProto::mutable_clientname() {
  set_has_clientname();
  // @@protoc_insertion_point(field_mutable:ClientOperationHeaderProto.clientName)
  return clientname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ClientOperationHeaderProto::release_clientname() {
  // @@protoc_insertion_point(field_release:ClientOperationHeaderProto.clientName)
  clear_has_clientname();
  return clientname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ClientOperationHeaderProto::set_allocated_clientname(::std::string* clientname) {
  if (clientname != NULL) {
    set_has_clientname();
  } else {
    clear_has_clientname();
  }
  clientname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:ClientOperationHeaderProto.clientName)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OpTransferBlockProto::kHeaderFieldNumber;
const int OpTransferBlockProto::kTargetsFieldNumber;
const int OpTransferBlockProto::kTargetStorageTypesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OpTransferBlockProto::OpTransferBlockProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:OpTransferBlockProto)
}

void OpTransferBlockProto::InitAsDefaultInstance() {
  header_ = const_cast< ::ClientOperationHeaderProto*>(&::ClientOperationHeaderProto::default_instance());
}

OpTransferBlockProto::OpTransferBlockProto(const OpTransferBlockProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:OpTransferBlockProto)
}

void OpTransferBlockProto::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpTransferBlockProto::~OpTransferBlockProto() {
  // @@protoc_insertion_point(destructor:OpTransferBlockProto)
  SharedDtor();
}

void OpTransferBlockProto::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void OpTransferBlockProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OpTransferBlockProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OpTransferBlockProto_descriptor_;
}

const OpTransferBlockProto& OpTransferBlockProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

OpTransferBlockProto* OpTransferBlockProto::default_instance_ = NULL;

OpTransferBlockProto* OpTransferBlockProto::New(::google::protobuf::Arena* arena) const {
  OpTransferBlockProto* n = new OpTransferBlockProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OpTransferBlockProto::Clear() {
// @@protoc_insertion_point(message_clear_start:OpTransferBlockProto)
  if (has_header()) {
    if (header_ != NULL) header_->::ClientOperationHeaderProto::Clear();
  }
  targets_.Clear();
  targetstoragetypes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool OpTransferBlockProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:OpTransferBlockProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ClientOperationHeaderProto header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_targets;
        break;
      }

      // repeated .DatanodeInfoProto targets = 2;
      case 2: {
        if (tag == 18) {
         parse_targets:
          DO_(input->IncrementRecursionDepth());
         parse_loop_targets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_targets()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_targets;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(24)) goto parse_targetStorageTypes;
        break;
      }

      // repeated .StorageTypeProto targetStorageTypes = 3;
      case 3: {
        if (tag == 24) {
         parse_targetStorageTypes:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::StorageTypeProto_IsValid(value)) {
            add_targetstoragetypes(static_cast< ::StorageTypeProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 3,
                 ::StorageTypeProto_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_targetstoragetypes())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_targetStorageTypes;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:OpTransferBlockProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:OpTransferBlockProto)
  return false;
#undef DO_
}

void OpTransferBlockProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:OpTransferBlockProto)
  // required .ClientOperationHeaderProto header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .DatanodeInfoProto targets = 2;
  for (unsigned int i = 0, n = this->targets_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->targets(i), output);
  }

  // repeated .StorageTypeProto targetStorageTypes = 3;
  for (int i = 0; i < this->targetstoragetypes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->targetstoragetypes(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:OpTransferBlockProto)
}

::google::protobuf::uint8* OpTransferBlockProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:OpTransferBlockProto)
  // required .ClientOperationHeaderProto header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, false, target);
  }

  // repeated .DatanodeInfoProto targets = 2;
  for (unsigned int i = 0, n = this->targets_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->targets(i), false, target);
  }

  // repeated .StorageTypeProto targetStorageTypes = 3;
  for (int i = 0; i < this->targetstoragetypes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->targetstoragetypes(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OpTransferBlockProto)
  return target;
}

int OpTransferBlockProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:OpTransferBlockProto)
  int total_size = 0;

  // required .ClientOperationHeaderProto header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }
  // repeated .DatanodeInfoProto targets = 2;
  total_size += 1 * this->targets_size();
  for (int i = 0; i < this->targets_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->targets(i));
  }

  // repeated .StorageTypeProto targetStorageTypes = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->targetstoragetypes_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->targetstoragetypes(i));
    }
    total_size += 1 * this->targetstoragetypes_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpTransferBlockProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:OpTransferBlockProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const OpTransferBlockProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const OpTransferBlockProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:OpTransferBlockProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:OpTransferBlockProto)
    MergeFrom(*source);
  }
}

void OpTransferBlockProto::MergeFrom(const OpTransferBlockProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:OpTransferBlockProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  targets_.MergeFrom(from.targets_);
  targetstoragetypes_.MergeFrom(from.targetstoragetypes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::ClientOperationHeaderProto::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void OpTransferBlockProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:OpTransferBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OpTransferBlockProto::CopyFrom(const OpTransferBlockProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OpTransferBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpTransferBlockProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_header()) {
    if (!this->header_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->targets())) return false;
  return true;
}

void OpTransferBlockProto::Swap(OpTransferBlockProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OpTransferBlockProto::InternalSwap(OpTransferBlockProto* other) {
  std::swap(header_, other->header_);
  targets_.UnsafeArenaSwap(&other->targets_);
  targetstoragetypes_.UnsafeArenaSwap(&other->targetstoragetypes_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata OpTransferBlockProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OpTransferBlockProto_descriptor_;
  metadata.reflection = OpTransferBlockProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OpTransferBlockProto

// required .ClientOperationHeaderProto header = 1;
bool OpTransferBlockProto::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void OpTransferBlockProto::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void OpTransferBlockProto::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void OpTransferBlockProto::clear_header() {
  if (header_ != NULL) header_->::ClientOperationHeaderProto::Clear();
  clear_has_header();
}
const ::ClientOperationHeaderProto& OpTransferBlockProto::header() const {
  // @@protoc_insertion_point(field_get:OpTransferBlockProto.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::ClientOperationHeaderProto* OpTransferBlockProto::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ClientOperationHeaderProto;
  }
  // @@protoc_insertion_point(field_mutable:OpTransferBlockProto.header)
  return header_;
}
::ClientOperationHeaderProto* OpTransferBlockProto::release_header() {
  // @@protoc_insertion_point(field_release:OpTransferBlockProto.header)
  clear_has_header();
  ::ClientOperationHeaderProto* temp = header_;
  header_ = NULL;
  return temp;
}
void OpTransferBlockProto::set_allocated_header(::ClientOperationHeaderProto* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:OpTransferBlockProto.header)
}

// repeated .DatanodeInfoProto targets = 2;
int OpTransferBlockProto::targets_size() const {
  return targets_.size();
}
void OpTransferBlockProto::clear_targets() {
  targets_.Clear();
}
const ::DatanodeInfoProto& OpTransferBlockProto::targets(int index) const {
  // @@protoc_insertion_point(field_get:OpTransferBlockProto.targets)
  return targets_.Get(index);
}
::DatanodeInfoProto* OpTransferBlockProto::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:OpTransferBlockProto.targets)
  return targets_.Mutable(index);
}
::DatanodeInfoProto* OpTransferBlockProto::add_targets() {
  // @@protoc_insertion_point(field_add:OpTransferBlockProto.targets)
  return targets_.Add();
}
::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >*
OpTransferBlockProto::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:OpTransferBlockProto.targets)
  return &targets_;
}
const ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >&
OpTransferBlockProto::targets() const {
  // @@protoc_insertion_point(field_list:OpTransferBlockProto.targets)
  return targets_;
}

// repeated .StorageTypeProto targetStorageTypes = 3;
int OpTransferBlockProto::targetstoragetypes_size() const {
  return targetstoragetypes_.size();
}
void OpTransferBlockProto::clear_targetstoragetypes() {
  targetstoragetypes_.Clear();
}
 ::StorageTypeProto OpTransferBlockProto::targetstoragetypes(int index) const {
  // @@protoc_insertion_point(field_get:OpTransferBlockProto.targetStorageTypes)
  return static_cast< ::StorageTypeProto >(targetstoragetypes_.Get(index));
}
 void OpTransferBlockProto::set_targetstoragetypes(int index, ::StorageTypeProto value) {
  assert(::StorageTypeProto_IsValid(value));
  targetstoragetypes_.Set(index, value);
  // @@protoc_insertion_point(field_set:OpTransferBlockProto.targetStorageTypes)
}
 void OpTransferBlockProto::add_targetstoragetypes(::StorageTypeProto value) {
  assert(::StorageTypeProto_IsValid(value));
  targetstoragetypes_.Add(value);
  // @@protoc_insertion_point(field_add:OpTransferBlockProto.targetStorageTypes)
}
 const ::google::protobuf::RepeatedField<int>&
OpTransferBlockProto::targetstoragetypes() const {
  // @@protoc_insertion_point(field_list:OpTransferBlockProto.targetStorageTypes)
  return targetstoragetypes_;
}
 ::google::protobuf::RepeatedField<int>*
OpTransferBlockProto::mutable_targetstoragetypes() {
  // @@protoc_insertion_point(field_mutable_list:OpTransferBlockProto.targetStorageTypes)
  return &targetstoragetypes_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OpBlockChecksumResponseProto::kBytesPerCrcFieldNumber;
const int OpBlockChecksumResponseProto::kCrcPerBlockFieldNumber;
const int OpBlockChecksumResponseProto::kMd5FieldNumber;
const int OpBlockChecksumResponseProto::kCrcTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OpBlockChecksumResponseProto::OpBlockChecksumResponseProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:OpBlockChecksumResponseProto)
}

void OpBlockChecksumResponseProto::InitAsDefaultInstance() {
}

OpBlockChecksumResponseProto::OpBlockChecksumResponseProto(const OpBlockChecksumResponseProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:OpBlockChecksumResponseProto)
}

void OpBlockChecksumResponseProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  bytespercrc_ = 0u;
  crcperblock_ = GOOGLE_ULONGLONG(0);
  md5_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  crctype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpBlockChecksumResponseProto::~OpBlockChecksumResponseProto() {
  // @@protoc_insertion_point(destructor:OpBlockChecksumResponseProto)
  SharedDtor();
}

void OpBlockChecksumResponseProto::SharedDtor() {
  md5_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void OpBlockChecksumResponseProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OpBlockChecksumResponseProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OpBlockChecksumResponseProto_descriptor_;
}

const OpBlockChecksumResponseProto& OpBlockChecksumResponseProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

OpBlockChecksumResponseProto* OpBlockChecksumResponseProto::default_instance_ = NULL;

OpBlockChecksumResponseProto* OpBlockChecksumResponseProto::New(::google::protobuf::Arena* arena) const {
  OpBlockChecksumResponseProto* n = new OpBlockChecksumResponseProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OpBlockChecksumResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:OpBlockChecksumResponseProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(OpBlockChecksumResponseProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<OpBlockChecksumResponseProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(crcperblock_, crctype_);
    if (has_md5()) {
      md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool OpBlockChecksumResponseProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:OpBlockChecksumResponseProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 bytesPerCrc = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bytespercrc_)));
          set_has_bytespercrc();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_crcPerBlock;
        break;
      }

      // required uint64 crcPerBlock = 2;
      case 2: {
        if (tag == 16) {
         parse_crcPerBlock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &crcperblock_)));
          set_has_crcperblock();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_md5;
        break;
      }

      // required bytes md5 = 3;
      case 3: {
        if (tag == 26) {
         parse_md5:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_md5()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_crcType;
        break;
      }

      // optional .ChecksumTypeProto crcType = 4;
      case 4: {
        if (tag == 32) {
         parse_crcType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ChecksumTypeProto_IsValid(value)) {
            set_crctype(static_cast< ::ChecksumTypeProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:OpBlockChecksumResponseProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:OpBlockChecksumResponseProto)
  return false;
#undef DO_
}

void OpBlockChecksumResponseProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:OpBlockChecksumResponseProto)
  // required uint32 bytesPerCrc = 1;
  if (has_bytespercrc()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->bytespercrc(), output);
  }

  // required uint64 crcPerBlock = 2;
  if (has_crcperblock()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->crcperblock(), output);
  }

  // required bytes md5 = 3;
  if (has_md5()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->md5(), output);
  }

  // optional .ChecksumTypeProto crcType = 4;
  if (has_crctype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->crctype(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:OpBlockChecksumResponseProto)
}

::google::protobuf::uint8* OpBlockChecksumResponseProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:OpBlockChecksumResponseProto)
  // required uint32 bytesPerCrc = 1;
  if (has_bytespercrc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->bytespercrc(), target);
  }

  // required uint64 crcPerBlock = 2;
  if (has_crcperblock()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->crcperblock(), target);
  }

  // required bytes md5 = 3;
  if (has_md5()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->md5(), target);
  }

  // optional .ChecksumTypeProto crcType = 4;
  if (has_crctype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->crctype(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OpBlockChecksumResponseProto)
  return target;
}

int OpBlockChecksumResponseProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:OpBlockChecksumResponseProto)
  int total_size = 0;

  if (has_bytespercrc()) {
    // required uint32 bytesPerCrc = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->bytespercrc());
  }

  if (has_crcperblock()) {
    // required uint64 crcPerBlock = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->crcperblock());
  }

  if (has_md5()) {
    // required bytes md5 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->md5());
  }

  return total_size;
}
int OpBlockChecksumResponseProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:OpBlockChecksumResponseProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 bytesPerCrc = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->bytespercrc());

    // required uint64 crcPerBlock = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->crcperblock());

    // required bytes md5 = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->md5());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .ChecksumTypeProto crcType = 4;
  if (has_crctype()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->crctype());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpBlockChecksumResponseProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:OpBlockChecksumResponseProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const OpBlockChecksumResponseProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const OpBlockChecksumResponseProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:OpBlockChecksumResponseProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:OpBlockChecksumResponseProto)
    MergeFrom(*source);
  }
}

void OpBlockChecksumResponseProto::MergeFrom(const OpBlockChecksumResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:OpBlockChecksumResponseProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bytespercrc()) {
      set_bytespercrc(from.bytespercrc());
    }
    if (from.has_crcperblock()) {
      set_crcperblock(from.crcperblock());
    }
    if (from.has_md5()) {
      set_has_md5();
      md5_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.md5_);
    }
    if (from.has_crctype()) {
      set_crctype(from.crctype());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void OpBlockChecksumResponseProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:OpBlockChecksumResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OpBlockChecksumResponseProto::CopyFrom(const OpBlockChecksumResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OpBlockChecksumResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpBlockChecksumResponseProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void OpBlockChecksumResponseProto::Swap(OpBlockChecksumResponseProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OpBlockChecksumResponseProto::InternalSwap(OpBlockChecksumResponseProto* other) {
  std::swap(bytespercrc_, other->bytespercrc_);
  std::swap(crcperblock_, other->crcperblock_);
  md5_.Swap(&other->md5_);
  std::swap(crctype_, other->crctype_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata OpBlockChecksumResponseProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OpBlockChecksumResponseProto_descriptor_;
  metadata.reflection = OpBlockChecksumResponseProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OpBlockChecksumResponseProto

// required uint32 bytesPerCrc = 1;
bool OpBlockChecksumResponseProto::has_bytespercrc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void OpBlockChecksumResponseProto::set_has_bytespercrc() {
  _has_bits_[0] |= 0x00000001u;
}
void OpBlockChecksumResponseProto::clear_has_bytespercrc() {
  _has_bits_[0] &= ~0x00000001u;
}
void OpBlockChecksumResponseProto::clear_bytespercrc() {
  bytespercrc_ = 0u;
  clear_has_bytespercrc();
}
 ::google::protobuf::uint32 OpBlockChecksumResponseProto::bytespercrc() const {
  // @@protoc_insertion_point(field_get:OpBlockChecksumResponseProto.bytesPerCrc)
  return bytespercrc_;
}
 void OpBlockChecksumResponseProto::set_bytespercrc(::google::protobuf::uint32 value) {
  set_has_bytespercrc();
  bytespercrc_ = value;
  // @@protoc_insertion_point(field_set:OpBlockChecksumResponseProto.bytesPerCrc)
}

// required uint64 crcPerBlock = 2;
bool OpBlockChecksumResponseProto::has_crcperblock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void OpBlockChecksumResponseProto::set_has_crcperblock() {
  _has_bits_[0] |= 0x00000002u;
}
void OpBlockChecksumResponseProto::clear_has_crcperblock() {
  _has_bits_[0] &= ~0x00000002u;
}
void OpBlockChecksumResponseProto::clear_crcperblock() {
  crcperblock_ = GOOGLE_ULONGLONG(0);
  clear_has_crcperblock();
}
 ::google::protobuf::uint64 OpBlockChecksumResponseProto::crcperblock() const {
  // @@protoc_insertion_point(field_get:OpBlockChecksumResponseProto.crcPerBlock)
  return crcperblock_;
}
 void OpBlockChecksumResponseProto::set_crcperblock(::google::protobuf::uint64 value) {
  set_has_crcperblock();
  crcperblock_ = value;
  // @@protoc_insertion_point(field_set:OpBlockChecksumResponseProto.crcPerBlock)
}

// required bytes md5 = 3;
bool OpBlockChecksumResponseProto::has_md5() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void OpBlockChecksumResponseProto::set_has_md5() {
  _has_bits_[0] |= 0x00000004u;
}
void OpBlockChecksumResponseProto::clear_has_md5() {
  _has_bits_[0] &= ~0x00000004u;
}
void OpBlockChecksumResponseProto::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_md5();
}
 const ::std::string& OpBlockChecksumResponseProto::md5() const {
  // @@protoc_insertion_point(field_get:OpBlockChecksumResponseProto.md5)
  return md5_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void OpBlockChecksumResponseProto::set_md5(const ::std::string& value) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OpBlockChecksumResponseProto.md5)
}
 void OpBlockChecksumResponseProto::set_md5(const char* value) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OpBlockChecksumResponseProto.md5)
}
 void OpBlockChecksumResponseProto::set_md5(const void* value, size_t size) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OpBlockChecksumResponseProto.md5)
}
 ::std::string* OpBlockChecksumResponseProto::mutable_md5() {
  set_has_md5();
  // @@protoc_insertion_point(field_mutable:OpBlockChecksumResponseProto.md5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* OpBlockChecksumResponseProto::release_md5() {
  // @@protoc_insertion_point(field_release:OpBlockChecksumResponseProto.md5)
  clear_has_md5();
  return md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void OpBlockChecksumResponseProto::set_allocated_md5(::std::string* md5) {
  if (md5 != NULL) {
    set_has_md5();
  } else {
    clear_has_md5();
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:OpBlockChecksumResponseProto.md5)
}

// optional .ChecksumTypeProto crcType = 4;
bool OpBlockChecksumResponseProto::has_crctype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void OpBlockChecksumResponseProto::set_has_crctype() {
  _has_bits_[0] |= 0x00000008u;
}
void OpBlockChecksumResponseProto::clear_has_crctype() {
  _has_bits_[0] &= ~0x00000008u;
}
void OpBlockChecksumResponseProto::clear_crctype() {
  crctype_ = 0;
  clear_has_crctype();
}
 ::ChecksumTypeProto OpBlockChecksumResponseProto::crctype() const {
  // @@protoc_insertion_point(field_get:OpBlockChecksumResponseProto.crcType)
  return static_cast< ::ChecksumTypeProto >(crctype_);
}
 void OpBlockChecksumResponseProto::set_crctype(::ChecksumTypeProto value) {
  assert(::ChecksumTypeProto_IsValid(value));
  set_has_crctype();
  crctype_ = value;
  // @@protoc_insertion_point(field_set:OpBlockChecksumResponseProto.crcType)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ChecksumProto::kTypeFieldNumber;
const int ChecksumProto::kBytesPerChecksumFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ChecksumProto::ChecksumProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ChecksumProto)
}

void ChecksumProto::InitAsDefaultInstance() {
}

ChecksumProto::ChecksumProto(const ChecksumProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ChecksumProto)
}

void ChecksumProto::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  bytesperchecksum_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChecksumProto::~ChecksumProto() {
  // @@protoc_insertion_point(destructor:ChecksumProto)
  SharedDtor();
}

void ChecksumProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ChecksumProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChecksumProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChecksumProto_descriptor_;
}

const ChecksumProto& ChecksumProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

ChecksumProto* ChecksumProto::default_instance_ = NULL;

ChecksumProto* ChecksumProto::New(::google::protobuf::Arena* arena) const {
  ChecksumProto* n = new ChecksumProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ChecksumProto::Clear() {
// @@protoc_insertion_point(message_clear_start:ChecksumProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ChecksumProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ChecksumProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(type_, bytesperchecksum_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ChecksumProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ChecksumProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ChecksumTypeProto type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ChecksumTypeProto_IsValid(value)) {
            set_type(static_cast< ::ChecksumTypeProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_bytesPerChecksum;
        break;
      }

      // required uint32 bytesPerChecksum = 2;
      case 2: {
        if (tag == 16) {
         parse_bytesPerChecksum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bytesperchecksum_)));
          set_has_bytesperchecksum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ChecksumProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ChecksumProto)
  return false;
#undef DO_
}

void ChecksumProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ChecksumProto)
  // required .ChecksumTypeProto type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required uint32 bytesPerChecksum = 2;
  if (has_bytesperchecksum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bytesperchecksum(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ChecksumProto)
}

::google::protobuf::uint8* ChecksumProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ChecksumProto)
  // required .ChecksumTypeProto type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required uint32 bytesPerChecksum = 2;
  if (has_bytesperchecksum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->bytesperchecksum(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ChecksumProto)
  return target;
}

int ChecksumProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ChecksumProto)
  int total_size = 0;

  if (has_type()) {
    // required .ChecksumTypeProto type = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  if (has_bytesperchecksum()) {
    // required uint32 bytesPerChecksum = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->bytesperchecksum());
  }

  return total_size;
}
int ChecksumProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:ChecksumProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .ChecksumTypeProto type = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

    // required uint32 bytesPerChecksum = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->bytesperchecksum());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChecksumProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ChecksumProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ChecksumProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ChecksumProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ChecksumProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ChecksumProto)
    MergeFrom(*source);
  }
}

void ChecksumProto::MergeFrom(const ChecksumProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ChecksumProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_bytesperchecksum()) {
      set_bytesperchecksum(from.bytesperchecksum());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ChecksumProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ChecksumProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChecksumProto::CopyFrom(const ChecksumProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ChecksumProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChecksumProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ChecksumProto::Swap(ChecksumProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ChecksumProto::InternalSwap(ChecksumProto* other) {
  std::swap(type_, other->type_);
  std::swap(bytesperchecksum_, other->bytesperchecksum_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ChecksumProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChecksumProto_descriptor_;
  metadata.reflection = ChecksumProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ChecksumProto

// required .ChecksumTypeProto type = 1;
bool ChecksumProto::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ChecksumProto::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void ChecksumProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void ChecksumProto::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::ChecksumTypeProto ChecksumProto::type() const {
  // @@protoc_insertion_point(field_get:ChecksumProto.type)
  return static_cast< ::ChecksumTypeProto >(type_);
}
 void ChecksumProto::set_type(::ChecksumTypeProto value) {
  assert(::ChecksumTypeProto_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ChecksumProto.type)
}

// required uint32 bytesPerChecksum = 2;
bool ChecksumProto::has_bytesperchecksum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ChecksumProto::set_has_bytesperchecksum() {
  _has_bits_[0] |= 0x00000002u;
}
void ChecksumProto::clear_has_bytesperchecksum() {
  _has_bits_[0] &= ~0x00000002u;
}
void ChecksumProto::clear_bytesperchecksum() {
  bytesperchecksum_ = 0u;
  clear_has_bytesperchecksum();
}
 ::google::protobuf::uint32 ChecksumProto::bytesperchecksum() const {
  // @@protoc_insertion_point(field_get:ChecksumProto.bytesPerChecksum)
  return bytesperchecksum_;
}
 void ChecksumProto::set_bytesperchecksum(::google::protobuf::uint32 value) {
  set_has_bytesperchecksum();
  bytesperchecksum_ = value;
  // @@protoc_insertion_point(field_set:ChecksumProto.bytesPerChecksum)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReadOpChecksumInfoProto::kChecksumFieldNumber;
const int ReadOpChecksumInfoProto::kChunkOffsetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReadOpChecksumInfoProto::ReadOpChecksumInfoProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ReadOpChecksumInfoProto)
}

void ReadOpChecksumInfoProto::InitAsDefaultInstance() {
  checksum_ = const_cast< ::ChecksumProto*>(&::ChecksumProto::default_instance());
}

ReadOpChecksumInfoProto::ReadOpChecksumInfoProto(const ReadOpChecksumInfoProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ReadOpChecksumInfoProto)
}

void ReadOpChecksumInfoProto::SharedCtor() {
  _cached_size_ = 0;
  checksum_ = NULL;
  chunkoffset_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadOpChecksumInfoProto::~ReadOpChecksumInfoProto() {
  // @@protoc_insertion_point(destructor:ReadOpChecksumInfoProto)
  SharedDtor();
}

void ReadOpChecksumInfoProto::SharedDtor() {
  if (this != default_instance_) {
    delete checksum_;
  }
}

void ReadOpChecksumInfoProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReadOpChecksumInfoProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReadOpChecksumInfoProto_descriptor_;
}

const ReadOpChecksumInfoProto& ReadOpChecksumInfoProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

ReadOpChecksumInfoProto* ReadOpChecksumInfoProto::default_instance_ = NULL;

ReadOpChecksumInfoProto* ReadOpChecksumInfoProto::New(::google::protobuf::Arena* arena) const {
  ReadOpChecksumInfoProto* n = new ReadOpChecksumInfoProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReadOpChecksumInfoProto::Clear() {
// @@protoc_insertion_point(message_clear_start:ReadOpChecksumInfoProto)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_checksum()) {
      if (checksum_ != NULL) checksum_->::ChecksumProto::Clear();
    }
    chunkoffset_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ReadOpChecksumInfoProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ReadOpChecksumInfoProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ChecksumProto checksum = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_checksum()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_chunkOffset;
        break;
      }

      // required uint64 chunkOffset = 2;
      case 2: {
        if (tag == 16) {
         parse_chunkOffset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &chunkoffset_)));
          set_has_chunkoffset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ReadOpChecksumInfoProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ReadOpChecksumInfoProto)
  return false;
#undef DO_
}

void ReadOpChecksumInfoProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ReadOpChecksumInfoProto)
  // required .ChecksumProto checksum = 1;
  if (has_checksum()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->checksum_, output);
  }

  // required uint64 chunkOffset = 2;
  if (has_chunkoffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->chunkoffset(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ReadOpChecksumInfoProto)
}

::google::protobuf::uint8* ReadOpChecksumInfoProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ReadOpChecksumInfoProto)
  // required .ChecksumProto checksum = 1;
  if (has_checksum()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->checksum_, false, target);
  }

  // required uint64 chunkOffset = 2;
  if (has_chunkoffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->chunkoffset(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ReadOpChecksumInfoProto)
  return target;
}

int ReadOpChecksumInfoProto::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ReadOpChecksumInfoProto)
  int total_size = 0;

  if (has_checksum()) {
    // required .ChecksumProto checksum = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->checksum_);
  }

  if (has_chunkoffset()) {
    // required uint64 chunkOffset = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->chunkoffset());
  }

  return total_size;
}
int ReadOpChecksumInfoProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:ReadOpChecksumInfoProto)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .ChecksumProto checksum = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->checksum_);

    // required uint64 chunkOffset = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->chunkoffset());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadOpChecksumInfoProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:ReadOpChecksumInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ReadOpChecksumInfoProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReadOpChecksumInfoProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:ReadOpChecksumInfoProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:ReadOpChecksumInfoProto)
    MergeFrom(*source);
  }
}

void ReadOpChecksumInfoProto::MergeFrom(const ReadOpChecksumInfoProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ReadOpChecksumInfoProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_checksum()) {
      mutable_checksum()->::ChecksumProto::MergeFrom(from.checksum());
    }
    if (from.has_chunkoffset()) {
      set_chunkoffset(from.chunkoffset());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ReadOpChecksumInfoProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:ReadOpChecksumInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReadOpChecksumInfoProto::CopyFrom(const ReadOpChecksumInfoProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ReadOpChecksumInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadOpChecksumInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_checksum()) {
    if (!this->checksum_->IsInitialized()) return false;
  }
  return true;
}

void ReadOpChecksumInfoProto::Swap(ReadOpChecksumInfoProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReadOpChecksumInfoProto::InternalSwap(ReadOpChecksumInfoProto* other) {
  std::swap(checksum_, other->checksum_);
  std::swap(chunkoffset_, other->chunkoffset_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReadOpChecksumInfoProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReadOpChecksumInfoProto_descriptor_;
  metadata.reflection = ReadOpChecksumInfoProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReadOpChecksumInfoProto

// required .ChecksumProto checksum = 1;
bool ReadOpChecksumInfoProto::has_checksum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReadOpChecksumInfoProto::set_has_checksum() {
  _has_bits_[0] |= 0x00000001u;
}
void ReadOpChecksumInfoProto::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReadOpChecksumInfoProto::clear_checksum() {
  if (checksum_ != NULL) checksum_->::ChecksumProto::Clear();
  clear_has_checksum();
}
const ::ChecksumProto& ReadOpChecksumInfoProto::checksum() const {
  // @@protoc_insertion_point(field_get:ReadOpChecksumInfoProto.checksum)
  return checksum_ != NULL ? *checksum_ : *default_instance_->checksum_;
}
::ChecksumProto* ReadOpChecksumInfoProto::mutable_checksum() {
  set_has_checksum();
  if (checksum_ == NULL) {
    checksum_ = new ::ChecksumProto;
  }
  // @@protoc_insertion_point(field_mutable:ReadOpChecksumInfoProto.checksum)
  return checksum_;
}
::ChecksumProto* ReadOpChecksumInfoProto::release_checksum() {
  // @@protoc_insertion_point(field_release:ReadOpChecksumInfoProto.checksum)
  clear_has_checksum();
  ::ChecksumProto* temp = checksum_;
  checksum_ = NULL;
  return temp;
}
void ReadOpChecksumInfoProto::set_allocated_checksum(::ChecksumProto* checksum) {
  delete checksum_;
  checksum_ = checksum;
  if (checksum) {
    set_has_checksum();
  } else {
    clear_has_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:ReadOpChecksumInfoProto.checksum)
}

// required uint64 chunkOffset = 2;
bool ReadOpChecksumInfoProto::has_chunkoffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ReadOpChecksumInfoProto::set_has_chunkoffset() {
  _has_bits_[0] |= 0x00000002u;
}
void ReadOpChecksumInfoProto::clear_has_chunkoffset() {
  _has_bits_[0] &= ~0x00000002u;
}
void ReadOpChecksumInfoProto::clear_chunkoffset() {
  chunkoffset_ = GOOGLE_ULONGLONG(0);
  clear_has_chunkoffset();
}
 ::google::protobuf::uint64 ReadOpChecksumInfoProto::chunkoffset() const {
  // @@protoc_insertion_point(field_get:ReadOpChecksumInfoProto.chunkOffset)
  return chunkoffset_;
}
 void ReadOpChecksumInfoProto::set_chunkoffset(::google::protobuf::uint64 value) {
  set_has_chunkoffset();
  chunkoffset_ = value;
  // @@protoc_insertion_point(field_set:ReadOpChecksumInfoProto.chunkOffset)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BlockOpResponseProto::kStatusFieldNumber;
const int BlockOpResponseProto::kFirstBadLinkFieldNumber;
const int BlockOpResponseProto::kChecksumResponseFieldNumber;
const int BlockOpResponseProto::kReadOpChecksumInfoFieldNumber;
const int BlockOpResponseProto::kMessageFieldNumber;
const int BlockOpResponseProto::kShortCircuitAccessVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BlockOpResponseProto::BlockOpResponseProto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:BlockOpResponseProto)
}

void BlockOpResponseProto::InitAsDefaultInstance() {
  checksumresponse_ = const_cast< ::OpBlockChecksumResponseProto*>(&::OpBlockChecksumResponseProto::default_instance());
  readopchecksuminfo_ = const_cast< ::ReadOpChecksumInfoProto*>(&::ReadOpChecksumInfoProto::default_instance());
}

BlockOpResponseProto::BlockOpResponseProto(const BlockOpResponseProto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:BlockOpResponseProto)
}

void BlockOpResponseProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  status_ = 0;
  firstbadlink_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  checksumresponse_ = NULL;
  readopchecksuminfo_ = NULL;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  shortcircuitaccessversion_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlockOpResponseProto::~BlockOpResponseProto() {
  // @@protoc_insertion_point(destructor:BlockOpResponseProto)
  SharedDtor();
}

void BlockOpResponseProto::SharedDtor() {
  firstbadlink_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete checksumresponse_;
    delete readopchecksuminfo_;
  }
}

void BlockOpResponseProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlockOpResponseProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlockOpResponseProto_descriptor_;
}

const BlockOpResponseProto& BlockOpResponseProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_common_2eproto();
  return *default_instance_;
}

BlockOpResponseProto* BlockOpResponseProto::default_instance_ = NULL;

BlockOpResponseProto* BlockOpResponseProto::New(::google::protobuf::Arena* arena) const {
  BlockOpResponseProto* n = new BlockOpResponseProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BlockOpResponseProto::Clear() {
// @@protoc_insertion_point(message_clear_start:BlockOpResponseProto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(BlockOpResponseProto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<BlockOpResponseProto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(status_, shortcircuitaccessversion_);
    if (has_firstbadlink()) {
      firstbadlink_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_checksumresponse()) {
      if (checksumresponse_ != NULL) checksumresponse_->::OpBlockChecksumResponseProto::Clear();
    }
    if (has_readopchecksuminfo()) {
      if (readopchecksuminfo_ != NULL) readopchecksuminfo_->::ReadOpChecksumInfoProto::Clear();
    }
    if (has_message()) {
      message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BlockOpResponseProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:BlockOpResponseProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Status status = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Status_IsValid(value)) {
            set_status(static_cast< ::Status >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_firstBadLink;
        break;
      }

      // optional string firstBadLink = 2;
      case 2: {
        if (tag == 18) {
         parse_firstBadLink:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_firstbadlink()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->firstbadlink().data(), this->firstbadlink().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "BlockOpResponseProto.firstBadLink");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_checksumResponse;
        break;
      }

      // optional .OpBlockChecksumResponseProto checksumResponse = 3;
      case 3: {
        if (tag == 26) {
         parse_checksumResponse:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_checksumresponse()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_readOpChecksumInfo;
        break;
      }

      // optional .ReadOpChecksumInfoProto readOpChecksumInfo = 4;
      case 4: {
        if (tag == 34) {
         parse_readOpChecksumInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_readopchecksuminfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_message;
        break;
      }

      // optional string message = 5;
      case 5: {
        if (tag == 42) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "BlockOpResponseProto.message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_shortCircuitAccessVersion;
        break;
      }

      // optional uint32 shortCircuitAccessVersion = 6;
      case 6: {
        if (tag == 48) {
         parse_shortCircuitAccessVersion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shortcircuitaccessversion_)));
          set_has_shortcircuitaccessversion();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:BlockOpResponseProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:BlockOpResponseProto)
  return false;
#undef DO_
}

void BlockOpResponseProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:BlockOpResponseProto)
  // required .Status status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }

  // optional string firstBadLink = 2;
  if (has_firstbadlink()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->firstbadlink().data(), this->firstbadlink().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "BlockOpResponseProto.firstBadLink");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->firstbadlink(), output);
  }

  // optional .OpBlockChecksumResponseProto checksumResponse = 3;
  if (has_checksumresponse()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->checksumresponse_, output);
  }

  // optional .ReadOpChecksumInfoProto readOpChecksumInfo = 4;
  if (has_readopchecksuminfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->readopchecksuminfo_, output);
  }

  // optional string message = 5;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "BlockOpResponseProto.message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->message(), output);
  }

  // optional uint32 shortCircuitAccessVersion = 6;
  if (has_shortcircuitaccessversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->shortcircuitaccessversion(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:BlockOpResponseProto)
}

::google::protobuf::uint8* BlockOpResponseProto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:BlockOpResponseProto)
  // required .Status status = 1;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->status(), target);
  }

  // optional string firstBadLink = 2;
  if (has_firstbadlink()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->firstbadlink().data(), this->firstbadlink().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "BlockOpResponseProto.firstBadLink");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->firstbadlink(), target);
  }

  // optional .OpBlockChecksumResponseProto checksumResponse = 3;
  if (has_checksumresponse()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->checksumresponse_, false, target);
  }

  // optional .ReadOpChecksumInfoProto readOpChecksumInfo = 4;
  if (has_readopchecksuminfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->readopchecksuminfo_, false, target);
  }

  // optional string message = 5;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "BlockOpResponseProto.message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->message(), target);
  }

  // optional uint32 shortCircuitAccessVersion = 6;
  if (has_shortcircuitaccessversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->shortcircuitaccessversion(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BlockOpResponseProto)
  return target;
}

int BlockOpResponseProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:BlockOpResponseProto)
  int total_size = 0;

  // required .Status status = 1;
  if (has_status()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
  }
  if (_has_bits_[1 / 32] & 62u) {
    // optional string firstBadLink = 2;
    if (has_firstbadlink()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->firstbadlink());
    }

    // optional .OpBlockChecksumResponseProto checksumResponse = 3;
    if (has_checksumresponse()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->checksumresponse_);
    }

    // optional .ReadOpChecksumInfoProto readOpChecksumInfo = 4;
    if (has_readopchecksuminfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->readopchecksuminfo_);
    }

    // optional string message = 5;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional uint32 shortCircuitAccessVersion = 6;
    if (has_shortcircuitaccessversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shortcircuitaccessversion());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlockOpResponseProto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:BlockOpResponseProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const BlockOpResponseProto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BlockOpResponseProto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:BlockOpResponseProto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:BlockOpResponseProto)
    MergeFrom(*source);
  }
}

void BlockOpResponseProto::MergeFrom(const BlockOpResponseProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:BlockOpResponseProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_firstbadlink()) {
      set_has_firstbadlink();
      firstbadlink_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.firstbadlink_);
    }
    if (from.has_checksumresponse()) {
      mutable_checksumresponse()->::OpBlockChecksumResponseProto::MergeFrom(from.checksumresponse());
    }
    if (from.has_readopchecksuminfo()) {
      mutable_readopchecksuminfo()->::ReadOpChecksumInfoProto::MergeFrom(from.readopchecksuminfo());
    }
    if (from.has_message()) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (from.has_shortcircuitaccessversion()) {
      set_shortcircuitaccessversion(from.shortcircuitaccessversion());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BlockOpResponseProto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:BlockOpResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlockOpResponseProto::CopyFrom(const BlockOpResponseProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BlockOpResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockOpResponseProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_checksumresponse()) {
    if (!this->checksumresponse_->IsInitialized()) return false;
  }
  if (has_readopchecksuminfo()) {
    if (!this->readopchecksuminfo_->IsInitialized()) return false;
  }
  return true;
}

void BlockOpResponseProto::Swap(BlockOpResponseProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BlockOpResponseProto::InternalSwap(BlockOpResponseProto* other) {
  std::swap(status_, other->status_);
  firstbadlink_.Swap(&other->firstbadlink_);
  std::swap(checksumresponse_, other->checksumresponse_);
  std::swap(readopchecksuminfo_, other->readopchecksuminfo_);
  message_.Swap(&other->message_);
  std::swap(shortcircuitaccessversion_, other->shortcircuitaccessversion_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BlockOpResponseProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlockOpResponseProto_descriptor_;
  metadata.reflection = BlockOpResponseProto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BlockOpResponseProto

// required .Status status = 1;
bool BlockOpResponseProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BlockOpResponseProto::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
void BlockOpResponseProto::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
void BlockOpResponseProto::clear_status() {
  status_ = 0;
  clear_has_status();
}
 ::Status BlockOpResponseProto::status() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.status)
  return static_cast< ::Status >(status_);
}
 void BlockOpResponseProto::set_status(::Status value) {
  assert(::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:BlockOpResponseProto.status)
}

// optional string firstBadLink = 2;
bool BlockOpResponseProto::has_firstbadlink() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void BlockOpResponseProto::set_has_firstbadlink() {
  _has_bits_[0] |= 0x00000002u;
}
void BlockOpResponseProto::clear_has_firstbadlink() {
  _has_bits_[0] &= ~0x00000002u;
}
void BlockOpResponseProto::clear_firstbadlink() {
  firstbadlink_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_firstbadlink();
}
 const ::std::string& BlockOpResponseProto::firstbadlink() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.firstBadLink)
  return firstbadlink_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void BlockOpResponseProto::set_firstbadlink(const ::std::string& value) {
  set_has_firstbadlink();
  firstbadlink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BlockOpResponseProto.firstBadLink)
}
 void BlockOpResponseProto::set_firstbadlink(const char* value) {
  set_has_firstbadlink();
  firstbadlink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BlockOpResponseProto.firstBadLink)
}
 void BlockOpResponseProto::set_firstbadlink(const char* value, size_t size) {
  set_has_firstbadlink();
  firstbadlink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BlockOpResponseProto.firstBadLink)
}
 ::std::string* BlockOpResponseProto::mutable_firstbadlink() {
  set_has_firstbadlink();
  // @@protoc_insertion_point(field_mutable:BlockOpResponseProto.firstBadLink)
  return firstbadlink_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* BlockOpResponseProto::release_firstbadlink() {
  // @@protoc_insertion_point(field_release:BlockOpResponseProto.firstBadLink)
  clear_has_firstbadlink();
  return firstbadlink_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void BlockOpResponseProto::set_allocated_firstbadlink(::std::string* firstbadlink) {
  if (firstbadlink != NULL) {
    set_has_firstbadlink();
  } else {
    clear_has_firstbadlink();
  }
  firstbadlink_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firstbadlink);
  // @@protoc_insertion_point(field_set_allocated:BlockOpResponseProto.firstBadLink)
}

// optional .OpBlockChecksumResponseProto checksumResponse = 3;
bool BlockOpResponseProto::has_checksumresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void BlockOpResponseProto::set_has_checksumresponse() {
  _has_bits_[0] |= 0x00000004u;
}
void BlockOpResponseProto::clear_has_checksumresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
void BlockOpResponseProto::clear_checksumresponse() {
  if (checksumresponse_ != NULL) checksumresponse_->::OpBlockChecksumResponseProto::Clear();
  clear_has_checksumresponse();
}
const ::OpBlockChecksumResponseProto& BlockOpResponseProto::checksumresponse() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.checksumResponse)
  return checksumresponse_ != NULL ? *checksumresponse_ : *default_instance_->checksumresponse_;
}
::OpBlockChecksumResponseProto* BlockOpResponseProto::mutable_checksumresponse() {
  set_has_checksumresponse();
  if (checksumresponse_ == NULL) {
    checksumresponse_ = new ::OpBlockChecksumResponseProto;
  }
  // @@protoc_insertion_point(field_mutable:BlockOpResponseProto.checksumResponse)
  return checksumresponse_;
}
::OpBlockChecksumResponseProto* BlockOpResponseProto::release_checksumresponse() {
  // @@protoc_insertion_point(field_release:BlockOpResponseProto.checksumResponse)
  clear_has_checksumresponse();
  ::OpBlockChecksumResponseProto* temp = checksumresponse_;
  checksumresponse_ = NULL;
  return temp;
}
void BlockOpResponseProto::set_allocated_checksumresponse(::OpBlockChecksumResponseProto* checksumresponse) {
  delete checksumresponse_;
  checksumresponse_ = checksumresponse;
  if (checksumresponse) {
    set_has_checksumresponse();
  } else {
    clear_has_checksumresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:BlockOpResponseProto.checksumResponse)
}

// optional .ReadOpChecksumInfoProto readOpChecksumInfo = 4;
bool BlockOpResponseProto::has_readopchecksuminfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void BlockOpResponseProto::set_has_readopchecksuminfo() {
  _has_bits_[0] |= 0x00000008u;
}
void BlockOpResponseProto::clear_has_readopchecksuminfo() {
  _has_bits_[0] &= ~0x00000008u;
}
void BlockOpResponseProto::clear_readopchecksuminfo() {
  if (readopchecksuminfo_ != NULL) readopchecksuminfo_->::ReadOpChecksumInfoProto::Clear();
  clear_has_readopchecksuminfo();
}
const ::ReadOpChecksumInfoProto& BlockOpResponseProto::readopchecksuminfo() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.readOpChecksumInfo)
  return readopchecksuminfo_ != NULL ? *readopchecksuminfo_ : *default_instance_->readopchecksuminfo_;
}
::ReadOpChecksumInfoProto* BlockOpResponseProto::mutable_readopchecksuminfo() {
  set_has_readopchecksuminfo();
  if (readopchecksuminfo_ == NULL) {
    readopchecksuminfo_ = new ::ReadOpChecksumInfoProto;
  }
  // @@protoc_insertion_point(field_mutable:BlockOpResponseProto.readOpChecksumInfo)
  return readopchecksuminfo_;
}
::ReadOpChecksumInfoProto* BlockOpResponseProto::release_readopchecksuminfo() {
  // @@protoc_insertion_point(field_release:BlockOpResponseProto.readOpChecksumInfo)
  clear_has_readopchecksuminfo();
  ::ReadOpChecksumInfoProto* temp = readopchecksuminfo_;
  readopchecksuminfo_ = NULL;
  return temp;
}
void BlockOpResponseProto::set_allocated_readopchecksuminfo(::ReadOpChecksumInfoProto* readopchecksuminfo) {
  delete readopchecksuminfo_;
  readopchecksuminfo_ = readopchecksuminfo;
  if (readopchecksuminfo) {
    set_has_readopchecksuminfo();
  } else {
    clear_has_readopchecksuminfo();
  }
  // @@protoc_insertion_point(field_set_allocated:BlockOpResponseProto.readOpChecksumInfo)
}

// optional string message = 5;
bool BlockOpResponseProto::has_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void BlockOpResponseProto::set_has_message() {
  _has_bits_[0] |= 0x00000010u;
}
void BlockOpResponseProto::clear_has_message() {
  _has_bits_[0] &= ~0x00000010u;
}
void BlockOpResponseProto::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
 const ::std::string& BlockOpResponseProto::message() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void BlockOpResponseProto::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BlockOpResponseProto.message)
}
 void BlockOpResponseProto::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BlockOpResponseProto.message)
}
 void BlockOpResponseProto::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BlockOpResponseProto.message)
}
 ::std::string* BlockOpResponseProto::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:BlockOpResponseProto.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* BlockOpResponseProto::release_message() {
  // @@protoc_insertion_point(field_release:BlockOpResponseProto.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void BlockOpResponseProto::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:BlockOpResponseProto.message)
}

// optional uint32 shortCircuitAccessVersion = 6;
bool BlockOpResponseProto::has_shortcircuitaccessversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void BlockOpResponseProto::set_has_shortcircuitaccessversion() {
  _has_bits_[0] |= 0x00000020u;
}
void BlockOpResponseProto::clear_has_shortcircuitaccessversion() {
  _has_bits_[0] &= ~0x00000020u;
}
void BlockOpResponseProto::clear_shortcircuitaccessversion() {
  shortcircuitaccessversion_ = 0u;
  clear_has_shortcircuitaccessversion();
}
 ::google::protobuf::uint32 BlockOpResponseProto::shortcircuitaccessversion() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.shortCircuitAccessVersion)
  return shortcircuitaccessversion_;
}
 void BlockOpResponseProto::set_shortcircuitaccessversion(::google::protobuf::uint32 value) {
  set_has_shortcircuitaccessversion();
  shortcircuitaccessversion_ = value;
  // @@protoc_insertion_point(field_set:BlockOpResponseProto.shortCircuitAccessVersion)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
