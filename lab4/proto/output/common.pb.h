// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class BaseHeaderProto;
class BlockKeyProto;
class BlockOpResponseProto;
class ChecksumProto;
class ClientOperationHeaderProto;
class DataTransferTraceInfoProto;
class DatanodeHeartbeatRequestProto;
class DatanodeHeartbeatResponseProto;
class DatanodeIDProto;
class DatanodeInfoProto;
class DatanodeRegistrationProto;
class ExportedBlockKeysProto;
class ExtendedBlockProto;
class FileEncryptionInfoProto;
class FsPermissionProto;
class LocatedBlockProto;
class LocatedBlocksProto;
class OpBlockChecksumResponseProto;
class OpTransferBlockProto;
class RPCCallerContextProto;
class RPCTraceInfoProto;
class ReadOpChecksumInfoProto;
class RegisterDatanodeRequestProto;
class RegisterDatanodeResponseProto;
class RequestHeaderProto;
class RpcRequestHeaderProto;
class RpcResponseHeaderProto;
class StorageInfoProto;
class TokenProto;

enum RpcRequestHeaderProto_OperationProto {
  RpcRequestHeaderProto_OperationProto_RPC_FINAL_PACKET = 0,
  RpcRequestHeaderProto_OperationProto_RPC_CONTINUATION_PACKET = 1,
  RpcRequestHeaderProto_OperationProto_RPC_CLOSE_CONNECTION = 2
};
bool RpcRequestHeaderProto_OperationProto_IsValid(int value);
const RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto_OperationProto_OperationProto_MIN = RpcRequestHeaderProto_OperationProto_RPC_FINAL_PACKET;
const RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto_OperationProto_OperationProto_MAX = RpcRequestHeaderProto_OperationProto_RPC_CLOSE_CONNECTION;
const int RpcRequestHeaderProto_OperationProto_OperationProto_ARRAYSIZE = RpcRequestHeaderProto_OperationProto_OperationProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcRequestHeaderProto_OperationProto_descriptor();
inline const ::std::string& RpcRequestHeaderProto_OperationProto_Name(RpcRequestHeaderProto_OperationProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcRequestHeaderProto_OperationProto_descriptor(), value);
}
inline bool RpcRequestHeaderProto_OperationProto_Parse(
    const ::std::string& name, RpcRequestHeaderProto_OperationProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcRequestHeaderProto_OperationProto>(
    RpcRequestHeaderProto_OperationProto_descriptor(), name, value);
}
enum RpcResponseHeaderProto_RpcStatusProto {
  RpcResponseHeaderProto_RpcStatusProto_SUCCESS = 0,
  RpcResponseHeaderProto_RpcStatusProto_ERROR = 1,
  RpcResponseHeaderProto_RpcStatusProto_FATAL = 2
};
bool RpcResponseHeaderProto_RpcStatusProto_IsValid(int value);
const RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MIN = RpcResponseHeaderProto_RpcStatusProto_SUCCESS;
const RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MAX = RpcResponseHeaderProto_RpcStatusProto_FATAL;
const int RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_ARRAYSIZE = RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcResponseHeaderProto_RpcStatusProto_descriptor();
inline const ::std::string& RpcResponseHeaderProto_RpcStatusProto_Name(RpcResponseHeaderProto_RpcStatusProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcResponseHeaderProto_RpcStatusProto_descriptor(), value);
}
inline bool RpcResponseHeaderProto_RpcStatusProto_Parse(
    const ::std::string& name, RpcResponseHeaderProto_RpcStatusProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcResponseHeaderProto_RpcStatusProto>(
    RpcResponseHeaderProto_RpcStatusProto_descriptor(), name, value);
}
enum RpcResponseHeaderProto_RpcErrorCodeProto {
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_APPLICATION = 1,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_METHOD = 2,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_PROTOCOL = 3,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_SERVER = 4,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_SERIALIZING_RESPONSE = 5,
  RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_VERSION_MISMATCH = 6,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNKNOWN = 10,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNSUPPORTED_SERIALIZATION = 11,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_INVALID_RPC_HEADER = 12,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_DESERIALIZING_REQUEST = 13,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_VERSION_MISMATCH = 14,
  RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNAUTHORIZED = 15
};
bool RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(int value);
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MIN = RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_APPLICATION;
const RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MAX = RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNAUTHORIZED;
const int RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_ARRAYSIZE = RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcResponseHeaderProto_RpcErrorCodeProto_descriptor();
inline const ::std::string& RpcResponseHeaderProto_RpcErrorCodeProto_Name(RpcResponseHeaderProto_RpcErrorCodeProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcResponseHeaderProto_RpcErrorCodeProto_descriptor(), value);
}
inline bool RpcResponseHeaderProto_RpcErrorCodeProto_Parse(
    const ::std::string& name, RpcResponseHeaderProto_RpcErrorCodeProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcResponseHeaderProto_RpcErrorCodeProto>(
    RpcResponseHeaderProto_RpcErrorCodeProto_descriptor(), name, value);
}
enum DatanodeInfoProto_AdminState {
  DatanodeInfoProto_AdminState_NORMAL = 0,
  DatanodeInfoProto_AdminState_DECOMMISSION_INPROGRESS = 1,
  DatanodeInfoProto_AdminState_DECOMMISSIONED = 2
};
bool DatanodeInfoProto_AdminState_IsValid(int value);
const DatanodeInfoProto_AdminState DatanodeInfoProto_AdminState_AdminState_MIN = DatanodeInfoProto_AdminState_NORMAL;
const DatanodeInfoProto_AdminState DatanodeInfoProto_AdminState_AdminState_MAX = DatanodeInfoProto_AdminState_DECOMMISSIONED;
const int DatanodeInfoProto_AdminState_AdminState_ARRAYSIZE = DatanodeInfoProto_AdminState_AdminState_MAX + 1;

const ::google::protobuf::EnumDescriptor* DatanodeInfoProto_AdminState_descriptor();
inline const ::std::string& DatanodeInfoProto_AdminState_Name(DatanodeInfoProto_AdminState value) {
  return ::google::protobuf::internal::NameOfEnum(
    DatanodeInfoProto_AdminState_descriptor(), value);
}
inline bool DatanodeInfoProto_AdminState_Parse(
    const ::std::string& name, DatanodeInfoProto_AdminState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatanodeInfoProto_AdminState>(
    DatanodeInfoProto_AdminState_descriptor(), name, value);
}
enum RpcKindProto {
  RPC_BUILTIN = 0,
  RPC_WRITABLE = 1,
  RPC_PROTOCOL_BUFFER = 2
};
bool RpcKindProto_IsValid(int value);
const RpcKindProto RpcKindProto_MIN = RPC_BUILTIN;
const RpcKindProto RpcKindProto_MAX = RPC_PROTOCOL_BUFFER;
const int RpcKindProto_ARRAYSIZE = RpcKindProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcKindProto_descriptor();
inline const ::std::string& RpcKindProto_Name(RpcKindProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcKindProto_descriptor(), value);
}
inline bool RpcKindProto_Parse(
    const ::std::string& name, RpcKindProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcKindProto>(
    RpcKindProto_descriptor(), name, value);
}
enum StorageTypeProto {
  DISK = 1,
  SSD = 2,
  ARCHIVE = 3,
  RAM_DISK = 4
};
bool StorageTypeProto_IsValid(int value);
const StorageTypeProto StorageTypeProto_MIN = DISK;
const StorageTypeProto StorageTypeProto_MAX = RAM_DISK;
const int StorageTypeProto_ARRAYSIZE = StorageTypeProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* StorageTypeProto_descriptor();
inline const ::std::string& StorageTypeProto_Name(StorageTypeProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    StorageTypeProto_descriptor(), value);
}
inline bool StorageTypeProto_Parse(
    const ::std::string& name, StorageTypeProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StorageTypeProto>(
    StorageTypeProto_descriptor(), name, value);
}
enum CipherSuiteProto {
  UNKNOWN = 1,
  AES_CTR_NOPADDING = 2
};
bool CipherSuiteProto_IsValid(int value);
const CipherSuiteProto CipherSuiteProto_MIN = UNKNOWN;
const CipherSuiteProto CipherSuiteProto_MAX = AES_CTR_NOPADDING;
const int CipherSuiteProto_ARRAYSIZE = CipherSuiteProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* CipherSuiteProto_descriptor();
inline const ::std::string& CipherSuiteProto_Name(CipherSuiteProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    CipherSuiteProto_descriptor(), value);
}
inline bool CipherSuiteProto_Parse(
    const ::std::string& name, CipherSuiteProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CipherSuiteProto>(
    CipherSuiteProto_descriptor(), name, value);
}
enum CryptoProtocolVersionProto {
  UNKNOWN_PROTOCOL_VERSION = 1,
  ENCRYPTION_ZONES = 2
};
bool CryptoProtocolVersionProto_IsValid(int value);
const CryptoProtocolVersionProto CryptoProtocolVersionProto_MIN = UNKNOWN_PROTOCOL_VERSION;
const CryptoProtocolVersionProto CryptoProtocolVersionProto_MAX = ENCRYPTION_ZONES;
const int CryptoProtocolVersionProto_ARRAYSIZE = CryptoProtocolVersionProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* CryptoProtocolVersionProto_descriptor();
inline const ::std::string& CryptoProtocolVersionProto_Name(CryptoProtocolVersionProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    CryptoProtocolVersionProto_descriptor(), value);
}
inline bool CryptoProtocolVersionProto_Parse(
    const ::std::string& name, CryptoProtocolVersionProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CryptoProtocolVersionProto>(
    CryptoProtocolVersionProto_descriptor(), name, value);
}
enum ChecksumTypeProto {
  CHECKSUM_NULL = 0,
  CHECKSUM_CRC32 = 1,
  CHECKSUM_CRC32C = 2
};
bool ChecksumTypeProto_IsValid(int value);
const ChecksumTypeProto ChecksumTypeProto_MIN = CHECKSUM_NULL;
const ChecksumTypeProto ChecksumTypeProto_MAX = CHECKSUM_CRC32C;
const int ChecksumTypeProto_ARRAYSIZE = ChecksumTypeProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChecksumTypeProto_descriptor();
inline const ::std::string& ChecksumTypeProto_Name(ChecksumTypeProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChecksumTypeProto_descriptor(), value);
}
inline bool ChecksumTypeProto_Parse(
    const ::std::string& name, ChecksumTypeProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChecksumTypeProto>(
    ChecksumTypeProto_descriptor(), name, value);
}
enum Status {
  SUCCESS = 0,
  ERROR = 1,
  ERROR_CHECKSUM = 2,
  ERROR_INVALID = 3,
  ERROR_EXISTS = 4,
  ERROR_ACCESS_TOKEN = 5,
  CHECKSUM_OK = 6,
  ERROR_UNSUPPORTED = 7,
  OOB_RESTART = 8,
  OOB_RESERVED1 = 9,
  OOB_RESERVED2 = 10,
  OOB_RESERVED3 = 11,
  IN_PROGRESS = 12
};
bool Status_IsValid(int value);
const Status Status_MIN = SUCCESS;
const Status Status_MAX = IN_PROGRESS;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
// ===================================================================

class RPCTraceInfoProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RPCTraceInfoProto) */ {
 public:
  RPCTraceInfoProto();
  virtual ~RPCTraceInfoProto();

  RPCTraceInfoProto(const RPCTraceInfoProto& from);

  inline RPCTraceInfoProto& operator=(const RPCTraceInfoProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCTraceInfoProto& default_instance();

  void Swap(RPCTraceInfoProto* other);

  // implements Message ----------------------------------------------

  inline RPCTraceInfoProto* New() const { return New(NULL); }

  RPCTraceInfoProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RPCTraceInfoProto& from);
  void MergeFrom(const RPCTraceInfoProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RPCTraceInfoProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 traceId = 1;
  bool has_traceid() const;
  void clear_traceid();
  static const int kTraceIdFieldNumber = 1;
  ::google::protobuf::int64 traceid() const;
  void set_traceid(::google::protobuf::int64 value);

  // optional int64 parentId = 2;
  bool has_parentid() const;
  void clear_parentid();
  static const int kParentIdFieldNumber = 2;
  ::google::protobuf::int64 parentid() const;
  void set_parentid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:RPCTraceInfoProto)
 private:
  inline void set_has_traceid();
  inline void clear_has_traceid();
  inline void set_has_parentid();
  inline void clear_has_parentid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 traceid_;
  ::google::protobuf::int64 parentid_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RPCTraceInfoProto* default_instance_;
};
// -------------------------------------------------------------------

class RPCCallerContextProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RPCCallerContextProto) */ {
 public:
  RPCCallerContextProto();
  virtual ~RPCCallerContextProto();

  RPCCallerContextProto(const RPCCallerContextProto& from);

  inline RPCCallerContextProto& operator=(const RPCCallerContextProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCCallerContextProto& default_instance();

  void Swap(RPCCallerContextProto* other);

  // implements Message ----------------------------------------------

  inline RPCCallerContextProto* New() const { return New(NULL); }

  RPCCallerContextProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RPCCallerContextProto& from);
  void MergeFrom(const RPCCallerContextProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RPCCallerContextProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  const ::std::string& context() const;
  void set_context(const ::std::string& value);
  void set_context(const char* value);
  void set_context(const char* value, size_t size);
  ::std::string* mutable_context();
  ::std::string* release_context();
  void set_allocated_context(::std::string* context);

  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:RPCCallerContextProto)
 private:
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr context_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RPCCallerContextProto* default_instance_;
};
// -------------------------------------------------------------------

class RpcRequestHeaderProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RpcRequestHeaderProto) */ {
 public:
  RpcRequestHeaderProto();
  virtual ~RpcRequestHeaderProto();

  RpcRequestHeaderProto(const RpcRequestHeaderProto& from);

  inline RpcRequestHeaderProto& operator=(const RpcRequestHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcRequestHeaderProto& default_instance();

  void Swap(RpcRequestHeaderProto* other);

  // implements Message ----------------------------------------------

  inline RpcRequestHeaderProto* New() const { return New(NULL); }

  RpcRequestHeaderProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpcRequestHeaderProto& from);
  void MergeFrom(const RpcRequestHeaderProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RpcRequestHeaderProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RpcRequestHeaderProto_OperationProto OperationProto;
  static const OperationProto RPC_FINAL_PACKET =
    RpcRequestHeaderProto_OperationProto_RPC_FINAL_PACKET;
  static const OperationProto RPC_CONTINUATION_PACKET =
    RpcRequestHeaderProto_OperationProto_RPC_CONTINUATION_PACKET;
  static const OperationProto RPC_CLOSE_CONNECTION =
    RpcRequestHeaderProto_OperationProto_RPC_CLOSE_CONNECTION;
  static inline bool OperationProto_IsValid(int value) {
    return RpcRequestHeaderProto_OperationProto_IsValid(value);
  }
  static const OperationProto OperationProto_MIN =
    RpcRequestHeaderProto_OperationProto_OperationProto_MIN;
  static const OperationProto OperationProto_MAX =
    RpcRequestHeaderProto_OperationProto_OperationProto_MAX;
  static const int OperationProto_ARRAYSIZE =
    RpcRequestHeaderProto_OperationProto_OperationProto_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OperationProto_descriptor() {
    return RpcRequestHeaderProto_OperationProto_descriptor();
  }
  static inline const ::std::string& OperationProto_Name(OperationProto value) {
    return RpcRequestHeaderProto_OperationProto_Name(value);
  }
  static inline bool OperationProto_Parse(const ::std::string& name,
      OperationProto* value) {
    return RpcRequestHeaderProto_OperationProto_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .RpcKindProto rpcKind = 1;
  bool has_rpckind() const;
  void clear_rpckind();
  static const int kRpcKindFieldNumber = 1;
  ::RpcKindProto rpckind() const;
  void set_rpckind(::RpcKindProto value);

  // optional .RpcRequestHeaderProto.OperationProto rpcOp = 2;
  bool has_rpcop() const;
  void clear_rpcop();
  static const int kRpcOpFieldNumber = 2;
  ::RpcRequestHeaderProto_OperationProto rpcop() const;
  void set_rpcop(::RpcRequestHeaderProto_OperationProto value);

  // required sint32 callId = 3;
  bool has_callid() const;
  void clear_callid();
  static const int kCallIdFieldNumber = 3;
  ::google::protobuf::int32 callid() const;
  void set_callid(::google::protobuf::int32 value);

  // required bytes clientId = 4;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 4;
  const ::std::string& clientid() const;
  void set_clientid(const ::std::string& value);
  void set_clientid(const char* value);
  void set_clientid(const void* value, size_t size);
  ::std::string* mutable_clientid();
  ::std::string* release_clientid();
  void set_allocated_clientid(::std::string* clientid);

  // optional sint32 retryCount = 5 [default = -1];
  bool has_retrycount() const;
  void clear_retrycount();
  static const int kRetryCountFieldNumber = 5;
  ::google::protobuf::int32 retrycount() const;
  void set_retrycount(::google::protobuf::int32 value);

  // optional .RPCTraceInfoProto traceInfo = 6;
  bool has_traceinfo() const;
  void clear_traceinfo();
  static const int kTraceInfoFieldNumber = 6;
  const ::RPCTraceInfoProto& traceinfo() const;
  ::RPCTraceInfoProto* mutable_traceinfo();
  ::RPCTraceInfoProto* release_traceinfo();
  void set_allocated_traceinfo(::RPCTraceInfoProto* traceinfo);

  // optional .RPCCallerContextProto callerContext = 7;
  bool has_callercontext() const;
  void clear_callercontext();
  static const int kCallerContextFieldNumber = 7;
  const ::RPCCallerContextProto& callercontext() const;
  ::RPCCallerContextProto* mutable_callercontext();
  ::RPCCallerContextProto* release_callercontext();
  void set_allocated_callercontext(::RPCCallerContextProto* callercontext);

  // @@protoc_insertion_point(class_scope:RpcRequestHeaderProto)
 private:
  inline void set_has_rpckind();
  inline void clear_has_rpckind();
  inline void set_has_rpcop();
  inline void clear_has_rpcop();
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_retrycount();
  inline void clear_has_retrycount();
  inline void set_has_traceinfo();
  inline void clear_has_traceinfo();
  inline void set_has_callercontext();
  inline void clear_has_callercontext();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int rpckind_;
  int rpcop_;
  ::google::protobuf::internal::ArenaStringPtr clientid_;
  ::google::protobuf::int32 callid_;
  ::google::protobuf::int32 retrycount_;
  ::RPCTraceInfoProto* traceinfo_;
  ::RPCCallerContextProto* callercontext_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RpcRequestHeaderProto* default_instance_;
};
// -------------------------------------------------------------------

class RpcResponseHeaderProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RpcResponseHeaderProto) */ {
 public:
  RpcResponseHeaderProto();
  virtual ~RpcResponseHeaderProto();

  RpcResponseHeaderProto(const RpcResponseHeaderProto& from);

  inline RpcResponseHeaderProto& operator=(const RpcResponseHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RpcResponseHeaderProto& default_instance();

  void Swap(RpcResponseHeaderProto* other);

  // implements Message ----------------------------------------------

  inline RpcResponseHeaderProto* New() const { return New(NULL); }

  RpcResponseHeaderProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpcResponseHeaderProto& from);
  void MergeFrom(const RpcResponseHeaderProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RpcResponseHeaderProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RpcResponseHeaderProto_RpcStatusProto RpcStatusProto;
  static const RpcStatusProto SUCCESS =
    RpcResponseHeaderProto_RpcStatusProto_SUCCESS;
  static const RpcStatusProto ERROR =
    RpcResponseHeaderProto_RpcStatusProto_ERROR;
  static const RpcStatusProto FATAL =
    RpcResponseHeaderProto_RpcStatusProto_FATAL;
  static inline bool RpcStatusProto_IsValid(int value) {
    return RpcResponseHeaderProto_RpcStatusProto_IsValid(value);
  }
  static const RpcStatusProto RpcStatusProto_MIN =
    RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MIN;
  static const RpcStatusProto RpcStatusProto_MAX =
    RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_MAX;
  static const int RpcStatusProto_ARRAYSIZE =
    RpcResponseHeaderProto_RpcStatusProto_RpcStatusProto_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RpcStatusProto_descriptor() {
    return RpcResponseHeaderProto_RpcStatusProto_descriptor();
  }
  static inline const ::std::string& RpcStatusProto_Name(RpcStatusProto value) {
    return RpcResponseHeaderProto_RpcStatusProto_Name(value);
  }
  static inline bool RpcStatusProto_Parse(const ::std::string& name,
      RpcStatusProto* value) {
    return RpcResponseHeaderProto_RpcStatusProto_Parse(name, value);
  }

  typedef RpcResponseHeaderProto_RpcErrorCodeProto RpcErrorCodeProto;
  static const RpcErrorCodeProto ERROR_APPLICATION =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_APPLICATION;
  static const RpcErrorCodeProto ERROR_NO_SUCH_METHOD =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_METHOD;
  static const RpcErrorCodeProto ERROR_NO_SUCH_PROTOCOL =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_NO_SUCH_PROTOCOL;
  static const RpcErrorCodeProto ERROR_RPC_SERVER =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_SERVER;
  static const RpcErrorCodeProto ERROR_SERIALIZING_RESPONSE =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_SERIALIZING_RESPONSE;
  static const RpcErrorCodeProto ERROR_RPC_VERSION_MISMATCH =
    RpcResponseHeaderProto_RpcErrorCodeProto_ERROR_RPC_VERSION_MISMATCH;
  static const RpcErrorCodeProto FATAL_UNKNOWN =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNKNOWN;
  static const RpcErrorCodeProto FATAL_UNSUPPORTED_SERIALIZATION =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNSUPPORTED_SERIALIZATION;
  static const RpcErrorCodeProto FATAL_INVALID_RPC_HEADER =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_INVALID_RPC_HEADER;
  static const RpcErrorCodeProto FATAL_DESERIALIZING_REQUEST =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_DESERIALIZING_REQUEST;
  static const RpcErrorCodeProto FATAL_VERSION_MISMATCH =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_VERSION_MISMATCH;
  static const RpcErrorCodeProto FATAL_UNAUTHORIZED =
    RpcResponseHeaderProto_RpcErrorCodeProto_FATAL_UNAUTHORIZED;
  static inline bool RpcErrorCodeProto_IsValid(int value) {
    return RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(value);
  }
  static const RpcErrorCodeProto RpcErrorCodeProto_MIN =
    RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MIN;
  static const RpcErrorCodeProto RpcErrorCodeProto_MAX =
    RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_MAX;
  static const int RpcErrorCodeProto_ARRAYSIZE =
    RpcResponseHeaderProto_RpcErrorCodeProto_RpcErrorCodeProto_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RpcErrorCodeProto_descriptor() {
    return RpcResponseHeaderProto_RpcErrorCodeProto_descriptor();
  }
  static inline const ::std::string& RpcErrorCodeProto_Name(RpcErrorCodeProto value) {
    return RpcResponseHeaderProto_RpcErrorCodeProto_Name(value);
  }
  static inline bool RpcErrorCodeProto_Parse(const ::std::string& name,
      RpcErrorCodeProto* value) {
    return RpcResponseHeaderProto_RpcErrorCodeProto_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 callId = 1;
  bool has_callid() const;
  void clear_callid();
  static const int kCallIdFieldNumber = 1;
  ::google::protobuf::uint32 callid() const;
  void set_callid(::google::protobuf::uint32 value);

  // required .RpcResponseHeaderProto.RpcStatusProto status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::RpcResponseHeaderProto_RpcStatusProto status() const;
  void set_status(::RpcResponseHeaderProto_RpcStatusProto value);

  // optional uint32 serverIpcVersionNum = 3;
  bool has_serveripcversionnum() const;
  void clear_serveripcversionnum();
  static const int kServerIpcVersionNumFieldNumber = 3;
  ::google::protobuf::uint32 serveripcversionnum() const;
  void set_serveripcversionnum(::google::protobuf::uint32 value);

  // optional string exceptionClassName = 4;
  bool has_exceptionclassname() const;
  void clear_exceptionclassname();
  static const int kExceptionClassNameFieldNumber = 4;
  const ::std::string& exceptionclassname() const;
  void set_exceptionclassname(const ::std::string& value);
  void set_exceptionclassname(const char* value);
  void set_exceptionclassname(const char* value, size_t size);
  ::std::string* mutable_exceptionclassname();
  ::std::string* release_exceptionclassname();
  void set_allocated_exceptionclassname(::std::string* exceptionclassname);

  // optional string errorMsg = 5;
  bool has_errormsg() const;
  void clear_errormsg();
  static const int kErrorMsgFieldNumber = 5;
  const ::std::string& errormsg() const;
  void set_errormsg(const ::std::string& value);
  void set_errormsg(const char* value);
  void set_errormsg(const char* value, size_t size);
  ::std::string* mutable_errormsg();
  ::std::string* release_errormsg();
  void set_allocated_errormsg(::std::string* errormsg);

  // optional .RpcResponseHeaderProto.RpcErrorCodeProto errorDetail = 6;
  bool has_errordetail() const;
  void clear_errordetail();
  static const int kErrorDetailFieldNumber = 6;
  ::RpcResponseHeaderProto_RpcErrorCodeProto errordetail() const;
  void set_errordetail(::RpcResponseHeaderProto_RpcErrorCodeProto value);

  // optional bytes clientId = 7;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 7;
  const ::std::string& clientid() const;
  void set_clientid(const ::std::string& value);
  void set_clientid(const char* value);
  void set_clientid(const void* value, size_t size);
  ::std::string* mutable_clientid();
  ::std::string* release_clientid();
  void set_allocated_clientid(::std::string* clientid);

  // optional sint32 retryCount = 8 [default = -1];
  bool has_retrycount() const;
  void clear_retrycount();
  static const int kRetryCountFieldNumber = 8;
  ::google::protobuf::int32 retrycount() const;
  void set_retrycount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RpcResponseHeaderProto)
 private:
  inline void set_has_callid();
  inline void clear_has_callid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_serveripcversionnum();
  inline void clear_has_serveripcversionnum();
  inline void set_has_exceptionclassname();
  inline void clear_has_exceptionclassname();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();
  inline void set_has_errordetail();
  inline void clear_has_errordetail();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_retrycount();
  inline void clear_has_retrycount();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 callid_;
  int status_;
  ::google::protobuf::internal::ArenaStringPtr exceptionclassname_;
  ::google::protobuf::uint32 serveripcversionnum_;
  int errordetail_;
  ::google::protobuf::internal::ArenaStringPtr errormsg_;
  ::google::protobuf::internal::ArenaStringPtr clientid_;
  ::google::protobuf::int32 retrycount_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RpcResponseHeaderProto* default_instance_;
};
// -------------------------------------------------------------------

class FsPermissionProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FsPermissionProto) */ {
 public:
  FsPermissionProto();
  virtual ~FsPermissionProto();

  FsPermissionProto(const FsPermissionProto& from);

  inline FsPermissionProto& operator=(const FsPermissionProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FsPermissionProto& default_instance();

  void Swap(FsPermissionProto* other);

  // implements Message ----------------------------------------------

  inline FsPermissionProto* New() const { return New(NULL); }

  FsPermissionProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FsPermissionProto& from);
  void MergeFrom(const FsPermissionProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FsPermissionProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 perm = 1;
  bool has_perm() const;
  void clear_perm();
  static const int kPermFieldNumber = 1;
  ::google::protobuf::uint32 perm() const;
  void set_perm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:FsPermissionProto)
 private:
  inline void set_has_perm();
  inline void clear_has_perm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 perm_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static FsPermissionProto* default_instance_;
};
// -------------------------------------------------------------------

class ExtendedBlockProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ExtendedBlockProto) */ {
 public:
  ExtendedBlockProto();
  virtual ~ExtendedBlockProto();

  ExtendedBlockProto(const ExtendedBlockProto& from);

  inline ExtendedBlockProto& operator=(const ExtendedBlockProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtendedBlockProto& default_instance();

  void Swap(ExtendedBlockProto* other);

  // implements Message ----------------------------------------------

  inline ExtendedBlockProto* New() const { return New(NULL); }

  ExtendedBlockProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtendedBlockProto& from);
  void MergeFrom(const ExtendedBlockProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtendedBlockProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string poolId = 1;
  bool has_poolid() const;
  void clear_poolid();
  static const int kPoolIdFieldNumber = 1;
  const ::std::string& poolid() const;
  void set_poolid(const ::std::string& value);
  void set_poolid(const char* value);
  void set_poolid(const char* value, size_t size);
  ::std::string* mutable_poolid();
  ::std::string* release_poolid();
  void set_allocated_poolid(::std::string* poolid);

  // required uint64 blockId = 2;
  bool has_blockid() const;
  void clear_blockid();
  static const int kBlockIdFieldNumber = 2;
  ::google::protobuf::uint64 blockid() const;
  void set_blockid(::google::protobuf::uint64 value);

  // required uint64 generationStamp = 3;
  bool has_generationstamp() const;
  void clear_generationstamp();
  static const int kGenerationStampFieldNumber = 3;
  ::google::protobuf::uint64 generationstamp() const;
  void set_generationstamp(::google::protobuf::uint64 value);

  // optional uint64 numBytes = 4 [default = 0];
  bool has_numbytes() const;
  void clear_numbytes();
  static const int kNumBytesFieldNumber = 4;
  ::google::protobuf::uint64 numbytes() const;
  void set_numbytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ExtendedBlockProto)
 private:
  inline void set_has_poolid();
  inline void clear_has_poolid();
  inline void set_has_blockid();
  inline void clear_has_blockid();
  inline void set_has_generationstamp();
  inline void clear_has_generationstamp();
  inline void set_has_numbytes();
  inline void clear_has_numbytes();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr poolid_;
  ::google::protobuf::uint64 blockid_;
  ::google::protobuf::uint64 generationstamp_;
  ::google::protobuf::uint64 numbytes_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ExtendedBlockProto* default_instance_;
};
// -------------------------------------------------------------------

class DatanodeIDProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DatanodeIDProto) */ {
 public:
  DatanodeIDProto();
  virtual ~DatanodeIDProto();

  DatanodeIDProto(const DatanodeIDProto& from);

  inline DatanodeIDProto& operator=(const DatanodeIDProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatanodeIDProto& default_instance();

  void Swap(DatanodeIDProto* other);

  // implements Message ----------------------------------------------

  inline DatanodeIDProto* New() const { return New(NULL); }

  DatanodeIDProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatanodeIDProto& from);
  void MergeFrom(const DatanodeIDProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DatanodeIDProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ipAddr = 1;
  bool has_ipaddr() const;
  void clear_ipaddr();
  static const int kIpAddrFieldNumber = 1;
  const ::std::string& ipaddr() const;
  void set_ipaddr(const ::std::string& value);
  void set_ipaddr(const char* value);
  void set_ipaddr(const char* value, size_t size);
  ::std::string* mutable_ipaddr();
  ::std::string* release_ipaddr();
  void set_allocated_ipaddr(::std::string* ipaddr);

  // required string hostName = 2;
  bool has_hostname() const;
  void clear_hostname();
  static const int kHostNameFieldNumber = 2;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // required string datanodeUuid = 3;
  bool has_datanodeuuid() const;
  void clear_datanodeuuid();
  static const int kDatanodeUuidFieldNumber = 3;
  const ::std::string& datanodeuuid() const;
  void set_datanodeuuid(const ::std::string& value);
  void set_datanodeuuid(const char* value);
  void set_datanodeuuid(const char* value, size_t size);
  ::std::string* mutable_datanodeuuid();
  ::std::string* release_datanodeuuid();
  void set_allocated_datanodeuuid(::std::string* datanodeuuid);

  // required uint32 xferPort = 4;
  bool has_xferport() const;
  void clear_xferport();
  static const int kXferPortFieldNumber = 4;
  ::google::protobuf::uint32 xferport() const;
  void set_xferport(::google::protobuf::uint32 value);

  // required uint32 infoPort = 5;
  bool has_infoport() const;
  void clear_infoport();
  static const int kInfoPortFieldNumber = 5;
  ::google::protobuf::uint32 infoport() const;
  void set_infoport(::google::protobuf::uint32 value);

  // required uint32 ipcPort = 6;
  bool has_ipcport() const;
  void clear_ipcport();
  static const int kIpcPortFieldNumber = 6;
  ::google::protobuf::uint32 ipcport() const;
  void set_ipcport(::google::protobuf::uint32 value);

  // optional uint32 infoSecurePort = 7 [default = 0];
  bool has_infosecureport() const;
  void clear_infosecureport();
  static const int kInfoSecurePortFieldNumber = 7;
  ::google::protobuf::uint32 infosecureport() const;
  void set_infosecureport(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DatanodeIDProto)
 private:
  inline void set_has_ipaddr();
  inline void clear_has_ipaddr();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_datanodeuuid();
  inline void clear_has_datanodeuuid();
  inline void set_has_xferport();
  inline void clear_has_xferport();
  inline void set_has_infoport();
  inline void clear_has_infoport();
  inline void set_has_ipcport();
  inline void clear_has_ipcport();
  inline void set_has_infosecureport();
  inline void clear_has_infosecureport();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ipaddr_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::internal::ArenaStringPtr datanodeuuid_;
  ::google::protobuf::uint32 xferport_;
  ::google::protobuf::uint32 infoport_;
  ::google::protobuf::uint32 ipcport_;
  ::google::protobuf::uint32 infosecureport_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DatanodeIDProto* default_instance_;
};
// -------------------------------------------------------------------

class DatanodeInfoProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DatanodeInfoProto) */ {
 public:
  DatanodeInfoProto();
  virtual ~DatanodeInfoProto();

  DatanodeInfoProto(const DatanodeInfoProto& from);

  inline DatanodeInfoProto& operator=(const DatanodeInfoProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatanodeInfoProto& default_instance();

  void Swap(DatanodeInfoProto* other);

  // implements Message ----------------------------------------------

  inline DatanodeInfoProto* New() const { return New(NULL); }

  DatanodeInfoProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatanodeInfoProto& from);
  void MergeFrom(const DatanodeInfoProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DatanodeInfoProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DatanodeInfoProto_AdminState AdminState;
  static const AdminState NORMAL =
    DatanodeInfoProto_AdminState_NORMAL;
  static const AdminState DECOMMISSION_INPROGRESS =
    DatanodeInfoProto_AdminState_DECOMMISSION_INPROGRESS;
  static const AdminState DECOMMISSIONED =
    DatanodeInfoProto_AdminState_DECOMMISSIONED;
  static inline bool AdminState_IsValid(int value) {
    return DatanodeInfoProto_AdminState_IsValid(value);
  }
  static const AdminState AdminState_MIN =
    DatanodeInfoProto_AdminState_AdminState_MIN;
  static const AdminState AdminState_MAX =
    DatanodeInfoProto_AdminState_AdminState_MAX;
  static const int AdminState_ARRAYSIZE =
    DatanodeInfoProto_AdminState_AdminState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AdminState_descriptor() {
    return DatanodeInfoProto_AdminState_descriptor();
  }
  static inline const ::std::string& AdminState_Name(AdminState value) {
    return DatanodeInfoProto_AdminState_Name(value);
  }
  static inline bool AdminState_Parse(const ::std::string& name,
      AdminState* value) {
    return DatanodeInfoProto_AdminState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .DatanodeIDProto id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::DatanodeIDProto& id() const;
  ::DatanodeIDProto* mutable_id();
  ::DatanodeIDProto* release_id();
  void set_allocated_id(::DatanodeIDProto* id);

  // optional uint64 capacity = 2 [default = 0];
  bool has_capacity() const;
  void clear_capacity();
  static const int kCapacityFieldNumber = 2;
  ::google::protobuf::uint64 capacity() const;
  void set_capacity(::google::protobuf::uint64 value);

  // optional uint64 dfsUsed = 3 [default = 0];
  bool has_dfsused() const;
  void clear_dfsused();
  static const int kDfsUsedFieldNumber = 3;
  ::google::protobuf::uint64 dfsused() const;
  void set_dfsused(::google::protobuf::uint64 value);

  // optional uint64 remaining = 4 [default = 0];
  bool has_remaining() const;
  void clear_remaining();
  static const int kRemainingFieldNumber = 4;
  ::google::protobuf::uint64 remaining() const;
  void set_remaining(::google::protobuf::uint64 value);

  // optional uint64 blockPoolUsed = 5 [default = 0];
  bool has_blockpoolused() const;
  void clear_blockpoolused();
  static const int kBlockPoolUsedFieldNumber = 5;
  ::google::protobuf::uint64 blockpoolused() const;
  void set_blockpoolused(::google::protobuf::uint64 value);

  // optional uint64 lastUpdate = 6 [default = 0];
  bool has_lastupdate() const;
  void clear_lastupdate();
  static const int kLastUpdateFieldNumber = 6;
  ::google::protobuf::uint64 lastupdate() const;
  void set_lastupdate(::google::protobuf::uint64 value);

  // optional uint32 xceiverCount = 7 [default = 0];
  bool has_xceivercount() const;
  void clear_xceivercount();
  static const int kXceiverCountFieldNumber = 7;
  ::google::protobuf::uint32 xceivercount() const;
  void set_xceivercount(::google::protobuf::uint32 value);

  // optional string location = 8;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 8;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // optional uint64 nonDfsUsed = 9;
  bool has_nondfsused() const;
  void clear_nondfsused();
  static const int kNonDfsUsedFieldNumber = 9;
  ::google::protobuf::uint64 nondfsused() const;
  void set_nondfsused(::google::protobuf::uint64 value);

  // optional .DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
  bool has_adminstate() const;
  void clear_adminstate();
  static const int kAdminStateFieldNumber = 10;
  ::DatanodeInfoProto_AdminState adminstate() const;
  void set_adminstate(::DatanodeInfoProto_AdminState value);

  // optional uint64 cacheCapacity = 11 [default = 0];
  bool has_cachecapacity() const;
  void clear_cachecapacity();
  static const int kCacheCapacityFieldNumber = 11;
  ::google::protobuf::uint64 cachecapacity() const;
  void set_cachecapacity(::google::protobuf::uint64 value);

  // optional uint64 cacheUsed = 12 [default = 0];
  bool has_cacheused() const;
  void clear_cacheused();
  static const int kCacheUsedFieldNumber = 12;
  ::google::protobuf::uint64 cacheused() const;
  void set_cacheused(::google::protobuf::uint64 value);

  // optional uint64 lastUpdateMonotonic = 13 [default = 0];
  bool has_lastupdatemonotonic() const;
  void clear_lastupdatemonotonic();
  static const int kLastUpdateMonotonicFieldNumber = 13;
  ::google::protobuf::uint64 lastupdatemonotonic() const;
  void set_lastupdatemonotonic(::google::protobuf::uint64 value);

  // optional string upgradeDomain = 14;
  bool has_upgradedomain() const;
  void clear_upgradedomain();
  static const int kUpgradeDomainFieldNumber = 14;
  const ::std::string& upgradedomain() const;
  void set_upgradedomain(const ::std::string& value);
  void set_upgradedomain(const char* value);
  void set_upgradedomain(const char* value, size_t size);
  ::std::string* mutable_upgradedomain();
  ::std::string* release_upgradedomain();
  void set_allocated_upgradedomain(::std::string* upgradedomain);

  // @@protoc_insertion_point(class_scope:DatanodeInfoProto)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_capacity();
  inline void clear_has_capacity();
  inline void set_has_dfsused();
  inline void clear_has_dfsused();
  inline void set_has_remaining();
  inline void clear_has_remaining();
  inline void set_has_blockpoolused();
  inline void clear_has_blockpoolused();
  inline void set_has_lastupdate();
  inline void clear_has_lastupdate();
  inline void set_has_xceivercount();
  inline void clear_has_xceivercount();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_nondfsused();
  inline void clear_has_nondfsused();
  inline void set_has_adminstate();
  inline void clear_has_adminstate();
  inline void set_has_cachecapacity();
  inline void clear_has_cachecapacity();
  inline void set_has_cacheused();
  inline void clear_has_cacheused();
  inline void set_has_lastupdatemonotonic();
  inline void clear_has_lastupdatemonotonic();
  inline void set_has_upgradedomain();
  inline void clear_has_upgradedomain();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DatanodeIDProto* id_;
  ::google::protobuf::uint64 capacity_;
  ::google::protobuf::uint64 dfsused_;
  ::google::protobuf::uint64 remaining_;
  ::google::protobuf::uint64 blockpoolused_;
  ::google::protobuf::uint64 lastupdate_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::uint32 xceivercount_;
  int adminstate_;
  ::google::protobuf::uint64 nondfsused_;
  ::google::protobuf::uint64 cachecapacity_;
  ::google::protobuf::uint64 cacheused_;
  ::google::protobuf::uint64 lastupdatemonotonic_;
  ::google::protobuf::internal::ArenaStringPtr upgradedomain_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DatanodeInfoProto* default_instance_;
};
// -------------------------------------------------------------------

class TokenProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TokenProto) */ {
 public:
  TokenProto();
  virtual ~TokenProto();

  TokenProto(const TokenProto& from);

  inline TokenProto& operator=(const TokenProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TokenProto& default_instance();

  void Swap(TokenProto* other);

  // implements Message ----------------------------------------------

  inline TokenProto* New() const { return New(NULL); }

  TokenProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TokenProto& from);
  void MergeFrom(const TokenProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TokenProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes identifier = 1;
  bool has_identifier() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  const ::std::string& identifier() const;
  void set_identifier(const ::std::string& value);
  void set_identifier(const char* value);
  void set_identifier(const void* value, size_t size);
  ::std::string* mutable_identifier();
  ::std::string* release_identifier();
  void set_allocated_identifier(::std::string* identifier);

  // required bytes password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const void* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required string kind = 3;
  bool has_kind() const;
  void clear_kind();
  static const int kKindFieldNumber = 3;
  const ::std::string& kind() const;
  void set_kind(const ::std::string& value);
  void set_kind(const char* value);
  void set_kind(const char* value, size_t size);
  ::std::string* mutable_kind();
  ::std::string* release_kind();
  void set_allocated_kind(::std::string* kind);

  // required string service = 4;
  bool has_service() const;
  void clear_service();
  static const int kServiceFieldNumber = 4;
  const ::std::string& service() const;
  void set_service(const ::std::string& value);
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  ::std::string* mutable_service();
  ::std::string* release_service();
  void set_allocated_service(::std::string* service);

  // @@protoc_insertion_point(class_scope:TokenProto)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_service();
  inline void clear_has_service();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr identifier_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr kind_;
  ::google::protobuf::internal::ArenaStringPtr service_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TokenProto* default_instance_;
};
// -------------------------------------------------------------------

class FileEncryptionInfoProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FileEncryptionInfoProto) */ {
 public:
  FileEncryptionInfoProto();
  virtual ~FileEncryptionInfoProto();

  FileEncryptionInfoProto(const FileEncryptionInfoProto& from);

  inline FileEncryptionInfoProto& operator=(const FileEncryptionInfoProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileEncryptionInfoProto& default_instance();

  void Swap(FileEncryptionInfoProto* other);

  // implements Message ----------------------------------------------

  inline FileEncryptionInfoProto* New() const { return New(NULL); }

  FileEncryptionInfoProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileEncryptionInfoProto& from);
  void MergeFrom(const FileEncryptionInfoProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileEncryptionInfoProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CipherSuiteProto suite = 1;
  bool has_suite() const;
  void clear_suite();
  static const int kSuiteFieldNumber = 1;
  ::CipherSuiteProto suite() const;
  void set_suite(::CipherSuiteProto value);

  // required .CryptoProtocolVersionProto cryptoProtocolVersion = 2;
  bool has_cryptoprotocolversion() const;
  void clear_cryptoprotocolversion();
  static const int kCryptoProtocolVersionFieldNumber = 2;
  ::CryptoProtocolVersionProto cryptoprotocolversion() const;
  void set_cryptoprotocolversion(::CryptoProtocolVersionProto value);

  // required bytes key = 3;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required bytes iv = 4;
  bool has_iv() const;
  void clear_iv();
  static const int kIvFieldNumber = 4;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // required string keyName = 5;
  bool has_keyname() const;
  void clear_keyname();
  static const int kKeyNameFieldNumber = 5;
  const ::std::string& keyname() const;
  void set_keyname(const ::std::string& value);
  void set_keyname(const char* value);
  void set_keyname(const char* value, size_t size);
  ::std::string* mutable_keyname();
  ::std::string* release_keyname();
  void set_allocated_keyname(::std::string* keyname);

  // required string ezKeyVersionName = 6;
  bool has_ezkeyversionname() const;
  void clear_ezkeyversionname();
  static const int kEzKeyVersionNameFieldNumber = 6;
  const ::std::string& ezkeyversionname() const;
  void set_ezkeyversionname(const ::std::string& value);
  void set_ezkeyversionname(const char* value);
  void set_ezkeyversionname(const char* value, size_t size);
  ::std::string* mutable_ezkeyversionname();
  ::std::string* release_ezkeyversionname();
  void set_allocated_ezkeyversionname(::std::string* ezkeyversionname);

  // @@protoc_insertion_point(class_scope:FileEncryptionInfoProto)
 private:
  inline void set_has_suite();
  inline void clear_has_suite();
  inline void set_has_cryptoprotocolversion();
  inline void clear_has_cryptoprotocolversion();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_iv();
  inline void clear_has_iv();
  inline void set_has_keyname();
  inline void clear_has_keyname();
  inline void set_has_ezkeyversionname();
  inline void clear_has_ezkeyversionname();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int suite_;
  int cryptoprotocolversion_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::internal::ArenaStringPtr keyname_;
  ::google::protobuf::internal::ArenaStringPtr ezkeyversionname_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static FileEncryptionInfoProto* default_instance_;
};
// -------------------------------------------------------------------

class LocatedBlockProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LocatedBlockProto) */ {
 public:
  LocatedBlockProto();
  virtual ~LocatedBlockProto();

  LocatedBlockProto(const LocatedBlockProto& from);

  inline LocatedBlockProto& operator=(const LocatedBlockProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocatedBlockProto& default_instance();

  void Swap(LocatedBlockProto* other);

  // implements Message ----------------------------------------------

  inline LocatedBlockProto* New() const { return New(NULL); }

  LocatedBlockProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocatedBlockProto& from);
  void MergeFrom(const LocatedBlockProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocatedBlockProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ExtendedBlockProto b = 1;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 1;
  const ::ExtendedBlockProto& b() const;
  ::ExtendedBlockProto* mutable_b();
  ::ExtendedBlockProto* release_b();
  void set_allocated_b(::ExtendedBlockProto* b);

  // required uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // repeated .DatanodeInfoProto locs = 3;
  int locs_size() const;
  void clear_locs();
  static const int kLocsFieldNumber = 3;
  const ::DatanodeInfoProto& locs(int index) const;
  ::DatanodeInfoProto* mutable_locs(int index);
  ::DatanodeInfoProto* add_locs();
  ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >*
      mutable_locs();
  const ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >&
      locs() const;

  // required bool corrupt = 4;
  bool has_corrupt() const;
  void clear_corrupt();
  static const int kCorruptFieldNumber = 4;
  bool corrupt() const;
  void set_corrupt(bool value);

  // required .TokenProto blockToken = 5;
  bool has_blocktoken() const;
  void clear_blocktoken();
  static const int kBlockTokenFieldNumber = 5;
  const ::TokenProto& blocktoken() const;
  ::TokenProto* mutable_blocktoken();
  ::TokenProto* release_blocktoken();
  void set_allocated_blocktoken(::TokenProto* blocktoken);

  // repeated bool isCached = 6 [packed = true];
  int iscached_size() const;
  void clear_iscached();
  static const int kIsCachedFieldNumber = 6;
  bool iscached(int index) const;
  void set_iscached(int index, bool value);
  void add_iscached(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      iscached() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_iscached();

  // repeated .StorageTypeProto storageTypes = 7;
  int storagetypes_size() const;
  void clear_storagetypes();
  static const int kStorageTypesFieldNumber = 7;
  ::StorageTypeProto storagetypes(int index) const;
  void set_storagetypes(int index, ::StorageTypeProto value);
  void add_storagetypes(::StorageTypeProto value);
  const ::google::protobuf::RepeatedField<int>& storagetypes() const;
  ::google::protobuf::RepeatedField<int>* mutable_storagetypes();

  // repeated string storageIDs = 8;
  int storageids_size() const;
  void clear_storageids();
  static const int kStorageIDsFieldNumber = 8;
  const ::std::string& storageids(int index) const;
  ::std::string* mutable_storageids(int index);
  void set_storageids(int index, const ::std::string& value);
  void set_storageids(int index, const char* value);
  void set_storageids(int index, const char* value, size_t size);
  ::std::string* add_storageids();
  void add_storageids(const ::std::string& value);
  void add_storageids(const char* value);
  void add_storageids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& storageids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_storageids();

  // @@protoc_insertion_point(class_scope:LocatedBlockProto)
 private:
  inline void set_has_b();
  inline void clear_has_b();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_corrupt();
  inline void clear_has_corrupt();
  inline void set_has_blocktoken();
  inline void clear_has_blocktoken();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ExtendedBlockProto* b_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto > locs_;
  ::TokenProto* blocktoken_;
  ::google::protobuf::RepeatedField< bool > iscached_;
  mutable int _iscached_cached_byte_size_;
  ::google::protobuf::RepeatedField<int> storagetypes_;
  ::google::protobuf::RepeatedPtrField< ::std::string> storageids_;
  bool corrupt_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LocatedBlockProto* default_instance_;
};
// -------------------------------------------------------------------

class LocatedBlocksProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LocatedBlocksProto) */ {
 public:
  LocatedBlocksProto();
  virtual ~LocatedBlocksProto();

  LocatedBlocksProto(const LocatedBlocksProto& from);

  inline LocatedBlocksProto& operator=(const LocatedBlocksProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocatedBlocksProto& default_instance();

  void Swap(LocatedBlocksProto* other);

  // implements Message ----------------------------------------------

  inline LocatedBlocksProto* New() const { return New(NULL); }

  LocatedBlocksProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocatedBlocksProto& from);
  void MergeFrom(const LocatedBlocksProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocatedBlocksProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 fileLength = 1;
  bool has_filelength() const;
  void clear_filelength();
  static const int kFileLengthFieldNumber = 1;
  ::google::protobuf::uint64 filelength() const;
  void set_filelength(::google::protobuf::uint64 value);

  // repeated .LocatedBlockProto blocks = 2;
  int blocks_size() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 2;
  const ::LocatedBlockProto& blocks(int index) const;
  ::LocatedBlockProto* mutable_blocks(int index);
  ::LocatedBlockProto* add_blocks();
  ::google::protobuf::RepeatedPtrField< ::LocatedBlockProto >*
      mutable_blocks();
  const ::google::protobuf::RepeatedPtrField< ::LocatedBlockProto >&
      blocks() const;

  // required bool underConstruction = 3;
  bool has_underconstruction() const;
  void clear_underconstruction();
  static const int kUnderConstructionFieldNumber = 3;
  bool underconstruction() const;
  void set_underconstruction(bool value);

  // optional .LocatedBlockProto lastBlock = 4;
  bool has_lastblock() const;
  void clear_lastblock();
  static const int kLastBlockFieldNumber = 4;
  const ::LocatedBlockProto& lastblock() const;
  ::LocatedBlockProto* mutable_lastblock();
  ::LocatedBlockProto* release_lastblock();
  void set_allocated_lastblock(::LocatedBlockProto* lastblock);

  // required bool isLastBlockComplete = 5;
  bool has_islastblockcomplete() const;
  void clear_islastblockcomplete();
  static const int kIsLastBlockCompleteFieldNumber = 5;
  bool islastblockcomplete() const;
  void set_islastblockcomplete(bool value);

  // optional .FileEncryptionInfoProto fileEncryptionInfo = 6;
  bool has_fileencryptioninfo() const;
  void clear_fileencryptioninfo();
  static const int kFileEncryptionInfoFieldNumber = 6;
  const ::FileEncryptionInfoProto& fileencryptioninfo() const;
  ::FileEncryptionInfoProto* mutable_fileencryptioninfo();
  ::FileEncryptionInfoProto* release_fileencryptioninfo();
  void set_allocated_fileencryptioninfo(::FileEncryptionInfoProto* fileencryptioninfo);

  // @@protoc_insertion_point(class_scope:LocatedBlocksProto)
 private:
  inline void set_has_filelength();
  inline void clear_has_filelength();
  inline void set_has_underconstruction();
  inline void clear_has_underconstruction();
  inline void set_has_lastblock();
  inline void clear_has_lastblock();
  inline void set_has_islastblockcomplete();
  inline void clear_has_islastblockcomplete();
  inline void set_has_fileencryptioninfo();
  inline void clear_has_fileencryptioninfo();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 filelength_;
  ::google::protobuf::RepeatedPtrField< ::LocatedBlockProto > blocks_;
  ::LocatedBlockProto* lastblock_;
  ::FileEncryptionInfoProto* fileencryptioninfo_;
  bool underconstruction_;
  bool islastblockcomplete_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LocatedBlocksProto* default_instance_;
};
// -------------------------------------------------------------------

class RequestHeaderProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RequestHeaderProto) */ {
 public:
  RequestHeaderProto();
  virtual ~RequestHeaderProto();

  RequestHeaderProto(const RequestHeaderProto& from);

  inline RequestHeaderProto& operator=(const RequestHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeaderProto& default_instance();

  void Swap(RequestHeaderProto* other);

  // implements Message ----------------------------------------------

  inline RequestHeaderProto* New() const { return New(NULL); }

  RequestHeaderProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestHeaderProto& from);
  void MergeFrom(const RequestHeaderProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestHeaderProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string methodName = 1;
  bool has_methodname() const;
  void clear_methodname();
  static const int kMethodNameFieldNumber = 1;
  const ::std::string& methodname() const;
  void set_methodname(const ::std::string& value);
  void set_methodname(const char* value);
  void set_methodname(const char* value, size_t size);
  ::std::string* mutable_methodname();
  ::std::string* release_methodname();
  void set_allocated_methodname(::std::string* methodname);

  // required string declaringClassProtocolName = 2;
  bool has_declaringclassprotocolname() const;
  void clear_declaringclassprotocolname();
  static const int kDeclaringClassProtocolNameFieldNumber = 2;
  const ::std::string& declaringclassprotocolname() const;
  void set_declaringclassprotocolname(const ::std::string& value);
  void set_declaringclassprotocolname(const char* value);
  void set_declaringclassprotocolname(const char* value, size_t size);
  ::std::string* mutable_declaringclassprotocolname();
  ::std::string* release_declaringclassprotocolname();
  void set_allocated_declaringclassprotocolname(::std::string* declaringclassprotocolname);

  // required uint64 clientProtocolVersion = 3;
  bool has_clientprotocolversion() const;
  void clear_clientprotocolversion();
  static const int kClientProtocolVersionFieldNumber = 3;
  ::google::protobuf::uint64 clientprotocolversion() const;
  void set_clientprotocolversion(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:RequestHeaderProto)
 private:
  inline void set_has_methodname();
  inline void clear_has_methodname();
  inline void set_has_declaringclassprotocolname();
  inline void clear_has_declaringclassprotocolname();
  inline void set_has_clientprotocolversion();
  inline void clear_has_clientprotocolversion();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr methodname_;
  ::google::protobuf::internal::ArenaStringPtr declaringclassprotocolname_;
  ::google::protobuf::uint64 clientprotocolversion_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RequestHeaderProto* default_instance_;
};
// -------------------------------------------------------------------

class StorageInfoProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StorageInfoProto) */ {
 public:
  StorageInfoProto();
  virtual ~StorageInfoProto();

  StorageInfoProto(const StorageInfoProto& from);

  inline StorageInfoProto& operator=(const StorageInfoProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageInfoProto& default_instance();

  void Swap(StorageInfoProto* other);

  // implements Message ----------------------------------------------

  inline StorageInfoProto* New() const { return New(NULL); }

  StorageInfoProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorageInfoProto& from);
  void MergeFrom(const StorageInfoProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StorageInfoProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 layoutVersion = 1;
  bool has_layoutversion() const;
  void clear_layoutversion();
  static const int kLayoutVersionFieldNumber = 1;
  ::google::protobuf::uint32 layoutversion() const;
  void set_layoutversion(::google::protobuf::uint32 value);

  // required uint32 namespceID = 2;
  bool has_namespceid() const;
  void clear_namespceid();
  static const int kNamespceIDFieldNumber = 2;
  ::google::protobuf::uint32 namespceid() const;
  void set_namespceid(::google::protobuf::uint32 value);

  // required string clusterID = 3;
  bool has_clusterid() const;
  void clear_clusterid();
  static const int kClusterIDFieldNumber = 3;
  const ::std::string& clusterid() const;
  void set_clusterid(const ::std::string& value);
  void set_clusterid(const char* value);
  void set_clusterid(const char* value, size_t size);
  ::std::string* mutable_clusterid();
  ::std::string* release_clusterid();
  void set_allocated_clusterid(::std::string* clusterid);

  // required uint64 cTime = 4;
  bool has_ctime() const;
  void clear_ctime();
  static const int kCTimeFieldNumber = 4;
  ::google::protobuf::uint64 ctime() const;
  void set_ctime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:StorageInfoProto)
 private:
  inline void set_has_layoutversion();
  inline void clear_has_layoutversion();
  inline void set_has_namespceid();
  inline void clear_has_namespceid();
  inline void set_has_clusterid();
  inline void clear_has_clusterid();
  inline void set_has_ctime();
  inline void clear_has_ctime();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 layoutversion_;
  ::google::protobuf::uint32 namespceid_;
  ::google::protobuf::internal::ArenaStringPtr clusterid_;
  ::google::protobuf::uint64 ctime_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static StorageInfoProto* default_instance_;
};
// -------------------------------------------------------------------

class BlockKeyProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BlockKeyProto) */ {
 public:
  BlockKeyProto();
  virtual ~BlockKeyProto();

  BlockKeyProto(const BlockKeyProto& from);

  inline BlockKeyProto& operator=(const BlockKeyProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockKeyProto& default_instance();

  void Swap(BlockKeyProto* other);

  // implements Message ----------------------------------------------

  inline BlockKeyProto* New() const { return New(NULL); }

  BlockKeyProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockKeyProto& from);
  void MergeFrom(const BlockKeyProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockKeyProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 keyId = 1;
  bool has_keyid() const;
  void clear_keyid();
  static const int kKeyIdFieldNumber = 1;
  ::google::protobuf::uint32 keyid() const;
  void set_keyid(::google::protobuf::uint32 value);

  // required uint64 expiryDate = 2;
  bool has_expirydate() const;
  void clear_expirydate();
  static const int kExpiryDateFieldNumber = 2;
  ::google::protobuf::uint64 expirydate() const;
  void set_expirydate(::google::protobuf::uint64 value);

  // optional bytes keyBytes = 3;
  bool has_keybytes() const;
  void clear_keybytes();
  static const int kKeyBytesFieldNumber = 3;
  const ::std::string& keybytes() const;
  void set_keybytes(const ::std::string& value);
  void set_keybytes(const char* value);
  void set_keybytes(const void* value, size_t size);
  ::std::string* mutable_keybytes();
  ::std::string* release_keybytes();
  void set_allocated_keybytes(::std::string* keybytes);

  // @@protoc_insertion_point(class_scope:BlockKeyProto)
 private:
  inline void set_has_keyid();
  inline void clear_has_keyid();
  inline void set_has_expirydate();
  inline void clear_has_expirydate();
  inline void set_has_keybytes();
  inline void clear_has_keybytes();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 expirydate_;
  ::google::protobuf::internal::ArenaStringPtr keybytes_;
  ::google::protobuf::uint32 keyid_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static BlockKeyProto* default_instance_;
};
// -------------------------------------------------------------------

class ExportedBlockKeysProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ExportedBlockKeysProto) */ {
 public:
  ExportedBlockKeysProto();
  virtual ~ExportedBlockKeysProto();

  ExportedBlockKeysProto(const ExportedBlockKeysProto& from);

  inline ExportedBlockKeysProto& operator=(const ExportedBlockKeysProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExportedBlockKeysProto& default_instance();

  void Swap(ExportedBlockKeysProto* other);

  // implements Message ----------------------------------------------

  inline ExportedBlockKeysProto* New() const { return New(NULL); }

  ExportedBlockKeysProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExportedBlockKeysProto& from);
  void MergeFrom(const ExportedBlockKeysProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExportedBlockKeysProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool isBlockTokenEnabled = 1;
  bool has_isblocktokenenabled() const;
  void clear_isblocktokenenabled();
  static const int kIsBlockTokenEnabledFieldNumber = 1;
  bool isblocktokenenabled() const;
  void set_isblocktokenenabled(bool value);

  // required uint64 keyUpdateInterval = 2;
  bool has_keyupdateinterval() const;
  void clear_keyupdateinterval();
  static const int kKeyUpdateIntervalFieldNumber = 2;
  ::google::protobuf::uint64 keyupdateinterval() const;
  void set_keyupdateinterval(::google::protobuf::uint64 value);

  // required uint64 tokenLifeTime = 3;
  bool has_tokenlifetime() const;
  void clear_tokenlifetime();
  static const int kTokenLifeTimeFieldNumber = 3;
  ::google::protobuf::uint64 tokenlifetime() const;
  void set_tokenlifetime(::google::protobuf::uint64 value);

  // required .BlockKeyProto currentKey = 4;
  bool has_currentkey() const;
  void clear_currentkey();
  static const int kCurrentKeyFieldNumber = 4;
  const ::BlockKeyProto& currentkey() const;
  ::BlockKeyProto* mutable_currentkey();
  ::BlockKeyProto* release_currentkey();
  void set_allocated_currentkey(::BlockKeyProto* currentkey);

  // repeated .BlockKeyProto allKeys = 5;
  int allkeys_size() const;
  void clear_allkeys();
  static const int kAllKeysFieldNumber = 5;
  const ::BlockKeyProto& allkeys(int index) const;
  ::BlockKeyProto* mutable_allkeys(int index);
  ::BlockKeyProto* add_allkeys();
  ::google::protobuf::RepeatedPtrField< ::BlockKeyProto >*
      mutable_allkeys();
  const ::google::protobuf::RepeatedPtrField< ::BlockKeyProto >&
      allkeys() const;

  // @@protoc_insertion_point(class_scope:ExportedBlockKeysProto)
 private:
  inline void set_has_isblocktokenenabled();
  inline void clear_has_isblocktokenenabled();
  inline void set_has_keyupdateinterval();
  inline void clear_has_keyupdateinterval();
  inline void set_has_tokenlifetime();
  inline void clear_has_tokenlifetime();
  inline void set_has_currentkey();
  inline void clear_has_currentkey();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 keyupdateinterval_;
  ::google::protobuf::uint64 tokenlifetime_;
  ::BlockKeyProto* currentkey_;
  ::google::protobuf::RepeatedPtrField< ::BlockKeyProto > allkeys_;
  bool isblocktokenenabled_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ExportedBlockKeysProto* default_instance_;
};
// -------------------------------------------------------------------

class DatanodeRegistrationProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DatanodeRegistrationProto) */ {
 public:
  DatanodeRegistrationProto();
  virtual ~DatanodeRegistrationProto();

  DatanodeRegistrationProto(const DatanodeRegistrationProto& from);

  inline DatanodeRegistrationProto& operator=(const DatanodeRegistrationProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatanodeRegistrationProto& default_instance();

  void Swap(DatanodeRegistrationProto* other);

  // implements Message ----------------------------------------------

  inline DatanodeRegistrationProto* New() const { return New(NULL); }

  DatanodeRegistrationProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatanodeRegistrationProto& from);
  void MergeFrom(const DatanodeRegistrationProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DatanodeRegistrationProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DatanodeIDProto datanodeID = 1;
  bool has_datanodeid() const;
  void clear_datanodeid();
  static const int kDatanodeIDFieldNumber = 1;
  const ::DatanodeIDProto& datanodeid() const;
  ::DatanodeIDProto* mutable_datanodeid();
  ::DatanodeIDProto* release_datanodeid();
  void set_allocated_datanodeid(::DatanodeIDProto* datanodeid);

  // optional .StorageInfoProto storageInfo = 2;
  bool has_storageinfo() const;
  void clear_storageinfo();
  static const int kStorageInfoFieldNumber = 2;
  const ::StorageInfoProto& storageinfo() const;
  ::StorageInfoProto* mutable_storageinfo();
  ::StorageInfoProto* release_storageinfo();
  void set_allocated_storageinfo(::StorageInfoProto* storageinfo);

  // optional .ExportedBlockKeysProto keys = 3;
  bool has_keys() const;
  void clear_keys();
  static const int kKeysFieldNumber = 3;
  const ::ExportedBlockKeysProto& keys() const;
  ::ExportedBlockKeysProto* mutable_keys();
  ::ExportedBlockKeysProto* release_keys();
  void set_allocated_keys(::ExportedBlockKeysProto* keys);

  // optional string softwareVersion = 4;
  bool has_softwareversion() const;
  void clear_softwareversion();
  static const int kSoftwareVersionFieldNumber = 4;
  const ::std::string& softwareversion() const;
  void set_softwareversion(const ::std::string& value);
  void set_softwareversion(const char* value);
  void set_softwareversion(const char* value, size_t size);
  ::std::string* mutable_softwareversion();
  ::std::string* release_softwareversion();
  void set_allocated_softwareversion(::std::string* softwareversion);

  // optional bool master = 5;
  bool has_master() const;
  void clear_master();
  static const int kMasterFieldNumber = 5;
  bool master() const;
  void set_master(bool value);

  // @@protoc_insertion_point(class_scope:DatanodeRegistrationProto)
 private:
  inline void set_has_datanodeid();
  inline void clear_has_datanodeid();
  inline void set_has_storageinfo();
  inline void clear_has_storageinfo();
  inline void set_has_keys();
  inline void clear_has_keys();
  inline void set_has_softwareversion();
  inline void clear_has_softwareversion();
  inline void set_has_master();
  inline void clear_has_master();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DatanodeIDProto* datanodeid_;
  ::StorageInfoProto* storageinfo_;
  ::ExportedBlockKeysProto* keys_;
  ::google::protobuf::internal::ArenaStringPtr softwareversion_;
  bool master_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DatanodeRegistrationProto* default_instance_;
};
// -------------------------------------------------------------------

class RegisterDatanodeRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RegisterDatanodeRequestProto) */ {
 public:
  RegisterDatanodeRequestProto();
  virtual ~RegisterDatanodeRequestProto();

  RegisterDatanodeRequestProto(const RegisterDatanodeRequestProto& from);

  inline RegisterDatanodeRequestProto& operator=(const RegisterDatanodeRequestProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterDatanodeRequestProto& default_instance();

  void Swap(RegisterDatanodeRequestProto* other);

  // implements Message ----------------------------------------------

  inline RegisterDatanodeRequestProto* New() const { return New(NULL); }

  RegisterDatanodeRequestProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterDatanodeRequestProto& from);
  void MergeFrom(const RegisterDatanodeRequestProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterDatanodeRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DatanodeRegistrationProto registration = 1;
  bool has_registration() const;
  void clear_registration();
  static const int kRegistrationFieldNumber = 1;
  const ::DatanodeRegistrationProto& registration() const;
  ::DatanodeRegistrationProto* mutable_registration();
  ::DatanodeRegistrationProto* release_registration();
  void set_allocated_registration(::DatanodeRegistrationProto* registration);

  // @@protoc_insertion_point(class_scope:RegisterDatanodeRequestProto)
 private:
  inline void set_has_registration();
  inline void clear_has_registration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DatanodeRegistrationProto* registration_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RegisterDatanodeRequestProto* default_instance_;
};
// -------------------------------------------------------------------

class RegisterDatanodeResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RegisterDatanodeResponseProto) */ {
 public:
  RegisterDatanodeResponseProto();
  virtual ~RegisterDatanodeResponseProto();

  RegisterDatanodeResponseProto(const RegisterDatanodeResponseProto& from);

  inline RegisterDatanodeResponseProto& operator=(const RegisterDatanodeResponseProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterDatanodeResponseProto& default_instance();

  void Swap(RegisterDatanodeResponseProto* other);

  // implements Message ----------------------------------------------

  inline RegisterDatanodeResponseProto* New() const { return New(NULL); }

  RegisterDatanodeResponseProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterDatanodeResponseProto& from);
  void MergeFrom(const RegisterDatanodeResponseProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterDatanodeResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DatanodeRegistrationProto registration = 1;
  bool has_registration() const;
  void clear_registration();
  static const int kRegistrationFieldNumber = 1;
  const ::DatanodeRegistrationProto& registration() const;
  ::DatanodeRegistrationProto* mutable_registration();
  ::DatanodeRegistrationProto* release_registration();
  void set_allocated_registration(::DatanodeRegistrationProto* registration);

  // @@protoc_insertion_point(class_scope:RegisterDatanodeResponseProto)
 private:
  inline void set_has_registration();
  inline void clear_has_registration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DatanodeRegistrationProto* registration_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RegisterDatanodeResponseProto* default_instance_;
};
// -------------------------------------------------------------------

class DatanodeHeartbeatRequestProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DatanodeHeartbeatRequestProto) */ {
 public:
  DatanodeHeartbeatRequestProto();
  virtual ~DatanodeHeartbeatRequestProto();

  DatanodeHeartbeatRequestProto(const DatanodeHeartbeatRequestProto& from);

  inline DatanodeHeartbeatRequestProto& operator=(const DatanodeHeartbeatRequestProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatanodeHeartbeatRequestProto& default_instance();

  void Swap(DatanodeHeartbeatRequestProto* other);

  // implements Message ----------------------------------------------

  inline DatanodeHeartbeatRequestProto* New() const { return New(NULL); }

  DatanodeHeartbeatRequestProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatanodeHeartbeatRequestProto& from);
  void MergeFrom(const DatanodeHeartbeatRequestProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DatanodeHeartbeatRequestProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .DatanodeIDProto id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::DatanodeIDProto& id() const;
  ::DatanodeIDProto* mutable_id();
  ::DatanodeIDProto* release_id();
  void set_allocated_id(::DatanodeIDProto* id);

  // @@protoc_insertion_point(class_scope:DatanodeHeartbeatRequestProto)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::DatanodeIDProto* id_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DatanodeHeartbeatRequestProto* default_instance_;
};
// -------------------------------------------------------------------

class DatanodeHeartbeatResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DatanodeHeartbeatResponseProto) */ {
 public:
  DatanodeHeartbeatResponseProto();
  virtual ~DatanodeHeartbeatResponseProto();

  DatanodeHeartbeatResponseProto(const DatanodeHeartbeatResponseProto& from);

  inline DatanodeHeartbeatResponseProto& operator=(const DatanodeHeartbeatResponseProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatanodeHeartbeatResponseProto& default_instance();

  void Swap(DatanodeHeartbeatResponseProto* other);

  // implements Message ----------------------------------------------

  inline DatanodeHeartbeatResponseProto* New() const { return New(NULL); }

  DatanodeHeartbeatResponseProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatanodeHeartbeatResponseProto& from);
  void MergeFrom(const DatanodeHeartbeatResponseProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DatanodeHeartbeatResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DatanodeHeartbeatResponseProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DatanodeHeartbeatResponseProto* default_instance_;
};
// -------------------------------------------------------------------

class DataTransferTraceInfoProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DataTransferTraceInfoProto) */ {
 public:
  DataTransferTraceInfoProto();
  virtual ~DataTransferTraceInfoProto();

  DataTransferTraceInfoProto(const DataTransferTraceInfoProto& from);

  inline DataTransferTraceInfoProto& operator=(const DataTransferTraceInfoProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataTransferTraceInfoProto& default_instance();

  void Swap(DataTransferTraceInfoProto* other);

  // implements Message ----------------------------------------------

  inline DataTransferTraceInfoProto* New() const { return New(NULL); }

  DataTransferTraceInfoProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataTransferTraceInfoProto& from);
  void MergeFrom(const DataTransferTraceInfoProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataTransferTraceInfoProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 traceId = 1;
  bool has_traceid() const;
  void clear_traceid();
  static const int kTraceIdFieldNumber = 1;
  ::google::protobuf::uint64 traceid() const;
  void set_traceid(::google::protobuf::uint64 value);

  // required uint64 parentId = 2;
  bool has_parentid() const;
  void clear_parentid();
  static const int kParentIdFieldNumber = 2;
  ::google::protobuf::uint64 parentid() const;
  void set_parentid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:DataTransferTraceInfoProto)
 private:
  inline void set_has_traceid();
  inline void clear_has_traceid();
  inline void set_has_parentid();
  inline void clear_has_parentid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 traceid_;
  ::google::protobuf::uint64 parentid_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DataTransferTraceInfoProto* default_instance_;
};
// -------------------------------------------------------------------

class BaseHeaderProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BaseHeaderProto) */ {
 public:
  BaseHeaderProto();
  virtual ~BaseHeaderProto();

  BaseHeaderProto(const BaseHeaderProto& from);

  inline BaseHeaderProto& operator=(const BaseHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseHeaderProto& default_instance();

  void Swap(BaseHeaderProto* other);

  // implements Message ----------------------------------------------

  inline BaseHeaderProto* New() const { return New(NULL); }

  BaseHeaderProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseHeaderProto& from);
  void MergeFrom(const BaseHeaderProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BaseHeaderProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ExtendedBlockProto block = 1;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 1;
  const ::ExtendedBlockProto& block() const;
  ::ExtendedBlockProto* mutable_block();
  ::ExtendedBlockProto* release_block();
  void set_allocated_block(::ExtendedBlockProto* block);

  // optional .TokenProto token = 2;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::TokenProto& token() const;
  ::TokenProto* mutable_token();
  ::TokenProto* release_token();
  void set_allocated_token(::TokenProto* token);

  // optional .DataTransferTraceInfoProto traceInfo = 3;
  bool has_traceinfo() const;
  void clear_traceinfo();
  static const int kTraceInfoFieldNumber = 3;
  const ::DataTransferTraceInfoProto& traceinfo() const;
  ::DataTransferTraceInfoProto* mutable_traceinfo();
  ::DataTransferTraceInfoProto* release_traceinfo();
  void set_allocated_traceinfo(::DataTransferTraceInfoProto* traceinfo);

  // @@protoc_insertion_point(class_scope:BaseHeaderProto)
 private:
  inline void set_has_block();
  inline void clear_has_block();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_traceinfo();
  inline void clear_has_traceinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ExtendedBlockProto* block_;
  ::TokenProto* token_;
  ::DataTransferTraceInfoProto* traceinfo_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static BaseHeaderProto* default_instance_;
};
// -------------------------------------------------------------------

class ClientOperationHeaderProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ClientOperationHeaderProto) */ {
 public:
  ClientOperationHeaderProto();
  virtual ~ClientOperationHeaderProto();

  ClientOperationHeaderProto(const ClientOperationHeaderProto& from);

  inline ClientOperationHeaderProto& operator=(const ClientOperationHeaderProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientOperationHeaderProto& default_instance();

  void Swap(ClientOperationHeaderProto* other);

  // implements Message ----------------------------------------------

  inline ClientOperationHeaderProto* New() const { return New(NULL); }

  ClientOperationHeaderProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientOperationHeaderProto& from);
  void MergeFrom(const ClientOperationHeaderProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientOperationHeaderProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .BaseHeaderProto baseHeader = 1;
  bool has_baseheader() const;
  void clear_baseheader();
  static const int kBaseHeaderFieldNumber = 1;
  const ::BaseHeaderProto& baseheader() const;
  ::BaseHeaderProto* mutable_baseheader();
  ::BaseHeaderProto* release_baseheader();
  void set_allocated_baseheader(::BaseHeaderProto* baseheader);

  // required string clientName = 2;
  bool has_clientname() const;
  void clear_clientname();
  static const int kClientNameFieldNumber = 2;
  const ::std::string& clientname() const;
  void set_clientname(const ::std::string& value);
  void set_clientname(const char* value);
  void set_clientname(const char* value, size_t size);
  ::std::string* mutable_clientname();
  ::std::string* release_clientname();
  void set_allocated_clientname(::std::string* clientname);

  // @@protoc_insertion_point(class_scope:ClientOperationHeaderProto)
 private:
  inline void set_has_baseheader();
  inline void clear_has_baseheader();
  inline void set_has_clientname();
  inline void clear_has_clientname();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::BaseHeaderProto* baseheader_;
  ::google::protobuf::internal::ArenaStringPtr clientname_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ClientOperationHeaderProto* default_instance_;
};
// -------------------------------------------------------------------

class OpTransferBlockProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpTransferBlockProto) */ {
 public:
  OpTransferBlockProto();
  virtual ~OpTransferBlockProto();

  OpTransferBlockProto(const OpTransferBlockProto& from);

  inline OpTransferBlockProto& operator=(const OpTransferBlockProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpTransferBlockProto& default_instance();

  void Swap(OpTransferBlockProto* other);

  // implements Message ----------------------------------------------

  inline OpTransferBlockProto* New() const { return New(NULL); }

  OpTransferBlockProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpTransferBlockProto& from);
  void MergeFrom(const OpTransferBlockProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpTransferBlockProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ClientOperationHeaderProto header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::ClientOperationHeaderProto& header() const;
  ::ClientOperationHeaderProto* mutable_header();
  ::ClientOperationHeaderProto* release_header();
  void set_allocated_header(::ClientOperationHeaderProto* header);

  // repeated .DatanodeInfoProto targets = 2;
  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 2;
  const ::DatanodeInfoProto& targets(int index) const;
  ::DatanodeInfoProto* mutable_targets(int index);
  ::DatanodeInfoProto* add_targets();
  ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >*
      mutable_targets();
  const ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >&
      targets() const;

  // repeated .StorageTypeProto targetStorageTypes = 3;
  int targetstoragetypes_size() const;
  void clear_targetstoragetypes();
  static const int kTargetStorageTypesFieldNumber = 3;
  ::StorageTypeProto targetstoragetypes(int index) const;
  void set_targetstoragetypes(int index, ::StorageTypeProto value);
  void add_targetstoragetypes(::StorageTypeProto value);
  const ::google::protobuf::RepeatedField<int>& targetstoragetypes() const;
  ::google::protobuf::RepeatedField<int>* mutable_targetstoragetypes();

  // @@protoc_insertion_point(class_scope:OpTransferBlockProto)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ClientOperationHeaderProto* header_;
  ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto > targets_;
  ::google::protobuf::RepeatedField<int> targetstoragetypes_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static OpTransferBlockProto* default_instance_;
};
// -------------------------------------------------------------------

class OpBlockChecksumResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OpBlockChecksumResponseProto) */ {
 public:
  OpBlockChecksumResponseProto();
  virtual ~OpBlockChecksumResponseProto();

  OpBlockChecksumResponseProto(const OpBlockChecksumResponseProto& from);

  inline OpBlockChecksumResponseProto& operator=(const OpBlockChecksumResponseProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpBlockChecksumResponseProto& default_instance();

  void Swap(OpBlockChecksumResponseProto* other);

  // implements Message ----------------------------------------------

  inline OpBlockChecksumResponseProto* New() const { return New(NULL); }

  OpBlockChecksumResponseProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpBlockChecksumResponseProto& from);
  void MergeFrom(const OpBlockChecksumResponseProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OpBlockChecksumResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 bytesPerCrc = 1;
  bool has_bytespercrc() const;
  void clear_bytespercrc();
  static const int kBytesPerCrcFieldNumber = 1;
  ::google::protobuf::uint32 bytespercrc() const;
  void set_bytespercrc(::google::protobuf::uint32 value);

  // required uint64 crcPerBlock = 2;
  bool has_crcperblock() const;
  void clear_crcperblock();
  static const int kCrcPerBlockFieldNumber = 2;
  ::google::protobuf::uint64 crcperblock() const;
  void set_crcperblock(::google::protobuf::uint64 value);

  // required bytes md5 = 3;
  bool has_md5() const;
  void clear_md5();
  static const int kMd5FieldNumber = 3;
  const ::std::string& md5() const;
  void set_md5(const ::std::string& value);
  void set_md5(const char* value);
  void set_md5(const void* value, size_t size);
  ::std::string* mutable_md5();
  ::std::string* release_md5();
  void set_allocated_md5(::std::string* md5);

  // optional .ChecksumTypeProto crcType = 4;
  bool has_crctype() const;
  void clear_crctype();
  static const int kCrcTypeFieldNumber = 4;
  ::ChecksumTypeProto crctype() const;
  void set_crctype(::ChecksumTypeProto value);

  // @@protoc_insertion_point(class_scope:OpBlockChecksumResponseProto)
 private:
  inline void set_has_bytespercrc();
  inline void clear_has_bytespercrc();
  inline void set_has_crcperblock();
  inline void clear_has_crcperblock();
  inline void set_has_md5();
  inline void clear_has_md5();
  inline void set_has_crctype();
  inline void clear_has_crctype();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 crcperblock_;
  ::google::protobuf::uint32 bytespercrc_;
  int crctype_;
  ::google::protobuf::internal::ArenaStringPtr md5_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static OpBlockChecksumResponseProto* default_instance_;
};
// -------------------------------------------------------------------

class ChecksumProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ChecksumProto) */ {
 public:
  ChecksumProto();
  virtual ~ChecksumProto();

  ChecksumProto(const ChecksumProto& from);

  inline ChecksumProto& operator=(const ChecksumProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChecksumProto& default_instance();

  void Swap(ChecksumProto* other);

  // implements Message ----------------------------------------------

  inline ChecksumProto* New() const { return New(NULL); }

  ChecksumProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChecksumProto& from);
  void MergeFrom(const ChecksumProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChecksumProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ChecksumTypeProto type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ChecksumTypeProto type() const;
  void set_type(::ChecksumTypeProto value);

  // required uint32 bytesPerChecksum = 2;
  bool has_bytesperchecksum() const;
  void clear_bytesperchecksum();
  static const int kBytesPerChecksumFieldNumber = 2;
  ::google::protobuf::uint32 bytesperchecksum() const;
  void set_bytesperchecksum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ChecksumProto)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_bytesperchecksum();
  inline void clear_has_bytesperchecksum();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 bytesperchecksum_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ChecksumProto* default_instance_;
};
// -------------------------------------------------------------------

class ReadOpChecksumInfoProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ReadOpChecksumInfoProto) */ {
 public:
  ReadOpChecksumInfoProto();
  virtual ~ReadOpChecksumInfoProto();

  ReadOpChecksumInfoProto(const ReadOpChecksumInfoProto& from);

  inline ReadOpChecksumInfoProto& operator=(const ReadOpChecksumInfoProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadOpChecksumInfoProto& default_instance();

  void Swap(ReadOpChecksumInfoProto* other);

  // implements Message ----------------------------------------------

  inline ReadOpChecksumInfoProto* New() const { return New(NULL); }

  ReadOpChecksumInfoProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadOpChecksumInfoProto& from);
  void MergeFrom(const ReadOpChecksumInfoProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadOpChecksumInfoProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ChecksumProto checksum = 1;
  bool has_checksum() const;
  void clear_checksum();
  static const int kChecksumFieldNumber = 1;
  const ::ChecksumProto& checksum() const;
  ::ChecksumProto* mutable_checksum();
  ::ChecksumProto* release_checksum();
  void set_allocated_checksum(::ChecksumProto* checksum);

  // required uint64 chunkOffset = 2;
  bool has_chunkoffset() const;
  void clear_chunkoffset();
  static const int kChunkOffsetFieldNumber = 2;
  ::google::protobuf::uint64 chunkoffset() const;
  void set_chunkoffset(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ReadOpChecksumInfoProto)
 private:
  inline void set_has_checksum();
  inline void clear_has_checksum();
  inline void set_has_chunkoffset();
  inline void clear_has_chunkoffset();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ChecksumProto* checksum_;
  ::google::protobuf::uint64 chunkoffset_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ReadOpChecksumInfoProto* default_instance_;
};
// -------------------------------------------------------------------

class BlockOpResponseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BlockOpResponseProto) */ {
 public:
  BlockOpResponseProto();
  virtual ~BlockOpResponseProto();

  BlockOpResponseProto(const BlockOpResponseProto& from);

  inline BlockOpResponseProto& operator=(const BlockOpResponseProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockOpResponseProto& default_instance();

  void Swap(BlockOpResponseProto* other);

  // implements Message ----------------------------------------------

  inline BlockOpResponseProto* New() const { return New(NULL); }

  BlockOpResponseProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockOpResponseProto& from);
  void MergeFrom(const BlockOpResponseProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BlockOpResponseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::Status status() const;
  void set_status(::Status value);

  // optional string firstBadLink = 2;
  bool has_firstbadlink() const;
  void clear_firstbadlink();
  static const int kFirstBadLinkFieldNumber = 2;
  const ::std::string& firstbadlink() const;
  void set_firstbadlink(const ::std::string& value);
  void set_firstbadlink(const char* value);
  void set_firstbadlink(const char* value, size_t size);
  ::std::string* mutable_firstbadlink();
  ::std::string* release_firstbadlink();
  void set_allocated_firstbadlink(::std::string* firstbadlink);

  // optional .OpBlockChecksumResponseProto checksumResponse = 3;
  bool has_checksumresponse() const;
  void clear_checksumresponse();
  static const int kChecksumResponseFieldNumber = 3;
  const ::OpBlockChecksumResponseProto& checksumresponse() const;
  ::OpBlockChecksumResponseProto* mutable_checksumresponse();
  ::OpBlockChecksumResponseProto* release_checksumresponse();
  void set_allocated_checksumresponse(::OpBlockChecksumResponseProto* checksumresponse);

  // optional .ReadOpChecksumInfoProto readOpChecksumInfo = 4;
  bool has_readopchecksuminfo() const;
  void clear_readopchecksuminfo();
  static const int kReadOpChecksumInfoFieldNumber = 4;
  const ::ReadOpChecksumInfoProto& readopchecksuminfo() const;
  ::ReadOpChecksumInfoProto* mutable_readopchecksuminfo();
  ::ReadOpChecksumInfoProto* release_readopchecksuminfo();
  void set_allocated_readopchecksuminfo(::ReadOpChecksumInfoProto* readopchecksuminfo);

  // optional string message = 5;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 5;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional uint32 shortCircuitAccessVersion = 6;
  bool has_shortcircuitaccessversion() const;
  void clear_shortcircuitaccessversion();
  static const int kShortCircuitAccessVersionFieldNumber = 6;
  ::google::protobuf::uint32 shortcircuitaccessversion() const;
  void set_shortcircuitaccessversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:BlockOpResponseProto)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_firstbadlink();
  inline void clear_has_firstbadlink();
  inline void set_has_checksumresponse();
  inline void clear_has_checksumresponse();
  inline void set_has_readopchecksuminfo();
  inline void clear_has_readopchecksuminfo();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_shortcircuitaccessversion();
  inline void clear_has_shortcircuitaccessversion();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr firstbadlink_;
  ::OpBlockChecksumResponseProto* checksumresponse_;
  int status_;
  ::google::protobuf::uint32 shortcircuitaccessversion_;
  ::ReadOpChecksumInfoProto* readopchecksuminfo_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static BlockOpResponseProto* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RPCTraceInfoProto

// optional int64 traceId = 1;
inline bool RPCTraceInfoProto::has_traceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RPCTraceInfoProto::set_has_traceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RPCTraceInfoProto::clear_has_traceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RPCTraceInfoProto::clear_traceid() {
  traceid_ = GOOGLE_LONGLONG(0);
  clear_has_traceid();
}
inline ::google::protobuf::int64 RPCTraceInfoProto::traceid() const {
  // @@protoc_insertion_point(field_get:RPCTraceInfoProto.traceId)
  return traceid_;
}
inline void RPCTraceInfoProto::set_traceid(::google::protobuf::int64 value) {
  set_has_traceid();
  traceid_ = value;
  // @@protoc_insertion_point(field_set:RPCTraceInfoProto.traceId)
}

// optional int64 parentId = 2;
inline bool RPCTraceInfoProto::has_parentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RPCTraceInfoProto::set_has_parentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RPCTraceInfoProto::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RPCTraceInfoProto::clear_parentid() {
  parentid_ = GOOGLE_LONGLONG(0);
  clear_has_parentid();
}
inline ::google::protobuf::int64 RPCTraceInfoProto::parentid() const {
  // @@protoc_insertion_point(field_get:RPCTraceInfoProto.parentId)
  return parentid_;
}
inline void RPCTraceInfoProto::set_parentid(::google::protobuf::int64 value) {
  set_has_parentid();
  parentid_ = value;
  // @@protoc_insertion_point(field_set:RPCTraceInfoProto.parentId)
}

// -------------------------------------------------------------------

// RPCCallerContextProto

// required string context = 1;
inline bool RPCCallerContextProto::has_context() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RPCCallerContextProto::set_has_context() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RPCCallerContextProto::clear_has_context() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RPCCallerContextProto::clear_context() {
  context_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_context();
}
inline const ::std::string& RPCCallerContextProto::context() const {
  // @@protoc_insertion_point(field_get:RPCCallerContextProto.context)
  return context_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RPCCallerContextProto::set_context(const ::std::string& value) {
  set_has_context();
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RPCCallerContextProto.context)
}
inline void RPCCallerContextProto::set_context(const char* value) {
  set_has_context();
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RPCCallerContextProto.context)
}
inline void RPCCallerContextProto::set_context(const char* value, size_t size) {
  set_has_context();
  context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RPCCallerContextProto.context)
}
inline ::std::string* RPCCallerContextProto::mutable_context() {
  set_has_context();
  // @@protoc_insertion_point(field_mutable:RPCCallerContextProto.context)
  return context_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RPCCallerContextProto::release_context() {
  // @@protoc_insertion_point(field_release:RPCCallerContextProto.context)
  clear_has_context();
  return context_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RPCCallerContextProto::set_allocated_context(::std::string* context) {
  if (context != NULL) {
    set_has_context();
  } else {
    clear_has_context();
  }
  context_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), context);
  // @@protoc_insertion_point(field_set_allocated:RPCCallerContextProto.context)
}

// optional bytes signature = 2;
inline bool RPCCallerContextProto::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RPCCallerContextProto::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RPCCallerContextProto::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RPCCallerContextProto::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& RPCCallerContextProto::signature() const {
  // @@protoc_insertion_point(field_get:RPCCallerContextProto.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RPCCallerContextProto::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RPCCallerContextProto.signature)
}
inline void RPCCallerContextProto::set_signature(const char* value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RPCCallerContextProto.signature)
}
inline void RPCCallerContextProto::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RPCCallerContextProto.signature)
}
inline ::std::string* RPCCallerContextProto::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:RPCCallerContextProto.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RPCCallerContextProto::release_signature() {
  // @@protoc_insertion_point(field_release:RPCCallerContextProto.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RPCCallerContextProto::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:RPCCallerContextProto.signature)
}

// -------------------------------------------------------------------

// RpcRequestHeaderProto

// optional .RpcKindProto rpcKind = 1;
inline bool RpcRequestHeaderProto::has_rpckind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcRequestHeaderProto::set_has_rpckind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcRequestHeaderProto::clear_has_rpckind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcRequestHeaderProto::clear_rpckind() {
  rpckind_ = 0;
  clear_has_rpckind();
}
inline ::RpcKindProto RpcRequestHeaderProto::rpckind() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.rpcKind)
  return static_cast< ::RpcKindProto >(rpckind_);
}
inline void RpcRequestHeaderProto::set_rpckind(::RpcKindProto value) {
  assert(::RpcKindProto_IsValid(value));
  set_has_rpckind();
  rpckind_ = value;
  // @@protoc_insertion_point(field_set:RpcRequestHeaderProto.rpcKind)
}

// optional .RpcRequestHeaderProto.OperationProto rpcOp = 2;
inline bool RpcRequestHeaderProto::has_rpcop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcRequestHeaderProto::set_has_rpcop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpcRequestHeaderProto::clear_has_rpcop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpcRequestHeaderProto::clear_rpcop() {
  rpcop_ = 0;
  clear_has_rpcop();
}
inline ::RpcRequestHeaderProto_OperationProto RpcRequestHeaderProto::rpcop() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.rpcOp)
  return static_cast< ::RpcRequestHeaderProto_OperationProto >(rpcop_);
}
inline void RpcRequestHeaderProto::set_rpcop(::RpcRequestHeaderProto_OperationProto value) {
  assert(::RpcRequestHeaderProto_OperationProto_IsValid(value));
  set_has_rpcop();
  rpcop_ = value;
  // @@protoc_insertion_point(field_set:RpcRequestHeaderProto.rpcOp)
}

// required sint32 callId = 3;
inline bool RpcRequestHeaderProto::has_callid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpcRequestHeaderProto::set_has_callid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpcRequestHeaderProto::clear_has_callid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpcRequestHeaderProto::clear_callid() {
  callid_ = 0;
  clear_has_callid();
}
inline ::google::protobuf::int32 RpcRequestHeaderProto::callid() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.callId)
  return callid_;
}
inline void RpcRequestHeaderProto::set_callid(::google::protobuf::int32 value) {
  set_has_callid();
  callid_ = value;
  // @@protoc_insertion_point(field_set:RpcRequestHeaderProto.callId)
}

// required bytes clientId = 4;
inline bool RpcRequestHeaderProto::has_clientid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpcRequestHeaderProto::set_has_clientid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpcRequestHeaderProto::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpcRequestHeaderProto::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
inline const ::std::string& RpcRequestHeaderProto::clientid() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.clientId)
  return clientid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcRequestHeaderProto::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RpcRequestHeaderProto.clientId)
}
inline void RpcRequestHeaderProto::set_clientid(const char* value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RpcRequestHeaderProto.clientId)
}
inline void RpcRequestHeaderProto::set_clientid(const void* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RpcRequestHeaderProto.clientId)
}
inline ::std::string* RpcRequestHeaderProto::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:RpcRequestHeaderProto.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcRequestHeaderProto::release_clientid() {
  // @@protoc_insertion_point(field_release:RpcRequestHeaderProto.clientId)
  clear_has_clientid();
  return clientid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcRequestHeaderProto::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:RpcRequestHeaderProto.clientId)
}

// optional sint32 retryCount = 5 [default = -1];
inline bool RpcRequestHeaderProto::has_retrycount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpcRequestHeaderProto::set_has_retrycount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpcRequestHeaderProto::clear_has_retrycount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpcRequestHeaderProto::clear_retrycount() {
  retrycount_ = -1;
  clear_has_retrycount();
}
inline ::google::protobuf::int32 RpcRequestHeaderProto::retrycount() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.retryCount)
  return retrycount_;
}
inline void RpcRequestHeaderProto::set_retrycount(::google::protobuf::int32 value) {
  set_has_retrycount();
  retrycount_ = value;
  // @@protoc_insertion_point(field_set:RpcRequestHeaderProto.retryCount)
}

// optional .RPCTraceInfoProto traceInfo = 6;
inline bool RpcRequestHeaderProto::has_traceinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpcRequestHeaderProto::set_has_traceinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpcRequestHeaderProto::clear_has_traceinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpcRequestHeaderProto::clear_traceinfo() {
  if (traceinfo_ != NULL) traceinfo_->::RPCTraceInfoProto::Clear();
  clear_has_traceinfo();
}
inline const ::RPCTraceInfoProto& RpcRequestHeaderProto::traceinfo() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.traceInfo)
  return traceinfo_ != NULL ? *traceinfo_ : *default_instance_->traceinfo_;
}
inline ::RPCTraceInfoProto* RpcRequestHeaderProto::mutable_traceinfo() {
  set_has_traceinfo();
  if (traceinfo_ == NULL) {
    traceinfo_ = new ::RPCTraceInfoProto;
  }
  // @@protoc_insertion_point(field_mutable:RpcRequestHeaderProto.traceInfo)
  return traceinfo_;
}
inline ::RPCTraceInfoProto* RpcRequestHeaderProto::release_traceinfo() {
  // @@protoc_insertion_point(field_release:RpcRequestHeaderProto.traceInfo)
  clear_has_traceinfo();
  ::RPCTraceInfoProto* temp = traceinfo_;
  traceinfo_ = NULL;
  return temp;
}
inline void RpcRequestHeaderProto::set_allocated_traceinfo(::RPCTraceInfoProto* traceinfo) {
  delete traceinfo_;
  traceinfo_ = traceinfo;
  if (traceinfo) {
    set_has_traceinfo();
  } else {
    clear_has_traceinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:RpcRequestHeaderProto.traceInfo)
}

// optional .RPCCallerContextProto callerContext = 7;
inline bool RpcRequestHeaderProto::has_callercontext() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpcRequestHeaderProto::set_has_callercontext() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpcRequestHeaderProto::clear_has_callercontext() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpcRequestHeaderProto::clear_callercontext() {
  if (callercontext_ != NULL) callercontext_->::RPCCallerContextProto::Clear();
  clear_has_callercontext();
}
inline const ::RPCCallerContextProto& RpcRequestHeaderProto::callercontext() const {
  // @@protoc_insertion_point(field_get:RpcRequestHeaderProto.callerContext)
  return callercontext_ != NULL ? *callercontext_ : *default_instance_->callercontext_;
}
inline ::RPCCallerContextProto* RpcRequestHeaderProto::mutable_callercontext() {
  set_has_callercontext();
  if (callercontext_ == NULL) {
    callercontext_ = new ::RPCCallerContextProto;
  }
  // @@protoc_insertion_point(field_mutable:RpcRequestHeaderProto.callerContext)
  return callercontext_;
}
inline ::RPCCallerContextProto* RpcRequestHeaderProto::release_callercontext() {
  // @@protoc_insertion_point(field_release:RpcRequestHeaderProto.callerContext)
  clear_has_callercontext();
  ::RPCCallerContextProto* temp = callercontext_;
  callercontext_ = NULL;
  return temp;
}
inline void RpcRequestHeaderProto::set_allocated_callercontext(::RPCCallerContextProto* callercontext) {
  delete callercontext_;
  callercontext_ = callercontext;
  if (callercontext) {
    set_has_callercontext();
  } else {
    clear_has_callercontext();
  }
  // @@protoc_insertion_point(field_set_allocated:RpcRequestHeaderProto.callerContext)
}

// -------------------------------------------------------------------

// RpcResponseHeaderProto

// required uint32 callId = 1;
inline bool RpcResponseHeaderProto::has_callid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcResponseHeaderProto::set_has_callid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcResponseHeaderProto::clear_has_callid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcResponseHeaderProto::clear_callid() {
  callid_ = 0u;
  clear_has_callid();
}
inline ::google::protobuf::uint32 RpcResponseHeaderProto::callid() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.callId)
  return callid_;
}
inline void RpcResponseHeaderProto::set_callid(::google::protobuf::uint32 value) {
  set_has_callid();
  callid_ = value;
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.callId)
}

// required .RpcResponseHeaderProto.RpcStatusProto status = 2;
inline bool RpcResponseHeaderProto::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcResponseHeaderProto::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpcResponseHeaderProto::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpcResponseHeaderProto::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::RpcResponseHeaderProto_RpcStatusProto RpcResponseHeaderProto::status() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.status)
  return static_cast< ::RpcResponseHeaderProto_RpcStatusProto >(status_);
}
inline void RpcResponseHeaderProto::set_status(::RpcResponseHeaderProto_RpcStatusProto value) {
  assert(::RpcResponseHeaderProto_RpcStatusProto_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.status)
}

// optional uint32 serverIpcVersionNum = 3;
inline bool RpcResponseHeaderProto::has_serveripcversionnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpcResponseHeaderProto::set_has_serveripcversionnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpcResponseHeaderProto::clear_has_serveripcversionnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpcResponseHeaderProto::clear_serveripcversionnum() {
  serveripcversionnum_ = 0u;
  clear_has_serveripcversionnum();
}
inline ::google::protobuf::uint32 RpcResponseHeaderProto::serveripcversionnum() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.serverIpcVersionNum)
  return serveripcversionnum_;
}
inline void RpcResponseHeaderProto::set_serveripcversionnum(::google::protobuf::uint32 value) {
  set_has_serveripcversionnum();
  serveripcversionnum_ = value;
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.serverIpcVersionNum)
}

// optional string exceptionClassName = 4;
inline bool RpcResponseHeaderProto::has_exceptionclassname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpcResponseHeaderProto::set_has_exceptionclassname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpcResponseHeaderProto::clear_has_exceptionclassname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpcResponseHeaderProto::clear_exceptionclassname() {
  exceptionclassname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_exceptionclassname();
}
inline const ::std::string& RpcResponseHeaderProto::exceptionclassname() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.exceptionClassName)
  return exceptionclassname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_exceptionclassname(const ::std::string& value) {
  set_has_exceptionclassname();
  exceptionclassname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.exceptionClassName)
}
inline void RpcResponseHeaderProto::set_exceptionclassname(const char* value) {
  set_has_exceptionclassname();
  exceptionclassname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RpcResponseHeaderProto.exceptionClassName)
}
inline void RpcResponseHeaderProto::set_exceptionclassname(const char* value, size_t size) {
  set_has_exceptionclassname();
  exceptionclassname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RpcResponseHeaderProto.exceptionClassName)
}
inline ::std::string* RpcResponseHeaderProto::mutable_exceptionclassname() {
  set_has_exceptionclassname();
  // @@protoc_insertion_point(field_mutable:RpcResponseHeaderProto.exceptionClassName)
  return exceptionclassname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcResponseHeaderProto::release_exceptionclassname() {
  // @@protoc_insertion_point(field_release:RpcResponseHeaderProto.exceptionClassName)
  clear_has_exceptionclassname();
  return exceptionclassname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_allocated_exceptionclassname(::std::string* exceptionclassname) {
  if (exceptionclassname != NULL) {
    set_has_exceptionclassname();
  } else {
    clear_has_exceptionclassname();
  }
  exceptionclassname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exceptionclassname);
  // @@protoc_insertion_point(field_set_allocated:RpcResponseHeaderProto.exceptionClassName)
}

// optional string errorMsg = 5;
inline bool RpcResponseHeaderProto::has_errormsg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpcResponseHeaderProto::set_has_errormsg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpcResponseHeaderProto::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpcResponseHeaderProto::clear_errormsg() {
  errormsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errormsg();
}
inline const ::std::string& RpcResponseHeaderProto::errormsg() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.errorMsg)
  return errormsg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.errorMsg)
}
inline void RpcResponseHeaderProto::set_errormsg(const char* value) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RpcResponseHeaderProto.errorMsg)
}
inline void RpcResponseHeaderProto::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RpcResponseHeaderProto.errorMsg)
}
inline ::std::string* RpcResponseHeaderProto::mutable_errormsg() {
  set_has_errormsg();
  // @@protoc_insertion_point(field_mutable:RpcResponseHeaderProto.errorMsg)
  return errormsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcResponseHeaderProto::release_errormsg() {
  // @@protoc_insertion_point(field_release:RpcResponseHeaderProto.errorMsg)
  clear_has_errormsg();
  return errormsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_allocated_errormsg(::std::string* errormsg) {
  if (errormsg != NULL) {
    set_has_errormsg();
  } else {
    clear_has_errormsg();
  }
  errormsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormsg);
  // @@protoc_insertion_point(field_set_allocated:RpcResponseHeaderProto.errorMsg)
}

// optional .RpcResponseHeaderProto.RpcErrorCodeProto errorDetail = 6;
inline bool RpcResponseHeaderProto::has_errordetail() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpcResponseHeaderProto::set_has_errordetail() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpcResponseHeaderProto::clear_has_errordetail() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpcResponseHeaderProto::clear_errordetail() {
  errordetail_ = 1;
  clear_has_errordetail();
}
inline ::RpcResponseHeaderProto_RpcErrorCodeProto RpcResponseHeaderProto::errordetail() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.errorDetail)
  return static_cast< ::RpcResponseHeaderProto_RpcErrorCodeProto >(errordetail_);
}
inline void RpcResponseHeaderProto::set_errordetail(::RpcResponseHeaderProto_RpcErrorCodeProto value) {
  assert(::RpcResponseHeaderProto_RpcErrorCodeProto_IsValid(value));
  set_has_errordetail();
  errordetail_ = value;
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.errorDetail)
}

// optional bytes clientId = 7;
inline bool RpcResponseHeaderProto::has_clientid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpcResponseHeaderProto::set_has_clientid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpcResponseHeaderProto::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpcResponseHeaderProto::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
inline const ::std::string& RpcResponseHeaderProto::clientid() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.clientId)
  return clientid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.clientId)
}
inline void RpcResponseHeaderProto::set_clientid(const char* value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RpcResponseHeaderProto.clientId)
}
inline void RpcResponseHeaderProto::set_clientid(const void* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RpcResponseHeaderProto.clientId)
}
inline ::std::string* RpcResponseHeaderProto::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:RpcResponseHeaderProto.clientId)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcResponseHeaderProto::release_clientid() {
  // @@protoc_insertion_point(field_release:RpcResponseHeaderProto.clientId)
  clear_has_clientid();
  return clientid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RpcResponseHeaderProto::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:RpcResponseHeaderProto.clientId)
}

// optional sint32 retryCount = 8 [default = -1];
inline bool RpcResponseHeaderProto::has_retrycount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RpcResponseHeaderProto::set_has_retrycount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RpcResponseHeaderProto::clear_has_retrycount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RpcResponseHeaderProto::clear_retrycount() {
  retrycount_ = -1;
  clear_has_retrycount();
}
inline ::google::protobuf::int32 RpcResponseHeaderProto::retrycount() const {
  // @@protoc_insertion_point(field_get:RpcResponseHeaderProto.retryCount)
  return retrycount_;
}
inline void RpcResponseHeaderProto::set_retrycount(::google::protobuf::int32 value) {
  set_has_retrycount();
  retrycount_ = value;
  // @@protoc_insertion_point(field_set:RpcResponseHeaderProto.retryCount)
}

// -------------------------------------------------------------------

// FsPermissionProto

// required uint32 perm = 1;
inline bool FsPermissionProto::has_perm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FsPermissionProto::set_has_perm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FsPermissionProto::clear_has_perm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FsPermissionProto::clear_perm() {
  perm_ = 0u;
  clear_has_perm();
}
inline ::google::protobuf::uint32 FsPermissionProto::perm() const {
  // @@protoc_insertion_point(field_get:FsPermissionProto.perm)
  return perm_;
}
inline void FsPermissionProto::set_perm(::google::protobuf::uint32 value) {
  set_has_perm();
  perm_ = value;
  // @@protoc_insertion_point(field_set:FsPermissionProto.perm)
}

// -------------------------------------------------------------------

// ExtendedBlockProto

// required string poolId = 1;
inline bool ExtendedBlockProto::has_poolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtendedBlockProto::set_has_poolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtendedBlockProto::clear_has_poolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtendedBlockProto::clear_poolid() {
  poolid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_poolid();
}
inline const ::std::string& ExtendedBlockProto::poolid() const {
  // @@protoc_insertion_point(field_get:ExtendedBlockProto.poolId)
  return poolid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtendedBlockProto::set_poolid(const ::std::string& value) {
  set_has_poolid();
  poolid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ExtendedBlockProto.poolId)
}
inline void ExtendedBlockProto::set_poolid(const char* value) {
  set_has_poolid();
  poolid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ExtendedBlockProto.poolId)
}
inline void ExtendedBlockProto::set_poolid(const char* value, size_t size) {
  set_has_poolid();
  poolid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ExtendedBlockProto.poolId)
}
inline ::std::string* ExtendedBlockProto::mutable_poolid() {
  set_has_poolid();
  // @@protoc_insertion_point(field_mutable:ExtendedBlockProto.poolId)
  return poolid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExtendedBlockProto::release_poolid() {
  // @@protoc_insertion_point(field_release:ExtendedBlockProto.poolId)
  clear_has_poolid();
  return poolid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtendedBlockProto::set_allocated_poolid(::std::string* poolid) {
  if (poolid != NULL) {
    set_has_poolid();
  } else {
    clear_has_poolid();
  }
  poolid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), poolid);
  // @@protoc_insertion_point(field_set_allocated:ExtendedBlockProto.poolId)
}

// required uint64 blockId = 2;
inline bool ExtendedBlockProto::has_blockid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtendedBlockProto::set_has_blockid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtendedBlockProto::clear_has_blockid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtendedBlockProto::clear_blockid() {
  blockid_ = GOOGLE_ULONGLONG(0);
  clear_has_blockid();
}
inline ::google::protobuf::uint64 ExtendedBlockProto::blockid() const {
  // @@protoc_insertion_point(field_get:ExtendedBlockProto.blockId)
  return blockid_;
}
inline void ExtendedBlockProto::set_blockid(::google::protobuf::uint64 value) {
  set_has_blockid();
  blockid_ = value;
  // @@protoc_insertion_point(field_set:ExtendedBlockProto.blockId)
}

// required uint64 generationStamp = 3;
inline bool ExtendedBlockProto::has_generationstamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtendedBlockProto::set_has_generationstamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtendedBlockProto::clear_has_generationstamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtendedBlockProto::clear_generationstamp() {
  generationstamp_ = GOOGLE_ULONGLONG(0);
  clear_has_generationstamp();
}
inline ::google::protobuf::uint64 ExtendedBlockProto::generationstamp() const {
  // @@protoc_insertion_point(field_get:ExtendedBlockProto.generationStamp)
  return generationstamp_;
}
inline void ExtendedBlockProto::set_generationstamp(::google::protobuf::uint64 value) {
  set_has_generationstamp();
  generationstamp_ = value;
  // @@protoc_insertion_point(field_set:ExtendedBlockProto.generationStamp)
}

// optional uint64 numBytes = 4 [default = 0];
inline bool ExtendedBlockProto::has_numbytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtendedBlockProto::set_has_numbytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExtendedBlockProto::clear_has_numbytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExtendedBlockProto::clear_numbytes() {
  numbytes_ = GOOGLE_ULONGLONG(0);
  clear_has_numbytes();
}
inline ::google::protobuf::uint64 ExtendedBlockProto::numbytes() const {
  // @@protoc_insertion_point(field_get:ExtendedBlockProto.numBytes)
  return numbytes_;
}
inline void ExtendedBlockProto::set_numbytes(::google::protobuf::uint64 value) {
  set_has_numbytes();
  numbytes_ = value;
  // @@protoc_insertion_point(field_set:ExtendedBlockProto.numBytes)
}

// -------------------------------------------------------------------

// DatanodeIDProto

// required string ipAddr = 1;
inline bool DatanodeIDProto::has_ipaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatanodeIDProto::set_has_ipaddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatanodeIDProto::clear_has_ipaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatanodeIDProto::clear_ipaddr() {
  ipaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ipaddr();
}
inline const ::std::string& DatanodeIDProto::ipaddr() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.ipAddr)
  return ipaddr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeIDProto::set_ipaddr(const ::std::string& value) {
  set_has_ipaddr();
  ipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeIDProto.ipAddr)
}
inline void DatanodeIDProto::set_ipaddr(const char* value) {
  set_has_ipaddr();
  ipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeIDProto.ipAddr)
}
inline void DatanodeIDProto::set_ipaddr(const char* value, size_t size) {
  set_has_ipaddr();
  ipaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeIDProto.ipAddr)
}
inline ::std::string* DatanodeIDProto::mutable_ipaddr() {
  set_has_ipaddr();
  // @@protoc_insertion_point(field_mutable:DatanodeIDProto.ipAddr)
  return ipaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatanodeIDProto::release_ipaddr() {
  // @@protoc_insertion_point(field_release:DatanodeIDProto.ipAddr)
  clear_has_ipaddr();
  return ipaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeIDProto::set_allocated_ipaddr(::std::string* ipaddr) {
  if (ipaddr != NULL) {
    set_has_ipaddr();
  } else {
    clear_has_ipaddr();
  }
  ipaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipaddr);
  // @@protoc_insertion_point(field_set_allocated:DatanodeIDProto.ipAddr)
}

// required string hostName = 2;
inline bool DatanodeIDProto::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatanodeIDProto::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatanodeIDProto::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatanodeIDProto::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
inline const ::std::string& DatanodeIDProto::hostname() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.hostName)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeIDProto::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeIDProto.hostName)
}
inline void DatanodeIDProto::set_hostname(const char* value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeIDProto.hostName)
}
inline void DatanodeIDProto::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeIDProto.hostName)
}
inline ::std::string* DatanodeIDProto::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:DatanodeIDProto.hostName)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatanodeIDProto::release_hostname() {
  // @@protoc_insertion_point(field_release:DatanodeIDProto.hostName)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeIDProto::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:DatanodeIDProto.hostName)
}

// required string datanodeUuid = 3;
inline bool DatanodeIDProto::has_datanodeuuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatanodeIDProto::set_has_datanodeuuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatanodeIDProto::clear_has_datanodeuuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatanodeIDProto::clear_datanodeuuid() {
  datanodeuuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_datanodeuuid();
}
inline const ::std::string& DatanodeIDProto::datanodeuuid() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.datanodeUuid)
  return datanodeuuid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeIDProto::set_datanodeuuid(const ::std::string& value) {
  set_has_datanodeuuid();
  datanodeuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeIDProto.datanodeUuid)
}
inline void DatanodeIDProto::set_datanodeuuid(const char* value) {
  set_has_datanodeuuid();
  datanodeuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeIDProto.datanodeUuid)
}
inline void DatanodeIDProto::set_datanodeuuid(const char* value, size_t size) {
  set_has_datanodeuuid();
  datanodeuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeIDProto.datanodeUuid)
}
inline ::std::string* DatanodeIDProto::mutable_datanodeuuid() {
  set_has_datanodeuuid();
  // @@protoc_insertion_point(field_mutable:DatanodeIDProto.datanodeUuid)
  return datanodeuuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatanodeIDProto::release_datanodeuuid() {
  // @@protoc_insertion_point(field_release:DatanodeIDProto.datanodeUuid)
  clear_has_datanodeuuid();
  return datanodeuuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeIDProto::set_allocated_datanodeuuid(::std::string* datanodeuuid) {
  if (datanodeuuid != NULL) {
    set_has_datanodeuuid();
  } else {
    clear_has_datanodeuuid();
  }
  datanodeuuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), datanodeuuid);
  // @@protoc_insertion_point(field_set_allocated:DatanodeIDProto.datanodeUuid)
}

// required uint32 xferPort = 4;
inline bool DatanodeIDProto::has_xferport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DatanodeIDProto::set_has_xferport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DatanodeIDProto::clear_has_xferport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DatanodeIDProto::clear_xferport() {
  xferport_ = 0u;
  clear_has_xferport();
}
inline ::google::protobuf::uint32 DatanodeIDProto::xferport() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.xferPort)
  return xferport_;
}
inline void DatanodeIDProto::set_xferport(::google::protobuf::uint32 value) {
  set_has_xferport();
  xferport_ = value;
  // @@protoc_insertion_point(field_set:DatanodeIDProto.xferPort)
}

// required uint32 infoPort = 5;
inline bool DatanodeIDProto::has_infoport() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DatanodeIDProto::set_has_infoport() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DatanodeIDProto::clear_has_infoport() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DatanodeIDProto::clear_infoport() {
  infoport_ = 0u;
  clear_has_infoport();
}
inline ::google::protobuf::uint32 DatanodeIDProto::infoport() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.infoPort)
  return infoport_;
}
inline void DatanodeIDProto::set_infoport(::google::protobuf::uint32 value) {
  set_has_infoport();
  infoport_ = value;
  // @@protoc_insertion_point(field_set:DatanodeIDProto.infoPort)
}

// required uint32 ipcPort = 6;
inline bool DatanodeIDProto::has_ipcport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DatanodeIDProto::set_has_ipcport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DatanodeIDProto::clear_has_ipcport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DatanodeIDProto::clear_ipcport() {
  ipcport_ = 0u;
  clear_has_ipcport();
}
inline ::google::protobuf::uint32 DatanodeIDProto::ipcport() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.ipcPort)
  return ipcport_;
}
inline void DatanodeIDProto::set_ipcport(::google::protobuf::uint32 value) {
  set_has_ipcport();
  ipcport_ = value;
  // @@protoc_insertion_point(field_set:DatanodeIDProto.ipcPort)
}

// optional uint32 infoSecurePort = 7 [default = 0];
inline bool DatanodeIDProto::has_infosecureport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DatanodeIDProto::set_has_infosecureport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DatanodeIDProto::clear_has_infosecureport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DatanodeIDProto::clear_infosecureport() {
  infosecureport_ = 0u;
  clear_has_infosecureport();
}
inline ::google::protobuf::uint32 DatanodeIDProto::infosecureport() const {
  // @@protoc_insertion_point(field_get:DatanodeIDProto.infoSecurePort)
  return infosecureport_;
}
inline void DatanodeIDProto::set_infosecureport(::google::protobuf::uint32 value) {
  set_has_infosecureport();
  infosecureport_ = value;
  // @@protoc_insertion_point(field_set:DatanodeIDProto.infoSecurePort)
}

// -------------------------------------------------------------------

// DatanodeInfoProto

// required .DatanodeIDProto id = 1;
inline bool DatanodeInfoProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatanodeInfoProto::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatanodeInfoProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatanodeInfoProto::clear_id() {
  if (id_ != NULL) id_->::DatanodeIDProto::Clear();
  clear_has_id();
}
inline const ::DatanodeIDProto& DatanodeInfoProto::id() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::DatanodeIDProto* DatanodeInfoProto::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::DatanodeIDProto;
  }
  // @@protoc_insertion_point(field_mutable:DatanodeInfoProto.id)
  return id_;
}
inline ::DatanodeIDProto* DatanodeInfoProto::release_id() {
  // @@protoc_insertion_point(field_release:DatanodeInfoProto.id)
  clear_has_id();
  ::DatanodeIDProto* temp = id_;
  id_ = NULL;
  return temp;
}
inline void DatanodeInfoProto::set_allocated_id(::DatanodeIDProto* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:DatanodeInfoProto.id)
}

// optional uint64 capacity = 2 [default = 0];
inline bool DatanodeInfoProto::has_capacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatanodeInfoProto::set_has_capacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatanodeInfoProto::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatanodeInfoProto::clear_capacity() {
  capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_capacity();
}
inline ::google::protobuf::uint64 DatanodeInfoProto::capacity() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.capacity)
  return capacity_;
}
inline void DatanodeInfoProto::set_capacity(::google::protobuf::uint64 value) {
  set_has_capacity();
  capacity_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.capacity)
}

// optional uint64 dfsUsed = 3 [default = 0];
inline bool DatanodeInfoProto::has_dfsused() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatanodeInfoProto::set_has_dfsused() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatanodeInfoProto::clear_has_dfsused() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatanodeInfoProto::clear_dfsused() {
  dfsused_ = GOOGLE_ULONGLONG(0);
  clear_has_dfsused();
}
inline ::google::protobuf::uint64 DatanodeInfoProto::dfsused() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.dfsUsed)
  return dfsused_;
}
inline void DatanodeInfoProto::set_dfsused(::google::protobuf::uint64 value) {
  set_has_dfsused();
  dfsused_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.dfsUsed)
}

// optional uint64 remaining = 4 [default = 0];
inline bool DatanodeInfoProto::has_remaining() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DatanodeInfoProto::set_has_remaining() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DatanodeInfoProto::clear_has_remaining() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DatanodeInfoProto::clear_remaining() {
  remaining_ = GOOGLE_ULONGLONG(0);
  clear_has_remaining();
}
inline ::google::protobuf::uint64 DatanodeInfoProto::remaining() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.remaining)
  return remaining_;
}
inline void DatanodeInfoProto::set_remaining(::google::protobuf::uint64 value) {
  set_has_remaining();
  remaining_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.remaining)
}

// optional uint64 blockPoolUsed = 5 [default = 0];
inline bool DatanodeInfoProto::has_blockpoolused() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DatanodeInfoProto::set_has_blockpoolused() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DatanodeInfoProto::clear_has_blockpoolused() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DatanodeInfoProto::clear_blockpoolused() {
  blockpoolused_ = GOOGLE_ULONGLONG(0);
  clear_has_blockpoolused();
}
inline ::google::protobuf::uint64 DatanodeInfoProto::blockpoolused() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.blockPoolUsed)
  return blockpoolused_;
}
inline void DatanodeInfoProto::set_blockpoolused(::google::protobuf::uint64 value) {
  set_has_blockpoolused();
  blockpoolused_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.blockPoolUsed)
}

// optional uint64 lastUpdate = 6 [default = 0];
inline bool DatanodeInfoProto::has_lastupdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DatanodeInfoProto::set_has_lastupdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DatanodeInfoProto::clear_has_lastupdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DatanodeInfoProto::clear_lastupdate() {
  lastupdate_ = GOOGLE_ULONGLONG(0);
  clear_has_lastupdate();
}
inline ::google::protobuf::uint64 DatanodeInfoProto::lastupdate() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.lastUpdate)
  return lastupdate_;
}
inline void DatanodeInfoProto::set_lastupdate(::google::protobuf::uint64 value) {
  set_has_lastupdate();
  lastupdate_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.lastUpdate)
}

// optional uint32 xceiverCount = 7 [default = 0];
inline bool DatanodeInfoProto::has_xceivercount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DatanodeInfoProto::set_has_xceivercount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DatanodeInfoProto::clear_has_xceivercount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DatanodeInfoProto::clear_xceivercount() {
  xceivercount_ = 0u;
  clear_has_xceivercount();
}
inline ::google::protobuf::uint32 DatanodeInfoProto::xceivercount() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.xceiverCount)
  return xceivercount_;
}
inline void DatanodeInfoProto::set_xceivercount(::google::protobuf::uint32 value) {
  set_has_xceivercount();
  xceivercount_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.xceiverCount)
}

// optional string location = 8;
inline bool DatanodeInfoProto::has_location() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DatanodeInfoProto::set_has_location() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DatanodeInfoProto::clear_has_location() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DatanodeInfoProto::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_location();
}
inline const ::std::string& DatanodeInfoProto::location() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.location)
  return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeInfoProto::set_location(const ::std::string& value) {
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.location)
}
inline void DatanodeInfoProto::set_location(const char* value) {
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeInfoProto.location)
}
inline void DatanodeInfoProto::set_location(const char* value, size_t size) {
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeInfoProto.location)
}
inline ::std::string* DatanodeInfoProto::mutable_location() {
  set_has_location();
  // @@protoc_insertion_point(field_mutable:DatanodeInfoProto.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatanodeInfoProto::release_location() {
  // @@protoc_insertion_point(field_release:DatanodeInfoProto.location)
  clear_has_location();
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeInfoProto::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    set_has_location();
  } else {
    clear_has_location();
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:DatanodeInfoProto.location)
}

// optional uint64 nonDfsUsed = 9;
inline bool DatanodeInfoProto::has_nondfsused() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DatanodeInfoProto::set_has_nondfsused() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DatanodeInfoProto::clear_has_nondfsused() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DatanodeInfoProto::clear_nondfsused() {
  nondfsused_ = GOOGLE_ULONGLONG(0);
  clear_has_nondfsused();
}
inline ::google::protobuf::uint64 DatanodeInfoProto::nondfsused() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.nonDfsUsed)
  return nondfsused_;
}
inline void DatanodeInfoProto::set_nondfsused(::google::protobuf::uint64 value) {
  set_has_nondfsused();
  nondfsused_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.nonDfsUsed)
}

// optional .DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
inline bool DatanodeInfoProto::has_adminstate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DatanodeInfoProto::set_has_adminstate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DatanodeInfoProto::clear_has_adminstate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DatanodeInfoProto::clear_adminstate() {
  adminstate_ = 0;
  clear_has_adminstate();
}
inline ::DatanodeInfoProto_AdminState DatanodeInfoProto::adminstate() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.adminState)
  return static_cast< ::DatanodeInfoProto_AdminState >(adminstate_);
}
inline void DatanodeInfoProto::set_adminstate(::DatanodeInfoProto_AdminState value) {
  assert(::DatanodeInfoProto_AdminState_IsValid(value));
  set_has_adminstate();
  adminstate_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.adminState)
}

// optional uint64 cacheCapacity = 11 [default = 0];
inline bool DatanodeInfoProto::has_cachecapacity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DatanodeInfoProto::set_has_cachecapacity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DatanodeInfoProto::clear_has_cachecapacity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DatanodeInfoProto::clear_cachecapacity() {
  cachecapacity_ = GOOGLE_ULONGLONG(0);
  clear_has_cachecapacity();
}
inline ::google::protobuf::uint64 DatanodeInfoProto::cachecapacity() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.cacheCapacity)
  return cachecapacity_;
}
inline void DatanodeInfoProto::set_cachecapacity(::google::protobuf::uint64 value) {
  set_has_cachecapacity();
  cachecapacity_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.cacheCapacity)
}

// optional uint64 cacheUsed = 12 [default = 0];
inline bool DatanodeInfoProto::has_cacheused() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DatanodeInfoProto::set_has_cacheused() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DatanodeInfoProto::clear_has_cacheused() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DatanodeInfoProto::clear_cacheused() {
  cacheused_ = GOOGLE_ULONGLONG(0);
  clear_has_cacheused();
}
inline ::google::protobuf::uint64 DatanodeInfoProto::cacheused() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.cacheUsed)
  return cacheused_;
}
inline void DatanodeInfoProto::set_cacheused(::google::protobuf::uint64 value) {
  set_has_cacheused();
  cacheused_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.cacheUsed)
}

// optional uint64 lastUpdateMonotonic = 13 [default = 0];
inline bool DatanodeInfoProto::has_lastupdatemonotonic() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DatanodeInfoProto::set_has_lastupdatemonotonic() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DatanodeInfoProto::clear_has_lastupdatemonotonic() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DatanodeInfoProto::clear_lastupdatemonotonic() {
  lastupdatemonotonic_ = GOOGLE_ULONGLONG(0);
  clear_has_lastupdatemonotonic();
}
inline ::google::protobuf::uint64 DatanodeInfoProto::lastupdatemonotonic() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.lastUpdateMonotonic)
  return lastupdatemonotonic_;
}
inline void DatanodeInfoProto::set_lastupdatemonotonic(::google::protobuf::uint64 value) {
  set_has_lastupdatemonotonic();
  lastupdatemonotonic_ = value;
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.lastUpdateMonotonic)
}

// optional string upgradeDomain = 14;
inline bool DatanodeInfoProto::has_upgradedomain() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DatanodeInfoProto::set_has_upgradedomain() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DatanodeInfoProto::clear_has_upgradedomain() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DatanodeInfoProto::clear_upgradedomain() {
  upgradedomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_upgradedomain();
}
inline const ::std::string& DatanodeInfoProto::upgradedomain() const {
  // @@protoc_insertion_point(field_get:DatanodeInfoProto.upgradeDomain)
  return upgradedomain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeInfoProto::set_upgradedomain(const ::std::string& value) {
  set_has_upgradedomain();
  upgradedomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeInfoProto.upgradeDomain)
}
inline void DatanodeInfoProto::set_upgradedomain(const char* value) {
  set_has_upgradedomain();
  upgradedomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeInfoProto.upgradeDomain)
}
inline void DatanodeInfoProto::set_upgradedomain(const char* value, size_t size) {
  set_has_upgradedomain();
  upgradedomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeInfoProto.upgradeDomain)
}
inline ::std::string* DatanodeInfoProto::mutable_upgradedomain() {
  set_has_upgradedomain();
  // @@protoc_insertion_point(field_mutable:DatanodeInfoProto.upgradeDomain)
  return upgradedomain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatanodeInfoProto::release_upgradedomain() {
  // @@protoc_insertion_point(field_release:DatanodeInfoProto.upgradeDomain)
  clear_has_upgradedomain();
  return upgradedomain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeInfoProto::set_allocated_upgradedomain(::std::string* upgradedomain) {
  if (upgradedomain != NULL) {
    set_has_upgradedomain();
  } else {
    clear_has_upgradedomain();
  }
  upgradedomain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), upgradedomain);
  // @@protoc_insertion_point(field_set_allocated:DatanodeInfoProto.upgradeDomain)
}

// -------------------------------------------------------------------

// TokenProto

// required bytes identifier = 1;
inline bool TokenProto::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TokenProto::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TokenProto::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TokenProto::clear_identifier() {
  identifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_identifier();
}
inline const ::std::string& TokenProto::identifier() const {
  // @@protoc_insertion_point(field_get:TokenProto.identifier)
  return identifier_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TokenProto::set_identifier(const ::std::string& value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TokenProto.identifier)
}
inline void TokenProto::set_identifier(const char* value) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TokenProto.identifier)
}
inline void TokenProto::set_identifier(const void* value, size_t size) {
  set_has_identifier();
  identifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TokenProto.identifier)
}
inline ::std::string* TokenProto::mutable_identifier() {
  set_has_identifier();
  // @@protoc_insertion_point(field_mutable:TokenProto.identifier)
  return identifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TokenProto::release_identifier() {
  // @@protoc_insertion_point(field_release:TokenProto.identifier)
  clear_has_identifier();
  return identifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TokenProto::set_allocated_identifier(::std::string* identifier) {
  if (identifier != NULL) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  identifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), identifier);
  // @@protoc_insertion_point(field_set_allocated:TokenProto.identifier)
}

// required bytes password = 2;
inline bool TokenProto::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TokenProto::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TokenProto::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TokenProto::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& TokenProto::password() const {
  // @@protoc_insertion_point(field_get:TokenProto.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TokenProto::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TokenProto.password)
}
inline void TokenProto::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TokenProto.password)
}
inline void TokenProto::set_password(const void* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TokenProto.password)
}
inline ::std::string* TokenProto::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:TokenProto.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TokenProto::release_password() {
  // @@protoc_insertion_point(field_release:TokenProto.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TokenProto::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:TokenProto.password)
}

// required string kind = 3;
inline bool TokenProto::has_kind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TokenProto::set_has_kind() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TokenProto::clear_has_kind() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TokenProto::clear_kind() {
  kind_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_kind();
}
inline const ::std::string& TokenProto::kind() const {
  // @@protoc_insertion_point(field_get:TokenProto.kind)
  return kind_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TokenProto::set_kind(const ::std::string& value) {
  set_has_kind();
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TokenProto.kind)
}
inline void TokenProto::set_kind(const char* value) {
  set_has_kind();
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TokenProto.kind)
}
inline void TokenProto::set_kind(const char* value, size_t size) {
  set_has_kind();
  kind_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TokenProto.kind)
}
inline ::std::string* TokenProto::mutable_kind() {
  set_has_kind();
  // @@protoc_insertion_point(field_mutable:TokenProto.kind)
  return kind_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TokenProto::release_kind() {
  // @@protoc_insertion_point(field_release:TokenProto.kind)
  clear_has_kind();
  return kind_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TokenProto::set_allocated_kind(::std::string* kind) {
  if (kind != NULL) {
    set_has_kind();
  } else {
    clear_has_kind();
  }
  kind_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), kind);
  // @@protoc_insertion_point(field_set_allocated:TokenProto.kind)
}

// required string service = 4;
inline bool TokenProto::has_service() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TokenProto::set_has_service() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TokenProto::clear_has_service() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TokenProto::clear_service() {
  service_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service();
}
inline const ::std::string& TokenProto::service() const {
  // @@protoc_insertion_point(field_get:TokenProto.service)
  return service_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TokenProto::set_service(const ::std::string& value) {
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TokenProto.service)
}
inline void TokenProto::set_service(const char* value) {
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TokenProto.service)
}
inline void TokenProto::set_service(const char* value, size_t size) {
  set_has_service();
  service_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TokenProto.service)
}
inline ::std::string* TokenProto::mutable_service() {
  set_has_service();
  // @@protoc_insertion_point(field_mutable:TokenProto.service)
  return service_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TokenProto::release_service() {
  // @@protoc_insertion_point(field_release:TokenProto.service)
  clear_has_service();
  return service_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TokenProto::set_allocated_service(::std::string* service) {
  if (service != NULL) {
    set_has_service();
  } else {
    clear_has_service();
  }
  service_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service);
  // @@protoc_insertion_point(field_set_allocated:TokenProto.service)
}

// -------------------------------------------------------------------

// FileEncryptionInfoProto

// required .CipherSuiteProto suite = 1;
inline bool FileEncryptionInfoProto::has_suite() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileEncryptionInfoProto::set_has_suite() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileEncryptionInfoProto::clear_has_suite() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileEncryptionInfoProto::clear_suite() {
  suite_ = 1;
  clear_has_suite();
}
inline ::CipherSuiteProto FileEncryptionInfoProto::suite() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.suite)
  return static_cast< ::CipherSuiteProto >(suite_);
}
inline void FileEncryptionInfoProto::set_suite(::CipherSuiteProto value) {
  assert(::CipherSuiteProto_IsValid(value));
  set_has_suite();
  suite_ = value;
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.suite)
}

// required .CryptoProtocolVersionProto cryptoProtocolVersion = 2;
inline bool FileEncryptionInfoProto::has_cryptoprotocolversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileEncryptionInfoProto::set_has_cryptoprotocolversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileEncryptionInfoProto::clear_has_cryptoprotocolversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileEncryptionInfoProto::clear_cryptoprotocolversion() {
  cryptoprotocolversion_ = 1;
  clear_has_cryptoprotocolversion();
}
inline ::CryptoProtocolVersionProto FileEncryptionInfoProto::cryptoprotocolversion() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.cryptoProtocolVersion)
  return static_cast< ::CryptoProtocolVersionProto >(cryptoprotocolversion_);
}
inline void FileEncryptionInfoProto::set_cryptoprotocolversion(::CryptoProtocolVersionProto value) {
  assert(::CryptoProtocolVersionProto_IsValid(value));
  set_has_cryptoprotocolversion();
  cryptoprotocolversion_ = value;
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.cryptoProtocolVersion)
}

// required bytes key = 3;
inline bool FileEncryptionInfoProto::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileEncryptionInfoProto::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileEncryptionInfoProto::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileEncryptionInfoProto::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& FileEncryptionInfoProto::key() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.key)
}
inline void FileEncryptionInfoProto::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileEncryptionInfoProto.key)
}
inline void FileEncryptionInfoProto::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileEncryptionInfoProto.key)
}
inline ::std::string* FileEncryptionInfoProto::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:FileEncryptionInfoProto.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileEncryptionInfoProto::release_key() {
  // @@protoc_insertion_point(field_release:FileEncryptionInfoProto.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:FileEncryptionInfoProto.key)
}

// required bytes iv = 4;
inline bool FileEncryptionInfoProto::has_iv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileEncryptionInfoProto::set_has_iv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileEncryptionInfoProto::clear_has_iv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileEncryptionInfoProto::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iv();
}
inline const ::std::string& FileEncryptionInfoProto::iv() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.iv)
  return iv_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_iv(const ::std::string& value) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.iv)
}
inline void FileEncryptionInfoProto::set_iv(const char* value) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileEncryptionInfoProto.iv)
}
inline void FileEncryptionInfoProto::set_iv(const void* value, size_t size) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileEncryptionInfoProto.iv)
}
inline ::std::string* FileEncryptionInfoProto::mutable_iv() {
  set_has_iv();
  // @@protoc_insertion_point(field_mutable:FileEncryptionInfoProto.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileEncryptionInfoProto::release_iv() {
  // @@protoc_insertion_point(field_release:FileEncryptionInfoProto.iv)
  clear_has_iv();
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    set_has_iv();
  } else {
    clear_has_iv();
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:FileEncryptionInfoProto.iv)
}

// required string keyName = 5;
inline bool FileEncryptionInfoProto::has_keyname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileEncryptionInfoProto::set_has_keyname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileEncryptionInfoProto::clear_has_keyname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileEncryptionInfoProto::clear_keyname() {
  keyname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keyname();
}
inline const ::std::string& FileEncryptionInfoProto::keyname() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.keyName)
  return keyname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_keyname(const ::std::string& value) {
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.keyName)
}
inline void FileEncryptionInfoProto::set_keyname(const char* value) {
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileEncryptionInfoProto.keyName)
}
inline void FileEncryptionInfoProto::set_keyname(const char* value, size_t size) {
  set_has_keyname();
  keyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileEncryptionInfoProto.keyName)
}
inline ::std::string* FileEncryptionInfoProto::mutable_keyname() {
  set_has_keyname();
  // @@protoc_insertion_point(field_mutable:FileEncryptionInfoProto.keyName)
  return keyname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileEncryptionInfoProto::release_keyname() {
  // @@protoc_insertion_point(field_release:FileEncryptionInfoProto.keyName)
  clear_has_keyname();
  return keyname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_allocated_keyname(::std::string* keyname) {
  if (keyname != NULL) {
    set_has_keyname();
  } else {
    clear_has_keyname();
  }
  keyname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keyname);
  // @@protoc_insertion_point(field_set_allocated:FileEncryptionInfoProto.keyName)
}

// required string ezKeyVersionName = 6;
inline bool FileEncryptionInfoProto::has_ezkeyversionname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileEncryptionInfoProto::set_has_ezkeyversionname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileEncryptionInfoProto::clear_has_ezkeyversionname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileEncryptionInfoProto::clear_ezkeyversionname() {
  ezkeyversionname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ezkeyversionname();
}
inline const ::std::string& FileEncryptionInfoProto::ezkeyversionname() const {
  // @@protoc_insertion_point(field_get:FileEncryptionInfoProto.ezKeyVersionName)
  return ezkeyversionname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_ezkeyversionname(const ::std::string& value) {
  set_has_ezkeyversionname();
  ezkeyversionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FileEncryptionInfoProto.ezKeyVersionName)
}
inline void FileEncryptionInfoProto::set_ezkeyversionname(const char* value) {
  set_has_ezkeyversionname();
  ezkeyversionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FileEncryptionInfoProto.ezKeyVersionName)
}
inline void FileEncryptionInfoProto::set_ezkeyversionname(const char* value, size_t size) {
  set_has_ezkeyversionname();
  ezkeyversionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FileEncryptionInfoProto.ezKeyVersionName)
}
inline ::std::string* FileEncryptionInfoProto::mutable_ezkeyversionname() {
  set_has_ezkeyversionname();
  // @@protoc_insertion_point(field_mutable:FileEncryptionInfoProto.ezKeyVersionName)
  return ezkeyversionname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileEncryptionInfoProto::release_ezkeyversionname() {
  // @@protoc_insertion_point(field_release:FileEncryptionInfoProto.ezKeyVersionName)
  clear_has_ezkeyversionname();
  return ezkeyversionname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileEncryptionInfoProto::set_allocated_ezkeyversionname(::std::string* ezkeyversionname) {
  if (ezkeyversionname != NULL) {
    set_has_ezkeyversionname();
  } else {
    clear_has_ezkeyversionname();
  }
  ezkeyversionname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ezkeyversionname);
  // @@protoc_insertion_point(field_set_allocated:FileEncryptionInfoProto.ezKeyVersionName)
}

// -------------------------------------------------------------------

// LocatedBlockProto

// required .ExtendedBlockProto b = 1;
inline bool LocatedBlockProto::has_b() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocatedBlockProto::set_has_b() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocatedBlockProto::clear_has_b() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocatedBlockProto::clear_b() {
  if (b_ != NULL) b_->::ExtendedBlockProto::Clear();
  clear_has_b();
}
inline const ::ExtendedBlockProto& LocatedBlockProto::b() const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.b)
  return b_ != NULL ? *b_ : *default_instance_->b_;
}
inline ::ExtendedBlockProto* LocatedBlockProto::mutable_b() {
  set_has_b();
  if (b_ == NULL) {
    b_ = new ::ExtendedBlockProto;
  }
  // @@protoc_insertion_point(field_mutable:LocatedBlockProto.b)
  return b_;
}
inline ::ExtendedBlockProto* LocatedBlockProto::release_b() {
  // @@protoc_insertion_point(field_release:LocatedBlockProto.b)
  clear_has_b();
  ::ExtendedBlockProto* temp = b_;
  b_ = NULL;
  return temp;
}
inline void LocatedBlockProto::set_allocated_b(::ExtendedBlockProto* b) {
  delete b_;
  b_ = b;
  if (b) {
    set_has_b();
  } else {
    clear_has_b();
  }
  // @@protoc_insertion_point(field_set_allocated:LocatedBlockProto.b)
}

// required uint64 offset = 2;
inline bool LocatedBlockProto::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocatedBlockProto::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocatedBlockProto::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocatedBlockProto::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 LocatedBlockProto::offset() const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.offset)
  return offset_;
}
inline void LocatedBlockProto::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:LocatedBlockProto.offset)
}

// repeated .DatanodeInfoProto locs = 3;
inline int LocatedBlockProto::locs_size() const {
  return locs_.size();
}
inline void LocatedBlockProto::clear_locs() {
  locs_.Clear();
}
inline const ::DatanodeInfoProto& LocatedBlockProto::locs(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.locs)
  return locs_.Get(index);
}
inline ::DatanodeInfoProto* LocatedBlockProto::mutable_locs(int index) {
  // @@protoc_insertion_point(field_mutable:LocatedBlockProto.locs)
  return locs_.Mutable(index);
}
inline ::DatanodeInfoProto* LocatedBlockProto::add_locs() {
  // @@protoc_insertion_point(field_add:LocatedBlockProto.locs)
  return locs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >*
LocatedBlockProto::mutable_locs() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlockProto.locs)
  return &locs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >&
LocatedBlockProto::locs() const {
  // @@protoc_insertion_point(field_list:LocatedBlockProto.locs)
  return locs_;
}

// required bool corrupt = 4;
inline bool LocatedBlockProto::has_corrupt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocatedBlockProto::set_has_corrupt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocatedBlockProto::clear_has_corrupt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocatedBlockProto::clear_corrupt() {
  corrupt_ = false;
  clear_has_corrupt();
}
inline bool LocatedBlockProto::corrupt() const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.corrupt)
  return corrupt_;
}
inline void LocatedBlockProto::set_corrupt(bool value) {
  set_has_corrupt();
  corrupt_ = value;
  // @@protoc_insertion_point(field_set:LocatedBlockProto.corrupt)
}

// required .TokenProto blockToken = 5;
inline bool LocatedBlockProto::has_blocktoken() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocatedBlockProto::set_has_blocktoken() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocatedBlockProto::clear_has_blocktoken() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocatedBlockProto::clear_blocktoken() {
  if (blocktoken_ != NULL) blocktoken_->::TokenProto::Clear();
  clear_has_blocktoken();
}
inline const ::TokenProto& LocatedBlockProto::blocktoken() const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.blockToken)
  return blocktoken_ != NULL ? *blocktoken_ : *default_instance_->blocktoken_;
}
inline ::TokenProto* LocatedBlockProto::mutable_blocktoken() {
  set_has_blocktoken();
  if (blocktoken_ == NULL) {
    blocktoken_ = new ::TokenProto;
  }
  // @@protoc_insertion_point(field_mutable:LocatedBlockProto.blockToken)
  return blocktoken_;
}
inline ::TokenProto* LocatedBlockProto::release_blocktoken() {
  // @@protoc_insertion_point(field_release:LocatedBlockProto.blockToken)
  clear_has_blocktoken();
  ::TokenProto* temp = blocktoken_;
  blocktoken_ = NULL;
  return temp;
}
inline void LocatedBlockProto::set_allocated_blocktoken(::TokenProto* blocktoken) {
  delete blocktoken_;
  blocktoken_ = blocktoken;
  if (blocktoken) {
    set_has_blocktoken();
  } else {
    clear_has_blocktoken();
  }
  // @@protoc_insertion_point(field_set_allocated:LocatedBlockProto.blockToken)
}

// repeated bool isCached = 6 [packed = true];
inline int LocatedBlockProto::iscached_size() const {
  return iscached_.size();
}
inline void LocatedBlockProto::clear_iscached() {
  iscached_.Clear();
}
inline bool LocatedBlockProto::iscached(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.isCached)
  return iscached_.Get(index);
}
inline void LocatedBlockProto::set_iscached(int index, bool value) {
  iscached_.Set(index, value);
  // @@protoc_insertion_point(field_set:LocatedBlockProto.isCached)
}
inline void LocatedBlockProto::add_iscached(bool value) {
  iscached_.Add(value);
  // @@protoc_insertion_point(field_add:LocatedBlockProto.isCached)
}
inline const ::google::protobuf::RepeatedField< bool >&
LocatedBlockProto::iscached() const {
  // @@protoc_insertion_point(field_list:LocatedBlockProto.isCached)
  return iscached_;
}
inline ::google::protobuf::RepeatedField< bool >*
LocatedBlockProto::mutable_iscached() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlockProto.isCached)
  return &iscached_;
}

// repeated .StorageTypeProto storageTypes = 7;
inline int LocatedBlockProto::storagetypes_size() const {
  return storagetypes_.size();
}
inline void LocatedBlockProto::clear_storagetypes() {
  storagetypes_.Clear();
}
inline ::StorageTypeProto LocatedBlockProto::storagetypes(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.storageTypes)
  return static_cast< ::StorageTypeProto >(storagetypes_.Get(index));
}
inline void LocatedBlockProto::set_storagetypes(int index, ::StorageTypeProto value) {
  assert(::StorageTypeProto_IsValid(value));
  storagetypes_.Set(index, value);
  // @@protoc_insertion_point(field_set:LocatedBlockProto.storageTypes)
}
inline void LocatedBlockProto::add_storagetypes(::StorageTypeProto value) {
  assert(::StorageTypeProto_IsValid(value));
  storagetypes_.Add(value);
  // @@protoc_insertion_point(field_add:LocatedBlockProto.storageTypes)
}
inline const ::google::protobuf::RepeatedField<int>&
LocatedBlockProto::storagetypes() const {
  // @@protoc_insertion_point(field_list:LocatedBlockProto.storageTypes)
  return storagetypes_;
}
inline ::google::protobuf::RepeatedField<int>*
LocatedBlockProto::mutable_storagetypes() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlockProto.storageTypes)
  return &storagetypes_;
}

// repeated string storageIDs = 8;
inline int LocatedBlockProto::storageids_size() const {
  return storageids_.size();
}
inline void LocatedBlockProto::clear_storageids() {
  storageids_.Clear();
}
inline const ::std::string& LocatedBlockProto::storageids(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlockProto.storageIDs)
  return storageids_.Get(index);
}
inline ::std::string* LocatedBlockProto::mutable_storageids(int index) {
  // @@protoc_insertion_point(field_mutable:LocatedBlockProto.storageIDs)
  return storageids_.Mutable(index);
}
inline void LocatedBlockProto::set_storageids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:LocatedBlockProto.storageIDs)
  storageids_.Mutable(index)->assign(value);
}
inline void LocatedBlockProto::set_storageids(int index, const char* value) {
  storageids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:LocatedBlockProto.storageIDs)
}
inline void LocatedBlockProto::set_storageids(int index, const char* value, size_t size) {
  storageids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LocatedBlockProto.storageIDs)
}
inline ::std::string* LocatedBlockProto::add_storageids() {
  // @@protoc_insertion_point(field_add_mutable:LocatedBlockProto.storageIDs)
  return storageids_.Add();
}
inline void LocatedBlockProto::add_storageids(const ::std::string& value) {
  storageids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:LocatedBlockProto.storageIDs)
}
inline void LocatedBlockProto::add_storageids(const char* value) {
  storageids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:LocatedBlockProto.storageIDs)
}
inline void LocatedBlockProto::add_storageids(const char* value, size_t size) {
  storageids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:LocatedBlockProto.storageIDs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LocatedBlockProto::storageids() const {
  // @@protoc_insertion_point(field_list:LocatedBlockProto.storageIDs)
  return storageids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LocatedBlockProto::mutable_storageids() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlockProto.storageIDs)
  return &storageids_;
}

// -------------------------------------------------------------------

// LocatedBlocksProto

// required uint64 fileLength = 1;
inline bool LocatedBlocksProto::has_filelength() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocatedBlocksProto::set_has_filelength() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocatedBlocksProto::clear_has_filelength() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocatedBlocksProto::clear_filelength() {
  filelength_ = GOOGLE_ULONGLONG(0);
  clear_has_filelength();
}
inline ::google::protobuf::uint64 LocatedBlocksProto::filelength() const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.fileLength)
  return filelength_;
}
inline void LocatedBlocksProto::set_filelength(::google::protobuf::uint64 value) {
  set_has_filelength();
  filelength_ = value;
  // @@protoc_insertion_point(field_set:LocatedBlocksProto.fileLength)
}

// repeated .LocatedBlockProto blocks = 2;
inline int LocatedBlocksProto::blocks_size() const {
  return blocks_.size();
}
inline void LocatedBlocksProto::clear_blocks() {
  blocks_.Clear();
}
inline const ::LocatedBlockProto& LocatedBlocksProto::blocks(int index) const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.blocks)
  return blocks_.Get(index);
}
inline ::LocatedBlockProto* LocatedBlocksProto::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:LocatedBlocksProto.blocks)
  return blocks_.Mutable(index);
}
inline ::LocatedBlockProto* LocatedBlocksProto::add_blocks() {
  // @@protoc_insertion_point(field_add:LocatedBlocksProto.blocks)
  return blocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::LocatedBlockProto >*
LocatedBlocksProto::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:LocatedBlocksProto.blocks)
  return &blocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::LocatedBlockProto >&
LocatedBlocksProto::blocks() const {
  // @@protoc_insertion_point(field_list:LocatedBlocksProto.blocks)
  return blocks_;
}

// required bool underConstruction = 3;
inline bool LocatedBlocksProto::has_underconstruction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocatedBlocksProto::set_has_underconstruction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocatedBlocksProto::clear_has_underconstruction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocatedBlocksProto::clear_underconstruction() {
  underconstruction_ = false;
  clear_has_underconstruction();
}
inline bool LocatedBlocksProto::underconstruction() const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.underConstruction)
  return underconstruction_;
}
inline void LocatedBlocksProto::set_underconstruction(bool value) {
  set_has_underconstruction();
  underconstruction_ = value;
  // @@protoc_insertion_point(field_set:LocatedBlocksProto.underConstruction)
}

// optional .LocatedBlockProto lastBlock = 4;
inline bool LocatedBlocksProto::has_lastblock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocatedBlocksProto::set_has_lastblock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocatedBlocksProto::clear_has_lastblock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocatedBlocksProto::clear_lastblock() {
  if (lastblock_ != NULL) lastblock_->::LocatedBlockProto::Clear();
  clear_has_lastblock();
}
inline const ::LocatedBlockProto& LocatedBlocksProto::lastblock() const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.lastBlock)
  return lastblock_ != NULL ? *lastblock_ : *default_instance_->lastblock_;
}
inline ::LocatedBlockProto* LocatedBlocksProto::mutable_lastblock() {
  set_has_lastblock();
  if (lastblock_ == NULL) {
    lastblock_ = new ::LocatedBlockProto;
  }
  // @@protoc_insertion_point(field_mutable:LocatedBlocksProto.lastBlock)
  return lastblock_;
}
inline ::LocatedBlockProto* LocatedBlocksProto::release_lastblock() {
  // @@protoc_insertion_point(field_release:LocatedBlocksProto.lastBlock)
  clear_has_lastblock();
  ::LocatedBlockProto* temp = lastblock_;
  lastblock_ = NULL;
  return temp;
}
inline void LocatedBlocksProto::set_allocated_lastblock(::LocatedBlockProto* lastblock) {
  delete lastblock_;
  lastblock_ = lastblock;
  if (lastblock) {
    set_has_lastblock();
  } else {
    clear_has_lastblock();
  }
  // @@protoc_insertion_point(field_set_allocated:LocatedBlocksProto.lastBlock)
}

// required bool isLastBlockComplete = 5;
inline bool LocatedBlocksProto::has_islastblockcomplete() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocatedBlocksProto::set_has_islastblockcomplete() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocatedBlocksProto::clear_has_islastblockcomplete() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocatedBlocksProto::clear_islastblockcomplete() {
  islastblockcomplete_ = false;
  clear_has_islastblockcomplete();
}
inline bool LocatedBlocksProto::islastblockcomplete() const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.isLastBlockComplete)
  return islastblockcomplete_;
}
inline void LocatedBlocksProto::set_islastblockcomplete(bool value) {
  set_has_islastblockcomplete();
  islastblockcomplete_ = value;
  // @@protoc_insertion_point(field_set:LocatedBlocksProto.isLastBlockComplete)
}

// optional .FileEncryptionInfoProto fileEncryptionInfo = 6;
inline bool LocatedBlocksProto::has_fileencryptioninfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocatedBlocksProto::set_has_fileencryptioninfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocatedBlocksProto::clear_has_fileencryptioninfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocatedBlocksProto::clear_fileencryptioninfo() {
  if (fileencryptioninfo_ != NULL) fileencryptioninfo_->::FileEncryptionInfoProto::Clear();
  clear_has_fileencryptioninfo();
}
inline const ::FileEncryptionInfoProto& LocatedBlocksProto::fileencryptioninfo() const {
  // @@protoc_insertion_point(field_get:LocatedBlocksProto.fileEncryptionInfo)
  return fileencryptioninfo_ != NULL ? *fileencryptioninfo_ : *default_instance_->fileencryptioninfo_;
}
inline ::FileEncryptionInfoProto* LocatedBlocksProto::mutable_fileencryptioninfo() {
  set_has_fileencryptioninfo();
  if (fileencryptioninfo_ == NULL) {
    fileencryptioninfo_ = new ::FileEncryptionInfoProto;
  }
  // @@protoc_insertion_point(field_mutable:LocatedBlocksProto.fileEncryptionInfo)
  return fileencryptioninfo_;
}
inline ::FileEncryptionInfoProto* LocatedBlocksProto::release_fileencryptioninfo() {
  // @@protoc_insertion_point(field_release:LocatedBlocksProto.fileEncryptionInfo)
  clear_has_fileencryptioninfo();
  ::FileEncryptionInfoProto* temp = fileencryptioninfo_;
  fileencryptioninfo_ = NULL;
  return temp;
}
inline void LocatedBlocksProto::set_allocated_fileencryptioninfo(::FileEncryptionInfoProto* fileencryptioninfo) {
  delete fileencryptioninfo_;
  fileencryptioninfo_ = fileencryptioninfo;
  if (fileencryptioninfo) {
    set_has_fileencryptioninfo();
  } else {
    clear_has_fileencryptioninfo();
  }
  // @@protoc_insertion_point(field_set_allocated:LocatedBlocksProto.fileEncryptionInfo)
}

// -------------------------------------------------------------------

// RequestHeaderProto

// required string methodName = 1;
inline bool RequestHeaderProto::has_methodname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestHeaderProto::set_has_methodname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestHeaderProto::clear_has_methodname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestHeaderProto::clear_methodname() {
  methodname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_methodname();
}
inline const ::std::string& RequestHeaderProto::methodname() const {
  // @@protoc_insertion_point(field_get:RequestHeaderProto.methodName)
  return methodname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestHeaderProto::set_methodname(const ::std::string& value) {
  set_has_methodname();
  methodname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RequestHeaderProto.methodName)
}
inline void RequestHeaderProto::set_methodname(const char* value) {
  set_has_methodname();
  methodname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RequestHeaderProto.methodName)
}
inline void RequestHeaderProto::set_methodname(const char* value, size_t size) {
  set_has_methodname();
  methodname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RequestHeaderProto.methodName)
}
inline ::std::string* RequestHeaderProto::mutable_methodname() {
  set_has_methodname();
  // @@protoc_insertion_point(field_mutable:RequestHeaderProto.methodName)
  return methodname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestHeaderProto::release_methodname() {
  // @@protoc_insertion_point(field_release:RequestHeaderProto.methodName)
  clear_has_methodname();
  return methodname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestHeaderProto::set_allocated_methodname(::std::string* methodname) {
  if (methodname != NULL) {
    set_has_methodname();
  } else {
    clear_has_methodname();
  }
  methodname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), methodname);
  // @@protoc_insertion_point(field_set_allocated:RequestHeaderProto.methodName)
}

// required string declaringClassProtocolName = 2;
inline bool RequestHeaderProto::has_declaringclassprotocolname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestHeaderProto::set_has_declaringclassprotocolname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestHeaderProto::clear_has_declaringclassprotocolname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestHeaderProto::clear_declaringclassprotocolname() {
  declaringclassprotocolname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_declaringclassprotocolname();
}
inline const ::std::string& RequestHeaderProto::declaringclassprotocolname() const {
  // @@protoc_insertion_point(field_get:RequestHeaderProto.declaringClassProtocolName)
  return declaringclassprotocolname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestHeaderProto::set_declaringclassprotocolname(const ::std::string& value) {
  set_has_declaringclassprotocolname();
  declaringclassprotocolname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RequestHeaderProto.declaringClassProtocolName)
}
inline void RequestHeaderProto::set_declaringclassprotocolname(const char* value) {
  set_has_declaringclassprotocolname();
  declaringclassprotocolname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RequestHeaderProto.declaringClassProtocolName)
}
inline void RequestHeaderProto::set_declaringclassprotocolname(const char* value, size_t size) {
  set_has_declaringclassprotocolname();
  declaringclassprotocolname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RequestHeaderProto.declaringClassProtocolName)
}
inline ::std::string* RequestHeaderProto::mutable_declaringclassprotocolname() {
  set_has_declaringclassprotocolname();
  // @@protoc_insertion_point(field_mutable:RequestHeaderProto.declaringClassProtocolName)
  return declaringclassprotocolname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestHeaderProto::release_declaringclassprotocolname() {
  // @@protoc_insertion_point(field_release:RequestHeaderProto.declaringClassProtocolName)
  clear_has_declaringclassprotocolname();
  return declaringclassprotocolname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestHeaderProto::set_allocated_declaringclassprotocolname(::std::string* declaringclassprotocolname) {
  if (declaringclassprotocolname != NULL) {
    set_has_declaringclassprotocolname();
  } else {
    clear_has_declaringclassprotocolname();
  }
  declaringclassprotocolname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), declaringclassprotocolname);
  // @@protoc_insertion_point(field_set_allocated:RequestHeaderProto.declaringClassProtocolName)
}

// required uint64 clientProtocolVersion = 3;
inline bool RequestHeaderProto::has_clientprotocolversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestHeaderProto::set_has_clientprotocolversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestHeaderProto::clear_has_clientprotocolversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestHeaderProto::clear_clientprotocolversion() {
  clientprotocolversion_ = GOOGLE_ULONGLONG(0);
  clear_has_clientprotocolversion();
}
inline ::google::protobuf::uint64 RequestHeaderProto::clientprotocolversion() const {
  // @@protoc_insertion_point(field_get:RequestHeaderProto.clientProtocolVersion)
  return clientprotocolversion_;
}
inline void RequestHeaderProto::set_clientprotocolversion(::google::protobuf::uint64 value) {
  set_has_clientprotocolversion();
  clientprotocolversion_ = value;
  // @@protoc_insertion_point(field_set:RequestHeaderProto.clientProtocolVersion)
}

// -------------------------------------------------------------------

// StorageInfoProto

// required uint32 layoutVersion = 1;
inline bool StorageInfoProto::has_layoutversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageInfoProto::set_has_layoutversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageInfoProto::clear_has_layoutversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageInfoProto::clear_layoutversion() {
  layoutversion_ = 0u;
  clear_has_layoutversion();
}
inline ::google::protobuf::uint32 StorageInfoProto::layoutversion() const {
  // @@protoc_insertion_point(field_get:StorageInfoProto.layoutVersion)
  return layoutversion_;
}
inline void StorageInfoProto::set_layoutversion(::google::protobuf::uint32 value) {
  set_has_layoutversion();
  layoutversion_ = value;
  // @@protoc_insertion_point(field_set:StorageInfoProto.layoutVersion)
}

// required uint32 namespceID = 2;
inline bool StorageInfoProto::has_namespceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StorageInfoProto::set_has_namespceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StorageInfoProto::clear_has_namespceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StorageInfoProto::clear_namespceid() {
  namespceid_ = 0u;
  clear_has_namespceid();
}
inline ::google::protobuf::uint32 StorageInfoProto::namespceid() const {
  // @@protoc_insertion_point(field_get:StorageInfoProto.namespceID)
  return namespceid_;
}
inline void StorageInfoProto::set_namespceid(::google::protobuf::uint32 value) {
  set_has_namespceid();
  namespceid_ = value;
  // @@protoc_insertion_point(field_set:StorageInfoProto.namespceID)
}

// required string clusterID = 3;
inline bool StorageInfoProto::has_clusterid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StorageInfoProto::set_has_clusterid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StorageInfoProto::clear_has_clusterid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StorageInfoProto::clear_clusterid() {
  clusterid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clusterid();
}
inline const ::std::string& StorageInfoProto::clusterid() const {
  // @@protoc_insertion_point(field_get:StorageInfoProto.clusterID)
  return clusterid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageInfoProto::set_clusterid(const ::std::string& value) {
  set_has_clusterid();
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:StorageInfoProto.clusterID)
}
inline void StorageInfoProto::set_clusterid(const char* value) {
  set_has_clusterid();
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:StorageInfoProto.clusterID)
}
inline void StorageInfoProto::set_clusterid(const char* value, size_t size) {
  set_has_clusterid();
  clusterid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:StorageInfoProto.clusterID)
}
inline ::std::string* StorageInfoProto::mutable_clusterid() {
  set_has_clusterid();
  // @@protoc_insertion_point(field_mutable:StorageInfoProto.clusterID)
  return clusterid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageInfoProto::release_clusterid() {
  // @@protoc_insertion_point(field_release:StorageInfoProto.clusterID)
  clear_has_clusterid();
  return clusterid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageInfoProto::set_allocated_clusterid(::std::string* clusterid) {
  if (clusterid != NULL) {
    set_has_clusterid();
  } else {
    clear_has_clusterid();
  }
  clusterid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clusterid);
  // @@protoc_insertion_point(field_set_allocated:StorageInfoProto.clusterID)
}

// required uint64 cTime = 4;
inline bool StorageInfoProto::has_ctime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StorageInfoProto::set_has_ctime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StorageInfoProto::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StorageInfoProto::clear_ctime() {
  ctime_ = GOOGLE_ULONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::uint64 StorageInfoProto::ctime() const {
  // @@protoc_insertion_point(field_get:StorageInfoProto.cTime)
  return ctime_;
}
inline void StorageInfoProto::set_ctime(::google::protobuf::uint64 value) {
  set_has_ctime();
  ctime_ = value;
  // @@protoc_insertion_point(field_set:StorageInfoProto.cTime)
}

// -------------------------------------------------------------------

// BlockKeyProto

// required uint32 keyId = 1;
inline bool BlockKeyProto::has_keyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockKeyProto::set_has_keyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockKeyProto::clear_has_keyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockKeyProto::clear_keyid() {
  keyid_ = 0u;
  clear_has_keyid();
}
inline ::google::protobuf::uint32 BlockKeyProto::keyid() const {
  // @@protoc_insertion_point(field_get:BlockKeyProto.keyId)
  return keyid_;
}
inline void BlockKeyProto::set_keyid(::google::protobuf::uint32 value) {
  set_has_keyid();
  keyid_ = value;
  // @@protoc_insertion_point(field_set:BlockKeyProto.keyId)
}

// required uint64 expiryDate = 2;
inline bool BlockKeyProto::has_expirydate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockKeyProto::set_has_expirydate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockKeyProto::clear_has_expirydate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockKeyProto::clear_expirydate() {
  expirydate_ = GOOGLE_ULONGLONG(0);
  clear_has_expirydate();
}
inline ::google::protobuf::uint64 BlockKeyProto::expirydate() const {
  // @@protoc_insertion_point(field_get:BlockKeyProto.expiryDate)
  return expirydate_;
}
inline void BlockKeyProto::set_expirydate(::google::protobuf::uint64 value) {
  set_has_expirydate();
  expirydate_ = value;
  // @@protoc_insertion_point(field_set:BlockKeyProto.expiryDate)
}

// optional bytes keyBytes = 3;
inline bool BlockKeyProto::has_keybytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockKeyProto::set_has_keybytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockKeyProto::clear_has_keybytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockKeyProto::clear_keybytes() {
  keybytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keybytes();
}
inline const ::std::string& BlockKeyProto::keybytes() const {
  // @@protoc_insertion_point(field_get:BlockKeyProto.keyBytes)
  return keybytes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockKeyProto::set_keybytes(const ::std::string& value) {
  set_has_keybytes();
  keybytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BlockKeyProto.keyBytes)
}
inline void BlockKeyProto::set_keybytes(const char* value) {
  set_has_keybytes();
  keybytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BlockKeyProto.keyBytes)
}
inline void BlockKeyProto::set_keybytes(const void* value, size_t size) {
  set_has_keybytes();
  keybytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BlockKeyProto.keyBytes)
}
inline ::std::string* BlockKeyProto::mutable_keybytes() {
  set_has_keybytes();
  // @@protoc_insertion_point(field_mutable:BlockKeyProto.keyBytes)
  return keybytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockKeyProto::release_keybytes() {
  // @@protoc_insertion_point(field_release:BlockKeyProto.keyBytes)
  clear_has_keybytes();
  return keybytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockKeyProto::set_allocated_keybytes(::std::string* keybytes) {
  if (keybytes != NULL) {
    set_has_keybytes();
  } else {
    clear_has_keybytes();
  }
  keybytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keybytes);
  // @@protoc_insertion_point(field_set_allocated:BlockKeyProto.keyBytes)
}

// -------------------------------------------------------------------

// ExportedBlockKeysProto

// required bool isBlockTokenEnabled = 1;
inline bool ExportedBlockKeysProto::has_isblocktokenenabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExportedBlockKeysProto::set_has_isblocktokenenabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExportedBlockKeysProto::clear_has_isblocktokenenabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExportedBlockKeysProto::clear_isblocktokenenabled() {
  isblocktokenenabled_ = false;
  clear_has_isblocktokenenabled();
}
inline bool ExportedBlockKeysProto::isblocktokenenabled() const {
  // @@protoc_insertion_point(field_get:ExportedBlockKeysProto.isBlockTokenEnabled)
  return isblocktokenenabled_;
}
inline void ExportedBlockKeysProto::set_isblocktokenenabled(bool value) {
  set_has_isblocktokenenabled();
  isblocktokenenabled_ = value;
  // @@protoc_insertion_point(field_set:ExportedBlockKeysProto.isBlockTokenEnabled)
}

// required uint64 keyUpdateInterval = 2;
inline bool ExportedBlockKeysProto::has_keyupdateinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExportedBlockKeysProto::set_has_keyupdateinterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExportedBlockKeysProto::clear_has_keyupdateinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExportedBlockKeysProto::clear_keyupdateinterval() {
  keyupdateinterval_ = GOOGLE_ULONGLONG(0);
  clear_has_keyupdateinterval();
}
inline ::google::protobuf::uint64 ExportedBlockKeysProto::keyupdateinterval() const {
  // @@protoc_insertion_point(field_get:ExportedBlockKeysProto.keyUpdateInterval)
  return keyupdateinterval_;
}
inline void ExportedBlockKeysProto::set_keyupdateinterval(::google::protobuf::uint64 value) {
  set_has_keyupdateinterval();
  keyupdateinterval_ = value;
  // @@protoc_insertion_point(field_set:ExportedBlockKeysProto.keyUpdateInterval)
}

// required uint64 tokenLifeTime = 3;
inline bool ExportedBlockKeysProto::has_tokenlifetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExportedBlockKeysProto::set_has_tokenlifetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExportedBlockKeysProto::clear_has_tokenlifetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExportedBlockKeysProto::clear_tokenlifetime() {
  tokenlifetime_ = GOOGLE_ULONGLONG(0);
  clear_has_tokenlifetime();
}
inline ::google::protobuf::uint64 ExportedBlockKeysProto::tokenlifetime() const {
  // @@protoc_insertion_point(field_get:ExportedBlockKeysProto.tokenLifeTime)
  return tokenlifetime_;
}
inline void ExportedBlockKeysProto::set_tokenlifetime(::google::protobuf::uint64 value) {
  set_has_tokenlifetime();
  tokenlifetime_ = value;
  // @@protoc_insertion_point(field_set:ExportedBlockKeysProto.tokenLifeTime)
}

// required .BlockKeyProto currentKey = 4;
inline bool ExportedBlockKeysProto::has_currentkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExportedBlockKeysProto::set_has_currentkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExportedBlockKeysProto::clear_has_currentkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExportedBlockKeysProto::clear_currentkey() {
  if (currentkey_ != NULL) currentkey_->::BlockKeyProto::Clear();
  clear_has_currentkey();
}
inline const ::BlockKeyProto& ExportedBlockKeysProto::currentkey() const {
  // @@protoc_insertion_point(field_get:ExportedBlockKeysProto.currentKey)
  return currentkey_ != NULL ? *currentkey_ : *default_instance_->currentkey_;
}
inline ::BlockKeyProto* ExportedBlockKeysProto::mutable_currentkey() {
  set_has_currentkey();
  if (currentkey_ == NULL) {
    currentkey_ = new ::BlockKeyProto;
  }
  // @@protoc_insertion_point(field_mutable:ExportedBlockKeysProto.currentKey)
  return currentkey_;
}
inline ::BlockKeyProto* ExportedBlockKeysProto::release_currentkey() {
  // @@protoc_insertion_point(field_release:ExportedBlockKeysProto.currentKey)
  clear_has_currentkey();
  ::BlockKeyProto* temp = currentkey_;
  currentkey_ = NULL;
  return temp;
}
inline void ExportedBlockKeysProto::set_allocated_currentkey(::BlockKeyProto* currentkey) {
  delete currentkey_;
  currentkey_ = currentkey;
  if (currentkey) {
    set_has_currentkey();
  } else {
    clear_has_currentkey();
  }
  // @@protoc_insertion_point(field_set_allocated:ExportedBlockKeysProto.currentKey)
}

// repeated .BlockKeyProto allKeys = 5;
inline int ExportedBlockKeysProto::allkeys_size() const {
  return allkeys_.size();
}
inline void ExportedBlockKeysProto::clear_allkeys() {
  allkeys_.Clear();
}
inline const ::BlockKeyProto& ExportedBlockKeysProto::allkeys(int index) const {
  // @@protoc_insertion_point(field_get:ExportedBlockKeysProto.allKeys)
  return allkeys_.Get(index);
}
inline ::BlockKeyProto* ExportedBlockKeysProto::mutable_allkeys(int index) {
  // @@protoc_insertion_point(field_mutable:ExportedBlockKeysProto.allKeys)
  return allkeys_.Mutable(index);
}
inline ::BlockKeyProto* ExportedBlockKeysProto::add_allkeys() {
  // @@protoc_insertion_point(field_add:ExportedBlockKeysProto.allKeys)
  return allkeys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::BlockKeyProto >*
ExportedBlockKeysProto::mutable_allkeys() {
  // @@protoc_insertion_point(field_mutable_list:ExportedBlockKeysProto.allKeys)
  return &allkeys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::BlockKeyProto >&
ExportedBlockKeysProto::allkeys() const {
  // @@protoc_insertion_point(field_list:ExportedBlockKeysProto.allKeys)
  return allkeys_;
}

// -------------------------------------------------------------------

// DatanodeRegistrationProto

// required .DatanodeIDProto datanodeID = 1;
inline bool DatanodeRegistrationProto::has_datanodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatanodeRegistrationProto::set_has_datanodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatanodeRegistrationProto::clear_has_datanodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatanodeRegistrationProto::clear_datanodeid() {
  if (datanodeid_ != NULL) datanodeid_->::DatanodeIDProto::Clear();
  clear_has_datanodeid();
}
inline const ::DatanodeIDProto& DatanodeRegistrationProto::datanodeid() const {
  // @@protoc_insertion_point(field_get:DatanodeRegistrationProto.datanodeID)
  return datanodeid_ != NULL ? *datanodeid_ : *default_instance_->datanodeid_;
}
inline ::DatanodeIDProto* DatanodeRegistrationProto::mutable_datanodeid() {
  set_has_datanodeid();
  if (datanodeid_ == NULL) {
    datanodeid_ = new ::DatanodeIDProto;
  }
  // @@protoc_insertion_point(field_mutable:DatanodeRegistrationProto.datanodeID)
  return datanodeid_;
}
inline ::DatanodeIDProto* DatanodeRegistrationProto::release_datanodeid() {
  // @@protoc_insertion_point(field_release:DatanodeRegistrationProto.datanodeID)
  clear_has_datanodeid();
  ::DatanodeIDProto* temp = datanodeid_;
  datanodeid_ = NULL;
  return temp;
}
inline void DatanodeRegistrationProto::set_allocated_datanodeid(::DatanodeIDProto* datanodeid) {
  delete datanodeid_;
  datanodeid_ = datanodeid;
  if (datanodeid) {
    set_has_datanodeid();
  } else {
    clear_has_datanodeid();
  }
  // @@protoc_insertion_point(field_set_allocated:DatanodeRegistrationProto.datanodeID)
}

// optional .StorageInfoProto storageInfo = 2;
inline bool DatanodeRegistrationProto::has_storageinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatanodeRegistrationProto::set_has_storageinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatanodeRegistrationProto::clear_has_storageinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatanodeRegistrationProto::clear_storageinfo() {
  if (storageinfo_ != NULL) storageinfo_->::StorageInfoProto::Clear();
  clear_has_storageinfo();
}
inline const ::StorageInfoProto& DatanodeRegistrationProto::storageinfo() const {
  // @@protoc_insertion_point(field_get:DatanodeRegistrationProto.storageInfo)
  return storageinfo_ != NULL ? *storageinfo_ : *default_instance_->storageinfo_;
}
inline ::StorageInfoProto* DatanodeRegistrationProto::mutable_storageinfo() {
  set_has_storageinfo();
  if (storageinfo_ == NULL) {
    storageinfo_ = new ::StorageInfoProto;
  }
  // @@protoc_insertion_point(field_mutable:DatanodeRegistrationProto.storageInfo)
  return storageinfo_;
}
inline ::StorageInfoProto* DatanodeRegistrationProto::release_storageinfo() {
  // @@protoc_insertion_point(field_release:DatanodeRegistrationProto.storageInfo)
  clear_has_storageinfo();
  ::StorageInfoProto* temp = storageinfo_;
  storageinfo_ = NULL;
  return temp;
}
inline void DatanodeRegistrationProto::set_allocated_storageinfo(::StorageInfoProto* storageinfo) {
  delete storageinfo_;
  storageinfo_ = storageinfo;
  if (storageinfo) {
    set_has_storageinfo();
  } else {
    clear_has_storageinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:DatanodeRegistrationProto.storageInfo)
}

// optional .ExportedBlockKeysProto keys = 3;
inline bool DatanodeRegistrationProto::has_keys() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatanodeRegistrationProto::set_has_keys() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatanodeRegistrationProto::clear_has_keys() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatanodeRegistrationProto::clear_keys() {
  if (keys_ != NULL) keys_->::ExportedBlockKeysProto::Clear();
  clear_has_keys();
}
inline const ::ExportedBlockKeysProto& DatanodeRegistrationProto::keys() const {
  // @@protoc_insertion_point(field_get:DatanodeRegistrationProto.keys)
  return keys_ != NULL ? *keys_ : *default_instance_->keys_;
}
inline ::ExportedBlockKeysProto* DatanodeRegistrationProto::mutable_keys() {
  set_has_keys();
  if (keys_ == NULL) {
    keys_ = new ::ExportedBlockKeysProto;
  }
  // @@protoc_insertion_point(field_mutable:DatanodeRegistrationProto.keys)
  return keys_;
}
inline ::ExportedBlockKeysProto* DatanodeRegistrationProto::release_keys() {
  // @@protoc_insertion_point(field_release:DatanodeRegistrationProto.keys)
  clear_has_keys();
  ::ExportedBlockKeysProto* temp = keys_;
  keys_ = NULL;
  return temp;
}
inline void DatanodeRegistrationProto::set_allocated_keys(::ExportedBlockKeysProto* keys) {
  delete keys_;
  keys_ = keys;
  if (keys) {
    set_has_keys();
  } else {
    clear_has_keys();
  }
  // @@protoc_insertion_point(field_set_allocated:DatanodeRegistrationProto.keys)
}

// optional string softwareVersion = 4;
inline bool DatanodeRegistrationProto::has_softwareversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DatanodeRegistrationProto::set_has_softwareversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DatanodeRegistrationProto::clear_has_softwareversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DatanodeRegistrationProto::clear_softwareversion() {
  softwareversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_softwareversion();
}
inline const ::std::string& DatanodeRegistrationProto::softwareversion() const {
  // @@protoc_insertion_point(field_get:DatanodeRegistrationProto.softwareVersion)
  return softwareversion_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeRegistrationProto::set_softwareversion(const ::std::string& value) {
  set_has_softwareversion();
  softwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DatanodeRegistrationProto.softwareVersion)
}
inline void DatanodeRegistrationProto::set_softwareversion(const char* value) {
  set_has_softwareversion();
  softwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DatanodeRegistrationProto.softwareVersion)
}
inline void DatanodeRegistrationProto::set_softwareversion(const char* value, size_t size) {
  set_has_softwareversion();
  softwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DatanodeRegistrationProto.softwareVersion)
}
inline ::std::string* DatanodeRegistrationProto::mutable_softwareversion() {
  set_has_softwareversion();
  // @@protoc_insertion_point(field_mutable:DatanodeRegistrationProto.softwareVersion)
  return softwareversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatanodeRegistrationProto::release_softwareversion() {
  // @@protoc_insertion_point(field_release:DatanodeRegistrationProto.softwareVersion)
  clear_has_softwareversion();
  return softwareversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatanodeRegistrationProto::set_allocated_softwareversion(::std::string* softwareversion) {
  if (softwareversion != NULL) {
    set_has_softwareversion();
  } else {
    clear_has_softwareversion();
  }
  softwareversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), softwareversion);
  // @@protoc_insertion_point(field_set_allocated:DatanodeRegistrationProto.softwareVersion)
}

// optional bool master = 5;
inline bool DatanodeRegistrationProto::has_master() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DatanodeRegistrationProto::set_has_master() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DatanodeRegistrationProto::clear_has_master() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DatanodeRegistrationProto::clear_master() {
  master_ = false;
  clear_has_master();
}
inline bool DatanodeRegistrationProto::master() const {
  // @@protoc_insertion_point(field_get:DatanodeRegistrationProto.master)
  return master_;
}
inline void DatanodeRegistrationProto::set_master(bool value) {
  set_has_master();
  master_ = value;
  // @@protoc_insertion_point(field_set:DatanodeRegistrationProto.master)
}

// -------------------------------------------------------------------

// RegisterDatanodeRequestProto

// required .DatanodeRegistrationProto registration = 1;
inline bool RegisterDatanodeRequestProto::has_registration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterDatanodeRequestProto::set_has_registration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterDatanodeRequestProto::clear_has_registration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterDatanodeRequestProto::clear_registration() {
  if (registration_ != NULL) registration_->::DatanodeRegistrationProto::Clear();
  clear_has_registration();
}
inline const ::DatanodeRegistrationProto& RegisterDatanodeRequestProto::registration() const {
  // @@protoc_insertion_point(field_get:RegisterDatanodeRequestProto.registration)
  return registration_ != NULL ? *registration_ : *default_instance_->registration_;
}
inline ::DatanodeRegistrationProto* RegisterDatanodeRequestProto::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) {
    registration_ = new ::DatanodeRegistrationProto;
  }
  // @@protoc_insertion_point(field_mutable:RegisterDatanodeRequestProto.registration)
  return registration_;
}
inline ::DatanodeRegistrationProto* RegisterDatanodeRequestProto::release_registration() {
  // @@protoc_insertion_point(field_release:RegisterDatanodeRequestProto.registration)
  clear_has_registration();
  ::DatanodeRegistrationProto* temp = registration_;
  registration_ = NULL;
  return temp;
}
inline void RegisterDatanodeRequestProto::set_allocated_registration(::DatanodeRegistrationProto* registration) {
  delete registration_;
  registration_ = registration;
  if (registration) {
    set_has_registration();
  } else {
    clear_has_registration();
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterDatanodeRequestProto.registration)
}

// -------------------------------------------------------------------

// RegisterDatanodeResponseProto

// required .DatanodeRegistrationProto registration = 1;
inline bool RegisterDatanodeResponseProto::has_registration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterDatanodeResponseProto::set_has_registration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterDatanodeResponseProto::clear_has_registration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterDatanodeResponseProto::clear_registration() {
  if (registration_ != NULL) registration_->::DatanodeRegistrationProto::Clear();
  clear_has_registration();
}
inline const ::DatanodeRegistrationProto& RegisterDatanodeResponseProto::registration() const {
  // @@protoc_insertion_point(field_get:RegisterDatanodeResponseProto.registration)
  return registration_ != NULL ? *registration_ : *default_instance_->registration_;
}
inline ::DatanodeRegistrationProto* RegisterDatanodeResponseProto::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) {
    registration_ = new ::DatanodeRegistrationProto;
  }
  // @@protoc_insertion_point(field_mutable:RegisterDatanodeResponseProto.registration)
  return registration_;
}
inline ::DatanodeRegistrationProto* RegisterDatanodeResponseProto::release_registration() {
  // @@protoc_insertion_point(field_release:RegisterDatanodeResponseProto.registration)
  clear_has_registration();
  ::DatanodeRegistrationProto* temp = registration_;
  registration_ = NULL;
  return temp;
}
inline void RegisterDatanodeResponseProto::set_allocated_registration(::DatanodeRegistrationProto* registration) {
  delete registration_;
  registration_ = registration;
  if (registration) {
    set_has_registration();
  } else {
    clear_has_registration();
  }
  // @@protoc_insertion_point(field_set_allocated:RegisterDatanodeResponseProto.registration)
}

// -------------------------------------------------------------------

// DatanodeHeartbeatRequestProto

// required .DatanodeIDProto id = 1;
inline bool DatanodeHeartbeatRequestProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatanodeHeartbeatRequestProto::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatanodeHeartbeatRequestProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatanodeHeartbeatRequestProto::clear_id() {
  if (id_ != NULL) id_->::DatanodeIDProto::Clear();
  clear_has_id();
}
inline const ::DatanodeIDProto& DatanodeHeartbeatRequestProto::id() const {
  // @@protoc_insertion_point(field_get:DatanodeHeartbeatRequestProto.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::DatanodeIDProto* DatanodeHeartbeatRequestProto::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::DatanodeIDProto;
  }
  // @@protoc_insertion_point(field_mutable:DatanodeHeartbeatRequestProto.id)
  return id_;
}
inline ::DatanodeIDProto* DatanodeHeartbeatRequestProto::release_id() {
  // @@protoc_insertion_point(field_release:DatanodeHeartbeatRequestProto.id)
  clear_has_id();
  ::DatanodeIDProto* temp = id_;
  id_ = NULL;
  return temp;
}
inline void DatanodeHeartbeatRequestProto::set_allocated_id(::DatanodeIDProto* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:DatanodeHeartbeatRequestProto.id)
}

// -------------------------------------------------------------------

// DatanodeHeartbeatResponseProto

// -------------------------------------------------------------------

// DataTransferTraceInfoProto

// required uint64 traceId = 1;
inline bool DataTransferTraceInfoProto::has_traceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataTransferTraceInfoProto::set_has_traceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataTransferTraceInfoProto::clear_has_traceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataTransferTraceInfoProto::clear_traceid() {
  traceid_ = GOOGLE_ULONGLONG(0);
  clear_has_traceid();
}
inline ::google::protobuf::uint64 DataTransferTraceInfoProto::traceid() const {
  // @@protoc_insertion_point(field_get:DataTransferTraceInfoProto.traceId)
  return traceid_;
}
inline void DataTransferTraceInfoProto::set_traceid(::google::protobuf::uint64 value) {
  set_has_traceid();
  traceid_ = value;
  // @@protoc_insertion_point(field_set:DataTransferTraceInfoProto.traceId)
}

// required uint64 parentId = 2;
inline bool DataTransferTraceInfoProto::has_parentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataTransferTraceInfoProto::set_has_parentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataTransferTraceInfoProto::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataTransferTraceInfoProto::clear_parentid() {
  parentid_ = GOOGLE_ULONGLONG(0);
  clear_has_parentid();
}
inline ::google::protobuf::uint64 DataTransferTraceInfoProto::parentid() const {
  // @@protoc_insertion_point(field_get:DataTransferTraceInfoProto.parentId)
  return parentid_;
}
inline void DataTransferTraceInfoProto::set_parentid(::google::protobuf::uint64 value) {
  set_has_parentid();
  parentid_ = value;
  // @@protoc_insertion_point(field_set:DataTransferTraceInfoProto.parentId)
}

// -------------------------------------------------------------------

// BaseHeaderProto

// required .ExtendedBlockProto block = 1;
inline bool BaseHeaderProto::has_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseHeaderProto::set_has_block() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseHeaderProto::clear_has_block() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseHeaderProto::clear_block() {
  if (block_ != NULL) block_->::ExtendedBlockProto::Clear();
  clear_has_block();
}
inline const ::ExtendedBlockProto& BaseHeaderProto::block() const {
  // @@protoc_insertion_point(field_get:BaseHeaderProto.block)
  return block_ != NULL ? *block_ : *default_instance_->block_;
}
inline ::ExtendedBlockProto* BaseHeaderProto::mutable_block() {
  set_has_block();
  if (block_ == NULL) {
    block_ = new ::ExtendedBlockProto;
  }
  // @@protoc_insertion_point(field_mutable:BaseHeaderProto.block)
  return block_;
}
inline ::ExtendedBlockProto* BaseHeaderProto::release_block() {
  // @@protoc_insertion_point(field_release:BaseHeaderProto.block)
  clear_has_block();
  ::ExtendedBlockProto* temp = block_;
  block_ = NULL;
  return temp;
}
inline void BaseHeaderProto::set_allocated_block(::ExtendedBlockProto* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
  // @@protoc_insertion_point(field_set_allocated:BaseHeaderProto.block)
}

// optional .TokenProto token = 2;
inline bool BaseHeaderProto::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseHeaderProto::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseHeaderProto::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseHeaderProto::clear_token() {
  if (token_ != NULL) token_->::TokenProto::Clear();
  clear_has_token();
}
inline const ::TokenProto& BaseHeaderProto::token() const {
  // @@protoc_insertion_point(field_get:BaseHeaderProto.token)
  return token_ != NULL ? *token_ : *default_instance_->token_;
}
inline ::TokenProto* BaseHeaderProto::mutable_token() {
  set_has_token();
  if (token_ == NULL) {
    token_ = new ::TokenProto;
  }
  // @@protoc_insertion_point(field_mutable:BaseHeaderProto.token)
  return token_;
}
inline ::TokenProto* BaseHeaderProto::release_token() {
  // @@protoc_insertion_point(field_release:BaseHeaderProto.token)
  clear_has_token();
  ::TokenProto* temp = token_;
  token_ = NULL;
  return temp;
}
inline void BaseHeaderProto::set_allocated_token(::TokenProto* token) {
  delete token_;
  token_ = token;
  if (token) {
    set_has_token();
  } else {
    clear_has_token();
  }
  // @@protoc_insertion_point(field_set_allocated:BaseHeaderProto.token)
}

// optional .DataTransferTraceInfoProto traceInfo = 3;
inline bool BaseHeaderProto::has_traceinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BaseHeaderProto::set_has_traceinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BaseHeaderProto::clear_has_traceinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BaseHeaderProto::clear_traceinfo() {
  if (traceinfo_ != NULL) traceinfo_->::DataTransferTraceInfoProto::Clear();
  clear_has_traceinfo();
}
inline const ::DataTransferTraceInfoProto& BaseHeaderProto::traceinfo() const {
  // @@protoc_insertion_point(field_get:BaseHeaderProto.traceInfo)
  return traceinfo_ != NULL ? *traceinfo_ : *default_instance_->traceinfo_;
}
inline ::DataTransferTraceInfoProto* BaseHeaderProto::mutable_traceinfo() {
  set_has_traceinfo();
  if (traceinfo_ == NULL) {
    traceinfo_ = new ::DataTransferTraceInfoProto;
  }
  // @@protoc_insertion_point(field_mutable:BaseHeaderProto.traceInfo)
  return traceinfo_;
}
inline ::DataTransferTraceInfoProto* BaseHeaderProto::release_traceinfo() {
  // @@protoc_insertion_point(field_release:BaseHeaderProto.traceInfo)
  clear_has_traceinfo();
  ::DataTransferTraceInfoProto* temp = traceinfo_;
  traceinfo_ = NULL;
  return temp;
}
inline void BaseHeaderProto::set_allocated_traceinfo(::DataTransferTraceInfoProto* traceinfo) {
  delete traceinfo_;
  traceinfo_ = traceinfo;
  if (traceinfo) {
    set_has_traceinfo();
  } else {
    clear_has_traceinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:BaseHeaderProto.traceInfo)
}

// -------------------------------------------------------------------

// ClientOperationHeaderProto

// required .BaseHeaderProto baseHeader = 1;
inline bool ClientOperationHeaderProto::has_baseheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientOperationHeaderProto::set_has_baseheader() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientOperationHeaderProto::clear_has_baseheader() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientOperationHeaderProto::clear_baseheader() {
  if (baseheader_ != NULL) baseheader_->::BaseHeaderProto::Clear();
  clear_has_baseheader();
}
inline const ::BaseHeaderProto& ClientOperationHeaderProto::baseheader() const {
  // @@protoc_insertion_point(field_get:ClientOperationHeaderProto.baseHeader)
  return baseheader_ != NULL ? *baseheader_ : *default_instance_->baseheader_;
}
inline ::BaseHeaderProto* ClientOperationHeaderProto::mutable_baseheader() {
  set_has_baseheader();
  if (baseheader_ == NULL) {
    baseheader_ = new ::BaseHeaderProto;
  }
  // @@protoc_insertion_point(field_mutable:ClientOperationHeaderProto.baseHeader)
  return baseheader_;
}
inline ::BaseHeaderProto* ClientOperationHeaderProto::release_baseheader() {
  // @@protoc_insertion_point(field_release:ClientOperationHeaderProto.baseHeader)
  clear_has_baseheader();
  ::BaseHeaderProto* temp = baseheader_;
  baseheader_ = NULL;
  return temp;
}
inline void ClientOperationHeaderProto::set_allocated_baseheader(::BaseHeaderProto* baseheader) {
  delete baseheader_;
  baseheader_ = baseheader;
  if (baseheader) {
    set_has_baseheader();
  } else {
    clear_has_baseheader();
  }
  // @@protoc_insertion_point(field_set_allocated:ClientOperationHeaderProto.baseHeader)
}

// required string clientName = 2;
inline bool ClientOperationHeaderProto::has_clientname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientOperationHeaderProto::set_has_clientname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientOperationHeaderProto::clear_has_clientname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientOperationHeaderProto::clear_clientname() {
  clientname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientname();
}
inline const ::std::string& ClientOperationHeaderProto::clientname() const {
  // @@protoc_insertion_point(field_get:ClientOperationHeaderProto.clientName)
  return clientname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientOperationHeaderProto::set_clientname(const ::std::string& value) {
  set_has_clientname();
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ClientOperationHeaderProto.clientName)
}
inline void ClientOperationHeaderProto::set_clientname(const char* value) {
  set_has_clientname();
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ClientOperationHeaderProto.clientName)
}
inline void ClientOperationHeaderProto::set_clientname(const char* value, size_t size) {
  set_has_clientname();
  clientname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ClientOperationHeaderProto.clientName)
}
inline ::std::string* ClientOperationHeaderProto::mutable_clientname() {
  set_has_clientname();
  // @@protoc_insertion_point(field_mutable:ClientOperationHeaderProto.clientName)
  return clientname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientOperationHeaderProto::release_clientname() {
  // @@protoc_insertion_point(field_release:ClientOperationHeaderProto.clientName)
  clear_has_clientname();
  return clientname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientOperationHeaderProto::set_allocated_clientname(::std::string* clientname) {
  if (clientname != NULL) {
    set_has_clientname();
  } else {
    clear_has_clientname();
  }
  clientname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientname);
  // @@protoc_insertion_point(field_set_allocated:ClientOperationHeaderProto.clientName)
}

// -------------------------------------------------------------------

// OpTransferBlockProto

// required .ClientOperationHeaderProto header = 1;
inline bool OpTransferBlockProto::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpTransferBlockProto::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpTransferBlockProto::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpTransferBlockProto::clear_header() {
  if (header_ != NULL) header_->::ClientOperationHeaderProto::Clear();
  clear_has_header();
}
inline const ::ClientOperationHeaderProto& OpTransferBlockProto::header() const {
  // @@protoc_insertion_point(field_get:OpTransferBlockProto.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::ClientOperationHeaderProto* OpTransferBlockProto::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ClientOperationHeaderProto;
  }
  // @@protoc_insertion_point(field_mutable:OpTransferBlockProto.header)
  return header_;
}
inline ::ClientOperationHeaderProto* OpTransferBlockProto::release_header() {
  // @@protoc_insertion_point(field_release:OpTransferBlockProto.header)
  clear_has_header();
  ::ClientOperationHeaderProto* temp = header_;
  header_ = NULL;
  return temp;
}
inline void OpTransferBlockProto::set_allocated_header(::ClientOperationHeaderProto* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:OpTransferBlockProto.header)
}

// repeated .DatanodeInfoProto targets = 2;
inline int OpTransferBlockProto::targets_size() const {
  return targets_.size();
}
inline void OpTransferBlockProto::clear_targets() {
  targets_.Clear();
}
inline const ::DatanodeInfoProto& OpTransferBlockProto::targets(int index) const {
  // @@protoc_insertion_point(field_get:OpTransferBlockProto.targets)
  return targets_.Get(index);
}
inline ::DatanodeInfoProto* OpTransferBlockProto::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:OpTransferBlockProto.targets)
  return targets_.Mutable(index);
}
inline ::DatanodeInfoProto* OpTransferBlockProto::add_targets() {
  // @@protoc_insertion_point(field_add:OpTransferBlockProto.targets)
  return targets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >*
OpTransferBlockProto::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:OpTransferBlockProto.targets)
  return &targets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::DatanodeInfoProto >&
OpTransferBlockProto::targets() const {
  // @@protoc_insertion_point(field_list:OpTransferBlockProto.targets)
  return targets_;
}

// repeated .StorageTypeProto targetStorageTypes = 3;
inline int OpTransferBlockProto::targetstoragetypes_size() const {
  return targetstoragetypes_.size();
}
inline void OpTransferBlockProto::clear_targetstoragetypes() {
  targetstoragetypes_.Clear();
}
inline ::StorageTypeProto OpTransferBlockProto::targetstoragetypes(int index) const {
  // @@protoc_insertion_point(field_get:OpTransferBlockProto.targetStorageTypes)
  return static_cast< ::StorageTypeProto >(targetstoragetypes_.Get(index));
}
inline void OpTransferBlockProto::set_targetstoragetypes(int index, ::StorageTypeProto value) {
  assert(::StorageTypeProto_IsValid(value));
  targetstoragetypes_.Set(index, value);
  // @@protoc_insertion_point(field_set:OpTransferBlockProto.targetStorageTypes)
}
inline void OpTransferBlockProto::add_targetstoragetypes(::StorageTypeProto value) {
  assert(::StorageTypeProto_IsValid(value));
  targetstoragetypes_.Add(value);
  // @@protoc_insertion_point(field_add:OpTransferBlockProto.targetStorageTypes)
}
inline const ::google::protobuf::RepeatedField<int>&
OpTransferBlockProto::targetstoragetypes() const {
  // @@protoc_insertion_point(field_list:OpTransferBlockProto.targetStorageTypes)
  return targetstoragetypes_;
}
inline ::google::protobuf::RepeatedField<int>*
OpTransferBlockProto::mutable_targetstoragetypes() {
  // @@protoc_insertion_point(field_mutable_list:OpTransferBlockProto.targetStorageTypes)
  return &targetstoragetypes_;
}

// -------------------------------------------------------------------

// OpBlockChecksumResponseProto

// required uint32 bytesPerCrc = 1;
inline bool OpBlockChecksumResponseProto::has_bytespercrc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpBlockChecksumResponseProto::set_has_bytespercrc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpBlockChecksumResponseProto::clear_has_bytespercrc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpBlockChecksumResponseProto::clear_bytespercrc() {
  bytespercrc_ = 0u;
  clear_has_bytespercrc();
}
inline ::google::protobuf::uint32 OpBlockChecksumResponseProto::bytespercrc() const {
  // @@protoc_insertion_point(field_get:OpBlockChecksumResponseProto.bytesPerCrc)
  return bytespercrc_;
}
inline void OpBlockChecksumResponseProto::set_bytespercrc(::google::protobuf::uint32 value) {
  set_has_bytespercrc();
  bytespercrc_ = value;
  // @@protoc_insertion_point(field_set:OpBlockChecksumResponseProto.bytesPerCrc)
}

// required uint64 crcPerBlock = 2;
inline bool OpBlockChecksumResponseProto::has_crcperblock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpBlockChecksumResponseProto::set_has_crcperblock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpBlockChecksumResponseProto::clear_has_crcperblock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpBlockChecksumResponseProto::clear_crcperblock() {
  crcperblock_ = GOOGLE_ULONGLONG(0);
  clear_has_crcperblock();
}
inline ::google::protobuf::uint64 OpBlockChecksumResponseProto::crcperblock() const {
  // @@protoc_insertion_point(field_get:OpBlockChecksumResponseProto.crcPerBlock)
  return crcperblock_;
}
inline void OpBlockChecksumResponseProto::set_crcperblock(::google::protobuf::uint64 value) {
  set_has_crcperblock();
  crcperblock_ = value;
  // @@protoc_insertion_point(field_set:OpBlockChecksumResponseProto.crcPerBlock)
}

// required bytes md5 = 3;
inline bool OpBlockChecksumResponseProto::has_md5() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpBlockChecksumResponseProto::set_has_md5() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpBlockChecksumResponseProto::clear_has_md5() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpBlockChecksumResponseProto::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_md5();
}
inline const ::std::string& OpBlockChecksumResponseProto::md5() const {
  // @@protoc_insertion_point(field_get:OpBlockChecksumResponseProto.md5)
  return md5_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpBlockChecksumResponseProto::set_md5(const ::std::string& value) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OpBlockChecksumResponseProto.md5)
}
inline void OpBlockChecksumResponseProto::set_md5(const char* value) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OpBlockChecksumResponseProto.md5)
}
inline void OpBlockChecksumResponseProto::set_md5(const void* value, size_t size) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OpBlockChecksumResponseProto.md5)
}
inline ::std::string* OpBlockChecksumResponseProto::mutable_md5() {
  set_has_md5();
  // @@protoc_insertion_point(field_mutable:OpBlockChecksumResponseProto.md5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpBlockChecksumResponseProto::release_md5() {
  // @@protoc_insertion_point(field_release:OpBlockChecksumResponseProto.md5)
  clear_has_md5();
  return md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpBlockChecksumResponseProto::set_allocated_md5(::std::string* md5) {
  if (md5 != NULL) {
    set_has_md5();
  } else {
    clear_has_md5();
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:OpBlockChecksumResponseProto.md5)
}

// optional .ChecksumTypeProto crcType = 4;
inline bool OpBlockChecksumResponseProto::has_crctype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpBlockChecksumResponseProto::set_has_crctype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpBlockChecksumResponseProto::clear_has_crctype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpBlockChecksumResponseProto::clear_crctype() {
  crctype_ = 0;
  clear_has_crctype();
}
inline ::ChecksumTypeProto OpBlockChecksumResponseProto::crctype() const {
  // @@protoc_insertion_point(field_get:OpBlockChecksumResponseProto.crcType)
  return static_cast< ::ChecksumTypeProto >(crctype_);
}
inline void OpBlockChecksumResponseProto::set_crctype(::ChecksumTypeProto value) {
  assert(::ChecksumTypeProto_IsValid(value));
  set_has_crctype();
  crctype_ = value;
  // @@protoc_insertion_point(field_set:OpBlockChecksumResponseProto.crcType)
}

// -------------------------------------------------------------------

// ChecksumProto

// required .ChecksumTypeProto type = 1;
inline bool ChecksumProto::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChecksumProto::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChecksumProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChecksumProto::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ChecksumTypeProto ChecksumProto::type() const {
  // @@protoc_insertion_point(field_get:ChecksumProto.type)
  return static_cast< ::ChecksumTypeProto >(type_);
}
inline void ChecksumProto::set_type(::ChecksumTypeProto value) {
  assert(::ChecksumTypeProto_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ChecksumProto.type)
}

// required uint32 bytesPerChecksum = 2;
inline bool ChecksumProto::has_bytesperchecksum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChecksumProto::set_has_bytesperchecksum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChecksumProto::clear_has_bytesperchecksum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChecksumProto::clear_bytesperchecksum() {
  bytesperchecksum_ = 0u;
  clear_has_bytesperchecksum();
}
inline ::google::protobuf::uint32 ChecksumProto::bytesperchecksum() const {
  // @@protoc_insertion_point(field_get:ChecksumProto.bytesPerChecksum)
  return bytesperchecksum_;
}
inline void ChecksumProto::set_bytesperchecksum(::google::protobuf::uint32 value) {
  set_has_bytesperchecksum();
  bytesperchecksum_ = value;
  // @@protoc_insertion_point(field_set:ChecksumProto.bytesPerChecksum)
}

// -------------------------------------------------------------------

// ReadOpChecksumInfoProto

// required .ChecksumProto checksum = 1;
inline bool ReadOpChecksumInfoProto::has_checksum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadOpChecksumInfoProto::set_has_checksum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadOpChecksumInfoProto::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadOpChecksumInfoProto::clear_checksum() {
  if (checksum_ != NULL) checksum_->::ChecksumProto::Clear();
  clear_has_checksum();
}
inline const ::ChecksumProto& ReadOpChecksumInfoProto::checksum() const {
  // @@protoc_insertion_point(field_get:ReadOpChecksumInfoProto.checksum)
  return checksum_ != NULL ? *checksum_ : *default_instance_->checksum_;
}
inline ::ChecksumProto* ReadOpChecksumInfoProto::mutable_checksum() {
  set_has_checksum();
  if (checksum_ == NULL) {
    checksum_ = new ::ChecksumProto;
  }
  // @@protoc_insertion_point(field_mutable:ReadOpChecksumInfoProto.checksum)
  return checksum_;
}
inline ::ChecksumProto* ReadOpChecksumInfoProto::release_checksum() {
  // @@protoc_insertion_point(field_release:ReadOpChecksumInfoProto.checksum)
  clear_has_checksum();
  ::ChecksumProto* temp = checksum_;
  checksum_ = NULL;
  return temp;
}
inline void ReadOpChecksumInfoProto::set_allocated_checksum(::ChecksumProto* checksum) {
  delete checksum_;
  checksum_ = checksum;
  if (checksum) {
    set_has_checksum();
  } else {
    clear_has_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:ReadOpChecksumInfoProto.checksum)
}

// required uint64 chunkOffset = 2;
inline bool ReadOpChecksumInfoProto::has_chunkoffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadOpChecksumInfoProto::set_has_chunkoffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadOpChecksumInfoProto::clear_has_chunkoffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadOpChecksumInfoProto::clear_chunkoffset() {
  chunkoffset_ = GOOGLE_ULONGLONG(0);
  clear_has_chunkoffset();
}
inline ::google::protobuf::uint64 ReadOpChecksumInfoProto::chunkoffset() const {
  // @@protoc_insertion_point(field_get:ReadOpChecksumInfoProto.chunkOffset)
  return chunkoffset_;
}
inline void ReadOpChecksumInfoProto::set_chunkoffset(::google::protobuf::uint64 value) {
  set_has_chunkoffset();
  chunkoffset_ = value;
  // @@protoc_insertion_point(field_set:ReadOpChecksumInfoProto.chunkOffset)
}

// -------------------------------------------------------------------

// BlockOpResponseProto

// required .Status status = 1;
inline bool BlockOpResponseProto::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockOpResponseProto::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockOpResponseProto::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockOpResponseProto::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::Status BlockOpResponseProto::status() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.status)
  return static_cast< ::Status >(status_);
}
inline void BlockOpResponseProto::set_status(::Status value) {
  assert(::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:BlockOpResponseProto.status)
}

// optional string firstBadLink = 2;
inline bool BlockOpResponseProto::has_firstbadlink() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockOpResponseProto::set_has_firstbadlink() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockOpResponseProto::clear_has_firstbadlink() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockOpResponseProto::clear_firstbadlink() {
  firstbadlink_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_firstbadlink();
}
inline const ::std::string& BlockOpResponseProto::firstbadlink() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.firstBadLink)
  return firstbadlink_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockOpResponseProto::set_firstbadlink(const ::std::string& value) {
  set_has_firstbadlink();
  firstbadlink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BlockOpResponseProto.firstBadLink)
}
inline void BlockOpResponseProto::set_firstbadlink(const char* value) {
  set_has_firstbadlink();
  firstbadlink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BlockOpResponseProto.firstBadLink)
}
inline void BlockOpResponseProto::set_firstbadlink(const char* value, size_t size) {
  set_has_firstbadlink();
  firstbadlink_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BlockOpResponseProto.firstBadLink)
}
inline ::std::string* BlockOpResponseProto::mutable_firstbadlink() {
  set_has_firstbadlink();
  // @@protoc_insertion_point(field_mutable:BlockOpResponseProto.firstBadLink)
  return firstbadlink_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockOpResponseProto::release_firstbadlink() {
  // @@protoc_insertion_point(field_release:BlockOpResponseProto.firstBadLink)
  clear_has_firstbadlink();
  return firstbadlink_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockOpResponseProto::set_allocated_firstbadlink(::std::string* firstbadlink) {
  if (firstbadlink != NULL) {
    set_has_firstbadlink();
  } else {
    clear_has_firstbadlink();
  }
  firstbadlink_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firstbadlink);
  // @@protoc_insertion_point(field_set_allocated:BlockOpResponseProto.firstBadLink)
}

// optional .OpBlockChecksumResponseProto checksumResponse = 3;
inline bool BlockOpResponseProto::has_checksumresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockOpResponseProto::set_has_checksumresponse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockOpResponseProto::clear_has_checksumresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockOpResponseProto::clear_checksumresponse() {
  if (checksumresponse_ != NULL) checksumresponse_->::OpBlockChecksumResponseProto::Clear();
  clear_has_checksumresponse();
}
inline const ::OpBlockChecksumResponseProto& BlockOpResponseProto::checksumresponse() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.checksumResponse)
  return checksumresponse_ != NULL ? *checksumresponse_ : *default_instance_->checksumresponse_;
}
inline ::OpBlockChecksumResponseProto* BlockOpResponseProto::mutable_checksumresponse() {
  set_has_checksumresponse();
  if (checksumresponse_ == NULL) {
    checksumresponse_ = new ::OpBlockChecksumResponseProto;
  }
  // @@protoc_insertion_point(field_mutable:BlockOpResponseProto.checksumResponse)
  return checksumresponse_;
}
inline ::OpBlockChecksumResponseProto* BlockOpResponseProto::release_checksumresponse() {
  // @@protoc_insertion_point(field_release:BlockOpResponseProto.checksumResponse)
  clear_has_checksumresponse();
  ::OpBlockChecksumResponseProto* temp = checksumresponse_;
  checksumresponse_ = NULL;
  return temp;
}
inline void BlockOpResponseProto::set_allocated_checksumresponse(::OpBlockChecksumResponseProto* checksumresponse) {
  delete checksumresponse_;
  checksumresponse_ = checksumresponse;
  if (checksumresponse) {
    set_has_checksumresponse();
  } else {
    clear_has_checksumresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:BlockOpResponseProto.checksumResponse)
}

// optional .ReadOpChecksumInfoProto readOpChecksumInfo = 4;
inline bool BlockOpResponseProto::has_readopchecksuminfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlockOpResponseProto::set_has_readopchecksuminfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlockOpResponseProto::clear_has_readopchecksuminfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlockOpResponseProto::clear_readopchecksuminfo() {
  if (readopchecksuminfo_ != NULL) readopchecksuminfo_->::ReadOpChecksumInfoProto::Clear();
  clear_has_readopchecksuminfo();
}
inline const ::ReadOpChecksumInfoProto& BlockOpResponseProto::readopchecksuminfo() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.readOpChecksumInfo)
  return readopchecksuminfo_ != NULL ? *readopchecksuminfo_ : *default_instance_->readopchecksuminfo_;
}
inline ::ReadOpChecksumInfoProto* BlockOpResponseProto::mutable_readopchecksuminfo() {
  set_has_readopchecksuminfo();
  if (readopchecksuminfo_ == NULL) {
    readopchecksuminfo_ = new ::ReadOpChecksumInfoProto;
  }
  // @@protoc_insertion_point(field_mutable:BlockOpResponseProto.readOpChecksumInfo)
  return readopchecksuminfo_;
}
inline ::ReadOpChecksumInfoProto* BlockOpResponseProto::release_readopchecksuminfo() {
  // @@protoc_insertion_point(field_release:BlockOpResponseProto.readOpChecksumInfo)
  clear_has_readopchecksuminfo();
  ::ReadOpChecksumInfoProto* temp = readopchecksuminfo_;
  readopchecksuminfo_ = NULL;
  return temp;
}
inline void BlockOpResponseProto::set_allocated_readopchecksuminfo(::ReadOpChecksumInfoProto* readopchecksuminfo) {
  delete readopchecksuminfo_;
  readopchecksuminfo_ = readopchecksuminfo;
  if (readopchecksuminfo) {
    set_has_readopchecksuminfo();
  } else {
    clear_has_readopchecksuminfo();
  }
  // @@protoc_insertion_point(field_set_allocated:BlockOpResponseProto.readOpChecksumInfo)
}

// optional string message = 5;
inline bool BlockOpResponseProto::has_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlockOpResponseProto::set_has_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlockOpResponseProto::clear_has_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlockOpResponseProto::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& BlockOpResponseProto::message() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockOpResponseProto::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BlockOpResponseProto.message)
}
inline void BlockOpResponseProto::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BlockOpResponseProto.message)
}
inline void BlockOpResponseProto::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BlockOpResponseProto.message)
}
inline ::std::string* BlockOpResponseProto::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:BlockOpResponseProto.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockOpResponseProto::release_message() {
  // @@protoc_insertion_point(field_release:BlockOpResponseProto.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockOpResponseProto::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:BlockOpResponseProto.message)
}

// optional uint32 shortCircuitAccessVersion = 6;
inline bool BlockOpResponseProto::has_shortcircuitaccessversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlockOpResponseProto::set_has_shortcircuitaccessversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlockOpResponseProto::clear_has_shortcircuitaccessversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlockOpResponseProto::clear_shortcircuitaccessversion() {
  shortcircuitaccessversion_ = 0u;
  clear_has_shortcircuitaccessversion();
}
inline ::google::protobuf::uint32 BlockOpResponseProto::shortcircuitaccessversion() const {
  // @@protoc_insertion_point(field_get:BlockOpResponseProto.shortCircuitAccessVersion)
  return shortcircuitaccessversion_;
}
inline void BlockOpResponseProto::set_shortcircuitaccessversion(::google::protobuf::uint32 value) {
  set_has_shortcircuitaccessversion();
  shortcircuitaccessversion_ = value;
  // @@protoc_insertion_point(field_set:BlockOpResponseProto.shortCircuitAccessVersion)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::RpcRequestHeaderProto_OperationProto> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RpcRequestHeaderProto_OperationProto>() {
  return ::RpcRequestHeaderProto_OperationProto_descriptor();
}
template <> struct is_proto_enum< ::RpcResponseHeaderProto_RpcStatusProto> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RpcResponseHeaderProto_RpcStatusProto>() {
  return ::RpcResponseHeaderProto_RpcStatusProto_descriptor();
}
template <> struct is_proto_enum< ::RpcResponseHeaderProto_RpcErrorCodeProto> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RpcResponseHeaderProto_RpcErrorCodeProto>() {
  return ::RpcResponseHeaderProto_RpcErrorCodeProto_descriptor();
}
template <> struct is_proto_enum< ::DatanodeInfoProto_AdminState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DatanodeInfoProto_AdminState>() {
  return ::DatanodeInfoProto_AdminState_descriptor();
}
template <> struct is_proto_enum< ::RpcKindProto> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RpcKindProto>() {
  return ::RpcKindProto_descriptor();
}
template <> struct is_proto_enum< ::StorageTypeProto> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::StorageTypeProto>() {
  return ::StorageTypeProto_descriptor();
}
template <> struct is_proto_enum< ::CipherSuiteProto> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CipherSuiteProto>() {
  return ::CipherSuiteProto_descriptor();
}
template <> struct is_proto_enum< ::CryptoProtocolVersionProto> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CryptoProtocolVersionProto>() {
  return ::CryptoProtocolVersionProto_descriptor();
}
template <> struct is_proto_enum< ::ChecksumTypeProto> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChecksumTypeProto>() {
  return ::ChecksumTypeProto_descriptor();
}
template <> struct is_proto_enum< ::Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Status>() {
  return ::Status_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
